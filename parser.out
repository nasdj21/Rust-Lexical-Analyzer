Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BIT_NOT
    BIT_XOR
    BREAK
    CONTINUE
    DIVIDE_EQUAL
    ENUM
    LOOP
    MATCH
    MINUS_EQUAL
    MOD_EQUAL
    PLUS_EQUAL
    SHIFT_LEFT
    SHIFT_RIGHT
    THEN
    TIMES_EQUAL
    WHERE

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     program_opt -> program
Rule 4     program_opt -> empty
Rule 5     empty -> <empty>
Rule 6     statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
Rule 7     statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON
Rule 8     statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
Rule 9     expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
Rule 10    expression -> expression DOT IDENTIFIER LPAREN expression RPAREN
Rule 11    expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
Rule 12    statement -> expression SEMICOLON
Rule 13    expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
Rule 14    arguments_opt -> argument_list
Rule 15    arguments_opt -> empty
Rule 16    argument_list -> argument_list COMMA expression
Rule 17    argument_list -> expression
Rule 18    closure_params -> <empty>
Rule 19    closure_params -> IDENTIFIER
Rule 20    closure_params -> IDENTIFIER COLON type
Rule 21    closure_params -> IDENTIFIER COMMA closure_params
Rule 22    closure_params -> IDENTIFIER COLON type COMMA closure_params
Rule 23    closure_body -> expression
Rule 24    closure_body -> LBRACE closure_block_content RBRACE
Rule 25    closure_block_content -> expression
Rule 26    closure_block_content -> program expression
Rule 27    closure_block_content -> program_opt
Rule 28    expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
Rule 29    expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
Rule 30    expression -> LPAREN expression RPAREN
Rule 31    expression -> expression PLUS expression
Rule 32    expression -> expression MINUS expression
Rule 33    expression -> expression TIMES expression
Rule 34    expression -> expression DIVIDE expression
Rule 35    expression -> expression MOD expression
Rule 36    expression -> expression RANGE expression
Rule 37    expression -> expression RANGE_INCLUSIVE expression
Rule 38    expression -> expression EQUAL_TO expression
Rule 39    expression -> expression NOT_EQUAL expression
Rule 40    expression -> expression LESS_THAN expression
Rule 41    expression -> expression GREATER_THAN expression
Rule 42    expression -> expression LESS_THAN_OR_EQUAL_TO expression
Rule 43    expression -> expression GREATER_THAN_OR_EQUAL_TO expression
Rule 44    expression -> expression CONJUNCTION expression
Rule 45    expression -> expression DISJUNCTION expression
Rule 46    expression -> NOT expression
Rule 47    expression -> MINUS expression
Rule 48    expression -> INTEGER
Rule 49    expression -> FLOAT
Rule 50    expression -> STRING
Rule 51    expression -> CHAR
Rule 52    expression -> BOOLEAN
Rule 53    expression -> IDENTIFIER
Rule 54    expression -> BIT_AND expression
Rule 55    expression -> BIT_AND MUT IDENTIFIER
Rule 56    expression -> expression AS type
Rule 57    condition -> expression EQUAL_TO expression
Rule 58    condition -> expression NOT_EQUAL expression
Rule 59    condition -> expression LESS_THAN expression
Rule 60    condition -> expression GREATER_THAN expression
Rule 61    condition -> expression LESS_THAN_OR_EQUAL_TO expression
Rule 62    condition -> expression GREATER_THAN_OR_EQUAL_TO expression
Rule 63    condition -> condition CONJUNCTION condition
Rule 64    condition -> condition DISJUNCTION condition
Rule 65    condition -> NOT condition
Rule 66    condition -> LPAREN condition RPAREN
Rule 67    condition -> expression
Rule 68    condition -> BOOLEAN
Rule 69    statement -> IF condition LBRACE program_opt RBRACE
Rule 70    statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
Rule 71    statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON
Rule 72    statement -> WHILE condition LBRACE program_opt RBRACE
Rule 73    statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
Rule 74    statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
Rule 75    type -> TYPE_I32
Rule 76    type -> TYPE_U8
Rule 77    type -> TYPE_U16
Rule 78    type -> TYPE_U32
Rule 79    type -> TYPE_U64
Rule 80    type -> TYPE_F64
Rule 81    type -> TYPE_CHAR
Rule 82    type -> TYPE_STRING
Rule 83    type -> TYPE_STR
Rule 84    type -> TYPE_BOOL
Rule 85    type -> TYPE_TUPLE
Rule 86    type -> LBRACKET type RBRACKET
Rule 87    type -> LBRACKET type COMMA INTEGER RBRACKET
Rule 88    type -> BIT_AND type
Rule 89    type -> BIT_AND MUT type
Rule 90    statement -> let_decl
Rule 91    let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
Rule 92    maybe_mut -> MUT
Rule 93    maybe_mut -> empty
Rule 94    maybe_type -> COLON type
Rule 95    maybe_type -> empty
Rule 96    maybe_init -> ASIGNED_TO expression
Rule 97    maybe_init -> empty
Rule 98    element_list -> element_list COMMA expression
Rule 99    element_list -> expression
Rule 100   expression -> LBRACKET element_list RBRACKET
Rule 101   expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET
Rule 102   expression -> IDENTIFIER LBRACKET expression RBRACKET
Rule 103   expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
Rule 104   expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
Rule 105   expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET
Rule 106   statement -> const_decl
Rule 107   const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
Rule 108   type -> LPAREN tuple_type_list RPAREN
Rule 109   tuple_type_list -> type
Rule 110   tuple_type_list -> type COMMA tuple_type_list
Rule 111   expression -> LPAREN tuple_value_list RPAREN
Rule 112   tuple_value_list -> expression
Rule 113   tuple_value_list -> expression COMMA tuple_value_list
Rule 114   expression -> expression DOT INTEGER
Rule 115   statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
Rule 116   maybe_pub -> IDENTIFIER
Rule 117   maybe_pub -> empty
Rule 118   function_name -> IDENTIFIER
Rule 119   function_name -> MAIN
Rule 120   statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
Rule 121   statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
Rule 122   statement -> RETURN expression SEMICOLON
Rule 123   expression -> IDENTIFIER LPAREN arguments_opt RPAREN

Terminals, with rules where they appear

ARROW                : 29 73 120
AS                   : 56
ASIGNED_TO           : 71 96 107
ASYNC                : 73 74
BIT_AND              : 54 55 88 89
BIT_NOT              : 
BIT_XOR              : 
BOOLEAN              : 52 68
BREAK                : 
CHAR                 : 51
CLOSURE_PIPE         : 28 28 29 29
COLON                : 20 22 94 107
COMMA                : 8 9 16 21 22 87 98 110 113
CONJUNCTION          : 44 63
CONST                : 107
CONTINUE             : 
DISJUNCTION          : 45 64
DIVIDE               : 34
DIVIDE_EQUAL         : 
DOT                  : 9 10 13 114
DOUBLE_COLON         : 11
ELSE                 : 70
ENUM                 : 
EQUAL_TO             : 38 57
FLOAT                : 49
FN                   : 73 74 120 121
FOR                  : 115
GREATER_THAN         : 41 60
GREATER_THAN_OR_EQUAL_TO : 43 62
IDENTIFIER           : 9 10 11 11 13 19 20 21 22 53 55 71 91 102 103 104 105 107 115 116 118 123
IF                   : 69 70
IN                   : 115
INTEGER              : 48 87 101 103 103 104 104 114
LBRACE               : 24 69 70 70 72 73 74 115 120 121
LBRACKET             : 86 87 100 101 102 103 104 105
LESS_THAN            : 40 59
LESS_THAN_OR_EQUAL_TO : 42 61
LET                  : 91
LOOP                 : 
LPAREN               : 6 7 8 9 10 11 13 30 66 73 74 108 111 120 121 123
MAIN                 : 119
MATCH                : 
MINUS                : 32 47
MINUS_EQUAL          : 
MOD                  : 35
MOD_EQUAL            : 
MUT                  : 55 89 92
NOT                  : 6 7 8 46 65 105
NOT_EQUAL            : 39 58
PLUS                 : 31
PLUS_EQUAL           : 
PRINTLN              : 6 7 8
RANGE                : 36 103
RANGE_INCLUSIVE      : 37 104
RBRACE               : 24 69 70 70 72 73 74 115 120 121
RBRACKET             : 86 87 100 101 102 103 104 105
RETURN               : 122
RPAREN               : 6 7 8 9 10 11 13 30 66 73 74 108 111 120 121 123
SEMICOLON            : 6 7 8 12 71 91 101 107 122
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
STRING               : 6 8 50
THEN                 : 
TIMES                : 33
TIMES_EQUAL          : 
TYPE_BOOL            : 84
TYPE_CHAR            : 81
TYPE_F64             : 80
TYPE_I32             : 75
TYPE_STR             : 83
TYPE_STRING          : 82
TYPE_TUPLE           : 85
TYPE_U16             : 77
TYPE_U32             : 78
TYPE_U64             : 79
TYPE_U8              : 76
WHERE                : 
WHILE                : 72
error                : 

Nonterminals, with rules where they appear

argument_list        : 8 14 16
arguments_opt        : 13 123
closure_block_content : 24
closure_body         : 28 29
closure_params       : 21 22 28 29
condition            : 63 63 64 64 65 66 69 70 72
const_decl           : 106
element_list         : 98 100 105
empty                : 4 15 93 95 97 117
expression           : 7 9 9 9 10 10 12 13 16 17 23 25 26 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 47 54 56 57 57 58 58 59 59 60 60 61 61 62 62 67 71 96 98 99 101 102 107 112 113 114 115 122
function_name        : 73 74 120 121
let_decl             : 90
maybe_init           : 91
maybe_mut            : 91
maybe_pub            : 120 121
maybe_type           : 91
program              : 1 3 26 0
program_opt          : 27 69 70 70 72 73 74 115 120 121
statement            : 1 2
tuple_type_list      : 108 110
tuple_value_list     : 111 113
type                 : 20 22 29 56 73 86 87 88 89 94 107 109 110 120

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    program                        shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    statement                      shift and go to state 28
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 2

    (2) program -> statement .

    PRINTLN         reduce using rule 2 (program -> statement .)
    IF              reduce using rule 2 (program -> statement .)
    IDENTIFIER      reduce using rule 2 (program -> statement .)
    WHILE           reduce using rule 2 (program -> statement .)
    ASYNC           reduce using rule 2 (program -> statement .)
    FOR             reduce using rule 2 (program -> statement .)
    RETURN          reduce using rule 2 (program -> statement .)
    CLOSURE_PIPE    reduce using rule 2 (program -> statement .)
    LPAREN          reduce using rule 2 (program -> statement .)
    NOT             reduce using rule 2 (program -> statement .)
    MINUS           reduce using rule 2 (program -> statement .)
    INTEGER         reduce using rule 2 (program -> statement .)
    FLOAT           reduce using rule 2 (program -> statement .)
    STRING          reduce using rule 2 (program -> statement .)
    CHAR            reduce using rule 2 (program -> statement .)
    BOOLEAN         reduce using rule 2 (program -> statement .)
    BIT_AND         reduce using rule 2 (program -> statement .)
    LBRACKET        reduce using rule 2 (program -> statement .)
    LET             reduce using rule 2 (program -> statement .)
    CONST           reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)
    FN              reduce using rule 2 (program -> statement .)
    RBRACE          reduce using rule 2 (program -> statement .)


state 3

    (6) statement -> PRINTLN . NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN . NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> PRINTLN . NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON

    NOT             shift and go to state 29


state 4

    (46) expression -> NOT . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 30

state 5

    (30) expression -> LPAREN . expression RPAREN
    (111) expression -> LPAREN . tuple_value_list RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (112) tuple_value_list -> . expression
    (113) tuple_value_list -> . expression COMMA tuple_value_list

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 32
    tuple_value_list               shift and go to state 33

state 6

    (50) expression -> STRING .

    SEMICOLON       reduce using rule 50 (expression -> STRING .)
    DOT             reduce using rule 50 (expression -> STRING .)
    PLUS            reduce using rule 50 (expression -> STRING .)
    MINUS           reduce using rule 50 (expression -> STRING .)
    TIMES           reduce using rule 50 (expression -> STRING .)
    DIVIDE          reduce using rule 50 (expression -> STRING .)
    MOD             reduce using rule 50 (expression -> STRING .)
    RANGE           reduce using rule 50 (expression -> STRING .)
    RANGE_INCLUSIVE reduce using rule 50 (expression -> STRING .)
    EQUAL_TO        reduce using rule 50 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 50 (expression -> STRING .)
    LESS_THAN       reduce using rule 50 (expression -> STRING .)
    GREATER_THAN    reduce using rule 50 (expression -> STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    CONJUNCTION     reduce using rule 50 (expression -> STRING .)
    DISJUNCTION     reduce using rule 50 (expression -> STRING .)
    AS              reduce using rule 50 (expression -> STRING .)
    RPAREN          reduce using rule 50 (expression -> STRING .)
    COMMA           reduce using rule 50 (expression -> STRING .)
    LBRACE          reduce using rule 50 (expression -> STRING .)
    RBRACKET        reduce using rule 50 (expression -> STRING .)
    RBRACE          reduce using rule 50 (expression -> STRING .)


state 7

    (12) statement -> expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 34
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 8

    (69) statement -> IF . condition LBRACE program_opt RBRACE
    (70) statement -> IF . condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (57) condition -> . expression EQUAL_TO expression
    (58) condition -> . expression NOT_EQUAL expression
    (59) condition -> . expression LESS_THAN expression
    (60) condition -> . expression GREATER_THAN expression
    (61) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (63) condition -> . condition CONJUNCTION condition
    (64) condition -> . condition DISJUNCTION condition
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN condition RPAREN
    (67) condition -> . expression
    (68) condition -> . BOOLEAN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 54
    LPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 56
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    condition                      shift and go to state 52
    expression                     shift and go to state 53

state 9

    (71) statement -> IDENTIFIER . ASIGNED_TO expression SEMICOLON
    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (53) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (103) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (123) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN
    (116) maybe_pub -> IDENTIFIER .

    ASIGNED_TO      shift and go to state 57
    DOUBLE_COLON    shift and go to state 58
    SEMICOLON       reduce using rule 53 (expression -> IDENTIFIER .)
    DOT             reduce using rule 53 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 53 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 53 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 53 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (expression -> IDENTIFIER .)
    MOD             reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE           reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 53 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    AS              reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 60
    NOT             shift and go to state 61
    LPAREN          shift and go to state 59
    FN              reduce using rule 116 (maybe_pub -> IDENTIFIER .)


state 10

    (72) statement -> WHILE . condition LBRACE program_opt RBRACE
    (57) condition -> . expression EQUAL_TO expression
    (58) condition -> . expression NOT_EQUAL expression
    (59) condition -> . expression LESS_THAN expression
    (60) condition -> . expression GREATER_THAN expression
    (61) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (63) condition -> . condition CONJUNCTION condition
    (64) condition -> . condition DISJUNCTION condition
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN condition RPAREN
    (67) condition -> . expression
    (68) condition -> . BOOLEAN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 54
    LPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 56
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    condition                      shift and go to state 62
    expression                     shift and go to state 53

state 11

    (73) statement -> ASYNC . FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> ASYNC . FN function_name LPAREN RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 63


state 12

    (90) statement -> let_decl .

    PRINTLN         reduce using rule 90 (statement -> let_decl .)
    IF              reduce using rule 90 (statement -> let_decl .)
    IDENTIFIER      reduce using rule 90 (statement -> let_decl .)
    WHILE           reduce using rule 90 (statement -> let_decl .)
    ASYNC           reduce using rule 90 (statement -> let_decl .)
    FOR             reduce using rule 90 (statement -> let_decl .)
    RETURN          reduce using rule 90 (statement -> let_decl .)
    CLOSURE_PIPE    reduce using rule 90 (statement -> let_decl .)
    LPAREN          reduce using rule 90 (statement -> let_decl .)
    NOT             reduce using rule 90 (statement -> let_decl .)
    MINUS           reduce using rule 90 (statement -> let_decl .)
    INTEGER         reduce using rule 90 (statement -> let_decl .)
    FLOAT           reduce using rule 90 (statement -> let_decl .)
    STRING          reduce using rule 90 (statement -> let_decl .)
    CHAR            reduce using rule 90 (statement -> let_decl .)
    BOOLEAN         reduce using rule 90 (statement -> let_decl .)
    BIT_AND         reduce using rule 90 (statement -> let_decl .)
    LBRACKET        reduce using rule 90 (statement -> let_decl .)
    LET             reduce using rule 90 (statement -> let_decl .)
    CONST           reduce using rule 90 (statement -> let_decl .)
    $end            reduce using rule 90 (statement -> let_decl .)
    FN              reduce using rule 90 (statement -> let_decl .)
    RBRACE          reduce using rule 90 (statement -> let_decl .)


state 13

    (106) statement -> const_decl .

    PRINTLN         reduce using rule 106 (statement -> const_decl .)
    IF              reduce using rule 106 (statement -> const_decl .)
    IDENTIFIER      reduce using rule 106 (statement -> const_decl .)
    WHILE           reduce using rule 106 (statement -> const_decl .)
    ASYNC           reduce using rule 106 (statement -> const_decl .)
    FOR             reduce using rule 106 (statement -> const_decl .)
    RETURN          reduce using rule 106 (statement -> const_decl .)
    CLOSURE_PIPE    reduce using rule 106 (statement -> const_decl .)
    LPAREN          reduce using rule 106 (statement -> const_decl .)
    NOT             reduce using rule 106 (statement -> const_decl .)
    MINUS           reduce using rule 106 (statement -> const_decl .)
    INTEGER         reduce using rule 106 (statement -> const_decl .)
    FLOAT           reduce using rule 106 (statement -> const_decl .)
    STRING          reduce using rule 106 (statement -> const_decl .)
    CHAR            reduce using rule 106 (statement -> const_decl .)
    BOOLEAN         reduce using rule 106 (statement -> const_decl .)
    BIT_AND         reduce using rule 106 (statement -> const_decl .)
    LBRACKET        reduce using rule 106 (statement -> const_decl .)
    LET             reduce using rule 106 (statement -> const_decl .)
    CONST           reduce using rule 106 (statement -> const_decl .)
    $end            reduce using rule 106 (statement -> const_decl .)
    FN              reduce using rule 106 (statement -> const_decl .)
    RBRACE          reduce using rule 106 (statement -> const_decl .)


state 14

    (115) statement -> FOR . IDENTIFIER IN expression LBRACE program_opt RBRACE

    IDENTIFIER      shift and go to state 64


state 15

    (120) statement -> maybe_pub . FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> maybe_pub . FN function_name LPAREN RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 65


state 16

    (122) statement -> RETURN . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 66

state 17

    (28) expression -> CLOSURE_PIPE . closure_params CLOSURE_PIPE closure_body
    (29) expression -> CLOSURE_PIPE . closure_params CLOSURE_PIPE ARROW type closure_body
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 68

    closure_params                 shift and go to state 67

state 18

    (47) expression -> MINUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 69

state 19

    (48) expression -> INTEGER .

    SEMICOLON       reduce using rule 48 (expression -> INTEGER .)
    DOT             reduce using rule 48 (expression -> INTEGER .)
    PLUS            reduce using rule 48 (expression -> INTEGER .)
    MINUS           reduce using rule 48 (expression -> INTEGER .)
    TIMES           reduce using rule 48 (expression -> INTEGER .)
    DIVIDE          reduce using rule 48 (expression -> INTEGER .)
    MOD             reduce using rule 48 (expression -> INTEGER .)
    RANGE           reduce using rule 48 (expression -> INTEGER .)
    RANGE_INCLUSIVE reduce using rule 48 (expression -> INTEGER .)
    EQUAL_TO        reduce using rule 48 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN       reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN    reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    CONJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    DISJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    AS              reduce using rule 48 (expression -> INTEGER .)
    RPAREN          reduce using rule 48 (expression -> INTEGER .)
    COMMA           reduce using rule 48 (expression -> INTEGER .)
    LBRACE          reduce using rule 48 (expression -> INTEGER .)
    RBRACKET        reduce using rule 48 (expression -> INTEGER .)
    RBRACE          reduce using rule 48 (expression -> INTEGER .)


state 20

    (49) expression -> FLOAT .

    SEMICOLON       reduce using rule 49 (expression -> FLOAT .)
    DOT             reduce using rule 49 (expression -> FLOAT .)
    PLUS            reduce using rule 49 (expression -> FLOAT .)
    MINUS           reduce using rule 49 (expression -> FLOAT .)
    TIMES           reduce using rule 49 (expression -> FLOAT .)
    DIVIDE          reduce using rule 49 (expression -> FLOAT .)
    MOD             reduce using rule 49 (expression -> FLOAT .)
    RANGE           reduce using rule 49 (expression -> FLOAT .)
    RANGE_INCLUSIVE reduce using rule 49 (expression -> FLOAT .)
    EQUAL_TO        reduce using rule 49 (expression -> FLOAT .)
    NOT_EQUAL       reduce using rule 49 (expression -> FLOAT .)
    LESS_THAN       reduce using rule 49 (expression -> FLOAT .)
    GREATER_THAN    reduce using rule 49 (expression -> FLOAT .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 49 (expression -> FLOAT .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 49 (expression -> FLOAT .)
    CONJUNCTION     reduce using rule 49 (expression -> FLOAT .)
    DISJUNCTION     reduce using rule 49 (expression -> FLOAT .)
    AS              reduce using rule 49 (expression -> FLOAT .)
    RPAREN          reduce using rule 49 (expression -> FLOAT .)
    COMMA           reduce using rule 49 (expression -> FLOAT .)
    LBRACE          reduce using rule 49 (expression -> FLOAT .)
    RBRACKET        reduce using rule 49 (expression -> FLOAT .)
    RBRACE          reduce using rule 49 (expression -> FLOAT .)


state 21

    (51) expression -> CHAR .

    SEMICOLON       reduce using rule 51 (expression -> CHAR .)
    DOT             reduce using rule 51 (expression -> CHAR .)
    PLUS            reduce using rule 51 (expression -> CHAR .)
    MINUS           reduce using rule 51 (expression -> CHAR .)
    TIMES           reduce using rule 51 (expression -> CHAR .)
    DIVIDE          reduce using rule 51 (expression -> CHAR .)
    MOD             reduce using rule 51 (expression -> CHAR .)
    RANGE           reduce using rule 51 (expression -> CHAR .)
    RANGE_INCLUSIVE reduce using rule 51 (expression -> CHAR .)
    EQUAL_TO        reduce using rule 51 (expression -> CHAR .)
    NOT_EQUAL       reduce using rule 51 (expression -> CHAR .)
    LESS_THAN       reduce using rule 51 (expression -> CHAR .)
    GREATER_THAN    reduce using rule 51 (expression -> CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 51 (expression -> CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 51 (expression -> CHAR .)
    CONJUNCTION     reduce using rule 51 (expression -> CHAR .)
    DISJUNCTION     reduce using rule 51 (expression -> CHAR .)
    AS              reduce using rule 51 (expression -> CHAR .)
    RPAREN          reduce using rule 51 (expression -> CHAR .)
    COMMA           reduce using rule 51 (expression -> CHAR .)
    LBRACE          reduce using rule 51 (expression -> CHAR .)
    RBRACKET        reduce using rule 51 (expression -> CHAR .)
    RBRACE          reduce using rule 51 (expression -> CHAR .)


state 22

    (52) expression -> BOOLEAN .

    SEMICOLON       reduce using rule 52 (expression -> BOOLEAN .)
    DOT             reduce using rule 52 (expression -> BOOLEAN .)
    PLUS            reduce using rule 52 (expression -> BOOLEAN .)
    MINUS           reduce using rule 52 (expression -> BOOLEAN .)
    TIMES           reduce using rule 52 (expression -> BOOLEAN .)
    DIVIDE          reduce using rule 52 (expression -> BOOLEAN .)
    MOD             reduce using rule 52 (expression -> BOOLEAN .)
    RANGE           reduce using rule 52 (expression -> BOOLEAN .)
    RANGE_INCLUSIVE reduce using rule 52 (expression -> BOOLEAN .)
    EQUAL_TO        reduce using rule 52 (expression -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 52 (expression -> BOOLEAN .)
    LESS_THAN       reduce using rule 52 (expression -> BOOLEAN .)
    GREATER_THAN    reduce using rule 52 (expression -> BOOLEAN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 52 (expression -> BOOLEAN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 52 (expression -> BOOLEAN .)
    CONJUNCTION     reduce using rule 52 (expression -> BOOLEAN .)
    DISJUNCTION     reduce using rule 52 (expression -> BOOLEAN .)
    AS              reduce using rule 52 (expression -> BOOLEAN .)
    RPAREN          reduce using rule 52 (expression -> BOOLEAN .)
    COMMA           reduce using rule 52 (expression -> BOOLEAN .)
    LBRACE          reduce using rule 52 (expression -> BOOLEAN .)
    RBRACKET        reduce using rule 52 (expression -> BOOLEAN .)
    RBRACE          reduce using rule 52 (expression -> BOOLEAN .)


state 23

    (54) expression -> BIT_AND . expression
    (55) expression -> BIT_AND . MUT IDENTIFIER
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    MUT             shift and go to state 71
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 70

state 24

    (100) expression -> LBRACKET . element_list RBRACKET
    (101) expression -> LBRACKET . expression SEMICOLON INTEGER RBRACKET
    (98) element_list -> . element_list COMMA expression
    (99) element_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    element_list                   shift and go to state 72
    expression                     shift and go to state 73

state 25

    (91) let_decl -> LET . maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (92) maybe_mut -> . MUT
    (93) maybe_mut -> . empty
    (5) empty -> .

    MUT             shift and go to state 75
    IDENTIFIER      reduce using rule 5 (empty -> .)

    maybe_mut                      shift and go to state 74
    empty                          shift and go to state 76

state 26

    (107) const_decl -> CONST . IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON

    IDENTIFIER      shift and go to state 77


state 27

    (117) maybe_pub -> empty .

    FN              reduce using rule 117 (maybe_pub -> empty .)


state 28

    (1) program -> program statement .

    PRINTLN         reduce using rule 1 (program -> program statement .)
    IF              reduce using rule 1 (program -> program statement .)
    IDENTIFIER      reduce using rule 1 (program -> program statement .)
    WHILE           reduce using rule 1 (program -> program statement .)
    ASYNC           reduce using rule 1 (program -> program statement .)
    FOR             reduce using rule 1 (program -> program statement .)
    RETURN          reduce using rule 1 (program -> program statement .)
    CLOSURE_PIPE    reduce using rule 1 (program -> program statement .)
    LPAREN          reduce using rule 1 (program -> program statement .)
    NOT             reduce using rule 1 (program -> program statement .)
    MINUS           reduce using rule 1 (program -> program statement .)
    INTEGER         reduce using rule 1 (program -> program statement .)
    FLOAT           reduce using rule 1 (program -> program statement .)
    STRING          reduce using rule 1 (program -> program statement .)
    CHAR            reduce using rule 1 (program -> program statement .)
    BOOLEAN         reduce using rule 1 (program -> program statement .)
    BIT_AND         reduce using rule 1 (program -> program statement .)
    LBRACKET        reduce using rule 1 (program -> program statement .)
    LET             reduce using rule 1 (program -> program statement .)
    CONST           reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)
    FN              reduce using rule 1 (program -> program statement .)
    RBRACE          reduce using rule 1 (program -> program statement .)


state 29

    (6) statement -> PRINTLN NOT . LPAREN STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN NOT . LPAREN expression RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT . LPAREN STRING COMMA argument_list RPAREN SEMICOLON

    LPAREN          shift and go to state 78


state 30

    (46) expression -> NOT expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 46 (expression -> NOT expression .)
    DOT             reduce using rule 46 (expression -> NOT expression .)
    CONJUNCTION     reduce using rule 46 (expression -> NOT expression .)
    DISJUNCTION     reduce using rule 46 (expression -> NOT expression .)
    RPAREN          reduce using rule 46 (expression -> NOT expression .)
    COMMA           reduce using rule 46 (expression -> NOT expression .)
    LBRACE          reduce using rule 46 (expression -> NOT expression .)
    RBRACKET        reduce using rule 46 (expression -> NOT expression .)
    RBRACE          reduce using rule 46 (expression -> NOT expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 46 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 46 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 46 (expression -> NOT expression .) ]
  ! RANGE           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 46 (expression -> NOT expression .) ]
  ! EQUAL_TO        [ reduce using rule 46 (expression -> NOT expression .) ]
  ! NOT_EQUAL       [ reduce using rule 46 (expression -> NOT expression .) ]
  ! LESS_THAN       [ reduce using rule 46 (expression -> NOT expression .) ]
  ! GREATER_THAN    [ reduce using rule 46 (expression -> NOT expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 46 (expression -> NOT expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 46 (expression -> NOT expression .) ]
  ! AS              [ reduce using rule 46 (expression -> NOT expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 31

    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (53) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (103) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (123) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN

    DOUBLE_COLON    shift and go to state 58
    DOT             reduce using rule 53 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 53 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 53 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 53 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (expression -> IDENTIFIER .)
    MOD             reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE           reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 53 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    AS              reduce using rule 53 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 53 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 53 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 60
    NOT             shift and go to state 61
    LPAREN          shift and go to state 59


state 32

    (30) expression -> LPAREN expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER
    (112) tuple_value_list -> expression .
    (113) tuple_value_list -> expression . COMMA tuple_value_list

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 79
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    COMMA           shift and go to state 80

  ! RPAREN          [ reduce using rule 112 (tuple_value_list -> expression .) ]


state 33

    (111) expression -> LPAREN tuple_value_list . RPAREN

    RPAREN          shift and go to state 81


state 34

    (12) statement -> expression SEMICOLON .

    PRINTLN         reduce using rule 12 (statement -> expression SEMICOLON .)
    IF              reduce using rule 12 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 12 (statement -> expression SEMICOLON .)
    ASYNC           reduce using rule 12 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 12 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 12 (statement -> expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 12 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 12 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 12 (statement -> expression SEMICOLON .)
    MINUS           reduce using rule 12 (statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 12 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 12 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 12 (statement -> expression SEMICOLON .)
    CHAR            reduce using rule 12 (statement -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 12 (statement -> expression SEMICOLON .)
    BIT_AND         reduce using rule 12 (statement -> expression SEMICOLON .)
    LBRACKET        reduce using rule 12 (statement -> expression SEMICOLON .)
    LET             reduce using rule 12 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 12 (statement -> expression SEMICOLON .)
    $end            reduce using rule 12 (statement -> expression SEMICOLON .)
    FN              reduce using rule 12 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 12 (statement -> expression SEMICOLON .)


state 35

    (9) expression -> expression DOT . IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression DOT . IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression DOT . IDENTIFIER LPAREN arguments_opt RPAREN
    (114) expression -> expression DOT . INTEGER

    IDENTIFIER      shift and go to state 82
    INTEGER         shift and go to state 83


state 36

    (31) expression -> expression PLUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 84

state 37

    (32) expression -> expression MINUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 85

state 38

    (33) expression -> expression TIMES . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 86

state 39

    (34) expression -> expression DIVIDE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 87

state 40

    (35) expression -> expression MOD . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 88

state 41

    (36) expression -> expression RANGE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 89

state 42

    (37) expression -> expression RANGE_INCLUSIVE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 90

state 43

    (38) expression -> expression EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 91

state 44

    (39) expression -> expression NOT_EQUAL . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 92

state 45

    (40) expression -> expression LESS_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 93

state 46

    (41) expression -> expression GREATER_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 94

state 47

    (42) expression -> expression LESS_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 95

state 48

    (43) expression -> expression GREATER_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 96

state 49

    (44) expression -> expression CONJUNCTION . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 97

state 50

    (45) expression -> expression DISJUNCTION . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 98

state 51

    (56) expression -> expression AS . type
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 99

state 52

    (69) statement -> IF condition . LBRACE program_opt RBRACE
    (70) statement -> IF condition . LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (63) condition -> condition . CONJUNCTION condition
    (64) condition -> condition . DISJUNCTION condition

    LBRACE          shift and go to state 114
    CONJUNCTION     shift and go to state 115
    DISJUNCTION     shift and go to state 116


state 53

    (57) condition -> expression . EQUAL_TO expression
    (58) condition -> expression . NOT_EQUAL expression
    (59) condition -> expression . LESS_THAN expression
    (60) condition -> expression . GREATER_THAN expression
    (61) condition -> expression . LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (67) condition -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for CONJUNCTION resolved as shift
  ! shift/reduce conflict for DISJUNCTION resolved as shift
    EQUAL_TO        shift and go to state 117
    NOT_EQUAL       shift and go to state 118
    LESS_THAN       shift and go to state 119
    GREATER_THAN    shift and go to state 120
    LESS_THAN_OR_EQUAL_TO shift and go to state 121
    GREATER_THAN_OR_EQUAL_TO shift and go to state 122
    LBRACE          reduce using rule 67 (condition -> expression .)
    RPAREN          reduce using rule 67 (condition -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! CONJUNCTION     [ reduce using rule 67 (condition -> expression .) ]
  ! DISJUNCTION     [ reduce using rule 67 (condition -> expression .) ]


state 54

    (65) condition -> NOT . condition
    (46) expression -> NOT . expression
    (57) condition -> . expression EQUAL_TO expression
    (58) condition -> . expression NOT_EQUAL expression
    (59) condition -> . expression LESS_THAN expression
    (60) condition -> . expression GREATER_THAN expression
    (61) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (63) condition -> . condition CONJUNCTION condition
    (64) condition -> . condition DISJUNCTION condition
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN condition RPAREN
    (67) condition -> . expression
    (68) condition -> . BOOLEAN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 54
    LPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 56
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    condition                      shift and go to state 123
    expression                     shift and go to state 124

state 55

    (66) condition -> LPAREN . condition RPAREN
    (30) expression -> LPAREN . expression RPAREN
    (111) expression -> LPAREN . tuple_value_list RPAREN
    (57) condition -> . expression EQUAL_TO expression
    (58) condition -> . expression NOT_EQUAL expression
    (59) condition -> . expression LESS_THAN expression
    (60) condition -> . expression GREATER_THAN expression
    (61) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (63) condition -> . condition CONJUNCTION condition
    (64) condition -> . condition DISJUNCTION condition
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN condition RPAREN
    (67) condition -> . expression
    (68) condition -> . BOOLEAN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (112) tuple_value_list -> . expression
    (113) tuple_value_list -> . expression COMMA tuple_value_list

    NOT             shift and go to state 54
    LPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 56
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    condition                      shift and go to state 125
    expression                     shift and go to state 126
    tuple_value_list               shift and go to state 33

state 56

    (68) condition -> BOOLEAN .
    (52) expression -> BOOLEAN .

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 52 (expression -> BOOLEAN .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 52 (expression -> BOOLEAN .)
  ! reduce/reduce conflict for LBRACE resolved using rule 52 (expression -> BOOLEAN .)
  ! reduce/reduce conflict for RPAREN resolved using rule 52 (expression -> BOOLEAN .)
    EQUAL_TO        reduce using rule 52 (expression -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 52 (expression -> BOOLEAN .)
    LESS_THAN       reduce using rule 52 (expression -> BOOLEAN .)
    GREATER_THAN    reduce using rule 52 (expression -> BOOLEAN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 52 (expression -> BOOLEAN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 52 (expression -> BOOLEAN .)
    DOT             reduce using rule 52 (expression -> BOOLEAN .)
    PLUS            reduce using rule 52 (expression -> BOOLEAN .)
    MINUS           reduce using rule 52 (expression -> BOOLEAN .)
    TIMES           reduce using rule 52 (expression -> BOOLEAN .)
    DIVIDE          reduce using rule 52 (expression -> BOOLEAN .)
    MOD             reduce using rule 52 (expression -> BOOLEAN .)
    RANGE           reduce using rule 52 (expression -> BOOLEAN .)
    RANGE_INCLUSIVE reduce using rule 52 (expression -> BOOLEAN .)
    CONJUNCTION     reduce using rule 52 (expression -> BOOLEAN .)
    DISJUNCTION     reduce using rule 52 (expression -> BOOLEAN .)
    AS              reduce using rule 52 (expression -> BOOLEAN .)
    LBRACE          reduce using rule 52 (expression -> BOOLEAN .)
    RPAREN          reduce using rule 52 (expression -> BOOLEAN .)
    COMMA           reduce using rule 52 (expression -> BOOLEAN .)

  ! LBRACE          [ reduce using rule 68 (condition -> BOOLEAN .) ]
  ! CONJUNCTION     [ reduce using rule 68 (condition -> BOOLEAN .) ]
  ! DISJUNCTION     [ reduce using rule 68 (condition -> BOOLEAN .) ]
  ! RPAREN          [ reduce using rule 68 (condition -> BOOLEAN .) ]


state 57

    (71) statement -> IDENTIFIER ASIGNED_TO . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 127

state 58

    (11) expression -> IDENTIFIER DOUBLE_COLON . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 128


state 59

    (123) expression -> IDENTIFIER LPAREN . arguments_opt RPAREN
    (14) arguments_opt -> . argument_list
    (15) arguments_opt -> . empty
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (5) empty -> .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    arguments_opt                  shift and go to state 129
    argument_list                  shift and go to state 130
    empty                          shift and go to state 131
    expression                     shift and go to state 132

state 60

    (102) expression -> IDENTIFIER LBRACKET . expression RBRACKET
    (103) expression -> IDENTIFIER LBRACKET . INTEGER RANGE INTEGER RBRACKET
    (104) expression -> IDENTIFIER LBRACKET . INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    INTEGER         shift and go to state 134
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 133

state 61

    (105) expression -> IDENTIFIER NOT . LBRACKET element_list RBRACKET

    LBRACKET        shift and go to state 135


state 62

    (72) statement -> WHILE condition . LBRACE program_opt RBRACE
    (63) condition -> condition . CONJUNCTION condition
    (64) condition -> condition . DISJUNCTION condition

    LBRACE          shift and go to state 136
    CONJUNCTION     shift and go to state 115
    DISJUNCTION     shift and go to state 116


state 63

    (73) statement -> ASYNC FN . function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> ASYNC FN . function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (118) function_name -> . IDENTIFIER
    (119) function_name -> . MAIN

    IDENTIFIER      shift and go to state 138
    MAIN            shift and go to state 139

    function_name                  shift and go to state 137

state 64

    (115) statement -> FOR IDENTIFIER . IN expression LBRACE program_opt RBRACE

    IN              shift and go to state 140


state 65

    (120) statement -> maybe_pub FN . function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> maybe_pub FN . function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (118) function_name -> . IDENTIFIER
    (119) function_name -> . MAIN

    IDENTIFIER      shift and go to state 138
    MAIN            shift and go to state 139

    function_name                  shift and go to state 141

state 66

    (122) statement -> RETURN expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 142
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 67

    (28) expression -> CLOSURE_PIPE closure_params . CLOSURE_PIPE closure_body
    (29) expression -> CLOSURE_PIPE closure_params . CLOSURE_PIPE ARROW type closure_body

    CLOSURE_PIPE    shift and go to state 143


state 68

    (19) closure_params -> IDENTIFIER .
    (20) closure_params -> IDENTIFIER . COLON type
    (21) closure_params -> IDENTIFIER . COMMA closure_params
    (22) closure_params -> IDENTIFIER . COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 19 (closure_params -> IDENTIFIER .)
    COLON           shift and go to state 144
    COMMA           shift and go to state 145


state 69

    (47) expression -> MINUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 47 (expression -> MINUS expression .)
    DOT             reduce using rule 47 (expression -> MINUS expression .)
    PLUS            reduce using rule 47 (expression -> MINUS expression .)
    MINUS           reduce using rule 47 (expression -> MINUS expression .)
    TIMES           reduce using rule 47 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 47 (expression -> MINUS expression .)
    MOD             reduce using rule 47 (expression -> MINUS expression .)
    RANGE           reduce using rule 47 (expression -> MINUS expression .)
    RANGE_INCLUSIVE reduce using rule 47 (expression -> MINUS expression .)
    EQUAL_TO        reduce using rule 47 (expression -> MINUS expression .)
    NOT_EQUAL       reduce using rule 47 (expression -> MINUS expression .)
    LESS_THAN       reduce using rule 47 (expression -> MINUS expression .)
    GREATER_THAN    reduce using rule 47 (expression -> MINUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 47 (expression -> MINUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 47 (expression -> MINUS expression .)
    CONJUNCTION     reduce using rule 47 (expression -> MINUS expression .)
    DISJUNCTION     reduce using rule 47 (expression -> MINUS expression .)
    AS              reduce using rule 47 (expression -> MINUS expression .)
    RPAREN          reduce using rule 47 (expression -> MINUS expression .)
    COMMA           reduce using rule 47 (expression -> MINUS expression .)
    LBRACE          reduce using rule 47 (expression -> MINUS expression .)
    RBRACKET        reduce using rule 47 (expression -> MINUS expression .)
    RBRACE          reduce using rule 47 (expression -> MINUS expression .)

  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]
  ! AS              [ shift and go to state 51 ]


state 70

    (54) expression -> BIT_AND expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for CONJUNCTION resolved as shift
  ! shift/reduce conflict for DISJUNCTION resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    SEMICOLON       reduce using rule 54 (expression -> BIT_AND expression .)
    RPAREN          reduce using rule 54 (expression -> BIT_AND expression .)
    COMMA           reduce using rule 54 (expression -> BIT_AND expression .)
    LBRACE          reduce using rule 54 (expression -> BIT_AND expression .)
    RBRACKET        reduce using rule 54 (expression -> BIT_AND expression .)
    RBRACE          reduce using rule 54 (expression -> BIT_AND expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! DOT             [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! PLUS            [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! TIMES           [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! MOD             [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! RANGE           [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! EQUAL_TO        [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! LESS_THAN       [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! GREATER_THAN    [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! CONJUNCTION     [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! DISJUNCTION     [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! AS              [ reduce using rule 54 (expression -> BIT_AND expression .) ]


state 71

    (55) expression -> BIT_AND MUT . IDENTIFIER

    IDENTIFIER      shift and go to state 146


state 72

    (100) expression -> LBRACKET element_list . RBRACKET
    (98) element_list -> element_list . COMMA expression

    RBRACKET        shift and go to state 147
    COMMA           shift and go to state 148


state 73

    (101) expression -> LBRACKET expression . SEMICOLON INTEGER RBRACKET
    (99) element_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 149
    RBRACKET        reduce using rule 99 (element_list -> expression .)
    COMMA           reduce using rule 99 (element_list -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 74

    (91) let_decl -> LET maybe_mut . IDENTIFIER maybe_type maybe_init SEMICOLON

    IDENTIFIER      shift and go to state 150


state 75

    (92) maybe_mut -> MUT .

    IDENTIFIER      reduce using rule 92 (maybe_mut -> MUT .)


state 76

    (93) maybe_mut -> empty .

    IDENTIFIER      reduce using rule 93 (maybe_mut -> empty .)


state 77

    (107) const_decl -> CONST IDENTIFIER . COLON type ASIGNED_TO expression SEMICOLON

    COLON           shift and go to state 151


state 78

    (6) statement -> PRINTLN NOT LPAREN . STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN NOT LPAREN . expression RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT LPAREN . STRING COMMA argument_list RPAREN SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    STRING          shift and go to state 152
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 153

state 79

    (30) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RANGE           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    EQUAL_TO        reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    CONJUNCTION     reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DISJUNCTION     reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    AS              reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)


state 80

    (113) tuple_value_list -> expression COMMA . tuple_value_list
    (112) tuple_value_list -> . expression
    (113) tuple_value_list -> . expression COMMA tuple_value_list
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 154
    tuple_value_list               shift and go to state 155

state 81

    (111) expression -> LPAREN tuple_value_list RPAREN .

    SEMICOLON       reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    DOT             reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    PLUS            reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    MINUS           reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    TIMES           reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    DIVIDE          reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    MOD             reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    RANGE           reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    RANGE_INCLUSIVE reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    EQUAL_TO        reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    NOT_EQUAL       reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    LESS_THAN       reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    GREATER_THAN    reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    CONJUNCTION     reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    DISJUNCTION     reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    AS              reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    RPAREN          reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    COMMA           reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    LBRACE          reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    RBRACKET        reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)
    RBRACE          reduce using rule 111 (expression -> LPAREN tuple_value_list RPAREN .)


state 82

    (9) expression -> expression DOT IDENTIFIER . LPAREN expression COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER . LPAREN expression RPAREN
    (13) expression -> expression DOT IDENTIFIER . LPAREN arguments_opt RPAREN

    LPAREN          shift and go to state 156


state 83

    (114) expression -> expression DOT INTEGER .

    SEMICOLON       reduce using rule 114 (expression -> expression DOT INTEGER .)
    DOT             reduce using rule 114 (expression -> expression DOT INTEGER .)
    PLUS            reduce using rule 114 (expression -> expression DOT INTEGER .)
    MINUS           reduce using rule 114 (expression -> expression DOT INTEGER .)
    TIMES           reduce using rule 114 (expression -> expression DOT INTEGER .)
    DIVIDE          reduce using rule 114 (expression -> expression DOT INTEGER .)
    MOD             reduce using rule 114 (expression -> expression DOT INTEGER .)
    RANGE           reduce using rule 114 (expression -> expression DOT INTEGER .)
    RANGE_INCLUSIVE reduce using rule 114 (expression -> expression DOT INTEGER .)
    EQUAL_TO        reduce using rule 114 (expression -> expression DOT INTEGER .)
    NOT_EQUAL       reduce using rule 114 (expression -> expression DOT INTEGER .)
    LESS_THAN       reduce using rule 114 (expression -> expression DOT INTEGER .)
    GREATER_THAN    reduce using rule 114 (expression -> expression DOT INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 114 (expression -> expression DOT INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 114 (expression -> expression DOT INTEGER .)
    CONJUNCTION     reduce using rule 114 (expression -> expression DOT INTEGER .)
    DISJUNCTION     reduce using rule 114 (expression -> expression DOT INTEGER .)
    AS              reduce using rule 114 (expression -> expression DOT INTEGER .)
    RPAREN          reduce using rule 114 (expression -> expression DOT INTEGER .)
    COMMA           reduce using rule 114 (expression -> expression DOT INTEGER .)
    LBRACE          reduce using rule 114 (expression -> expression DOT INTEGER .)
    RBRACKET        reduce using rule 114 (expression -> expression DOT INTEGER .)
    RBRACE          reduce using rule 114 (expression -> expression DOT INTEGER .)


state 84

    (31) expression -> expression PLUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 31 (expression -> expression PLUS expression .)
    DOT             reduce using rule 31 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 31 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 31 (expression -> expression PLUS expression .)
    RANGE           reduce using rule 31 (expression -> expression PLUS expression .)
    RANGE_INCLUSIVE reduce using rule 31 (expression -> expression PLUS expression .)
    EQUAL_TO        reduce using rule 31 (expression -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 31 (expression -> expression PLUS expression .)
    LESS_THAN       reduce using rule 31 (expression -> expression PLUS expression .)
    GREATER_THAN    reduce using rule 31 (expression -> expression PLUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 31 (expression -> expression PLUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 31 (expression -> expression PLUS expression .)
    CONJUNCTION     reduce using rule 31 (expression -> expression PLUS expression .)
    DISJUNCTION     reduce using rule 31 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 31 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 31 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 31 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 31 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 31 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! TIMES           [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! AS              [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 85

    (32) expression -> expression MINUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 32 (expression -> expression MINUS expression .)
    DOT             reduce using rule 32 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 32 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 32 (expression -> expression MINUS expression .)
    RANGE           reduce using rule 32 (expression -> expression MINUS expression .)
    RANGE_INCLUSIVE reduce using rule 32 (expression -> expression MINUS expression .)
    EQUAL_TO        reduce using rule 32 (expression -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 32 (expression -> expression MINUS expression .)
    LESS_THAN       reduce using rule 32 (expression -> expression MINUS expression .)
    GREATER_THAN    reduce using rule 32 (expression -> expression MINUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 32 (expression -> expression MINUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 32 (expression -> expression MINUS expression .)
    CONJUNCTION     reduce using rule 32 (expression -> expression MINUS expression .)
    DISJUNCTION     reduce using rule 32 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 32 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 32 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 32 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 32 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 32 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! TIMES           [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! AS              [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 86

    (33) expression -> expression TIMES expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 33 (expression -> expression TIMES expression .)
    DOT             reduce using rule 33 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 33 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 33 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 33 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 33 (expression -> expression TIMES expression .)
    MOD             reduce using rule 33 (expression -> expression TIMES expression .)
    RANGE           reduce using rule 33 (expression -> expression TIMES expression .)
    RANGE_INCLUSIVE reduce using rule 33 (expression -> expression TIMES expression .)
    EQUAL_TO        reduce using rule 33 (expression -> expression TIMES expression .)
    NOT_EQUAL       reduce using rule 33 (expression -> expression TIMES expression .)
    LESS_THAN       reduce using rule 33 (expression -> expression TIMES expression .)
    GREATER_THAN    reduce using rule 33 (expression -> expression TIMES expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 33 (expression -> expression TIMES expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 33 (expression -> expression TIMES expression .)
    CONJUNCTION     reduce using rule 33 (expression -> expression TIMES expression .)
    DISJUNCTION     reduce using rule 33 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 33 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 33 (expression -> expression TIMES expression .)
    LBRACE          reduce using rule 33 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 33 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 33 (expression -> expression TIMES expression .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 33 (expression -> expression TIMES expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 87

    (34) expression -> expression DIVIDE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 34 (expression -> expression DIVIDE expression .)
    DOT             reduce using rule 34 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 34 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 34 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 34 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    MOD             reduce using rule 34 (expression -> expression DIVIDE expression .)
    RANGE           reduce using rule 34 (expression -> expression DIVIDE expression .)
    RANGE_INCLUSIVE reduce using rule 34 (expression -> expression DIVIDE expression .)
    EQUAL_TO        reduce using rule 34 (expression -> expression DIVIDE expression .)
    NOT_EQUAL       reduce using rule 34 (expression -> expression DIVIDE expression .)
    LESS_THAN       reduce using rule 34 (expression -> expression DIVIDE expression .)
    GREATER_THAN    reduce using rule 34 (expression -> expression DIVIDE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 34 (expression -> expression DIVIDE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 34 (expression -> expression DIVIDE expression .)
    CONJUNCTION     reduce using rule 34 (expression -> expression DIVIDE expression .)
    DISJUNCTION     reduce using rule 34 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 34 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 34 (expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 34 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 34 (expression -> expression DIVIDE expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 88

    (35) expression -> expression MOD expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 35 (expression -> expression MOD expression .)
    DOT             reduce using rule 35 (expression -> expression MOD expression .)
    PLUS            reduce using rule 35 (expression -> expression MOD expression .)
    MINUS           reduce using rule 35 (expression -> expression MOD expression .)
    TIMES           reduce using rule 35 (expression -> expression MOD expression .)
    DIVIDE          reduce using rule 35 (expression -> expression MOD expression .)
    MOD             reduce using rule 35 (expression -> expression MOD expression .)
    RANGE           reduce using rule 35 (expression -> expression MOD expression .)
    RANGE_INCLUSIVE reduce using rule 35 (expression -> expression MOD expression .)
    EQUAL_TO        reduce using rule 35 (expression -> expression MOD expression .)
    NOT_EQUAL       reduce using rule 35 (expression -> expression MOD expression .)
    LESS_THAN       reduce using rule 35 (expression -> expression MOD expression .)
    GREATER_THAN    reduce using rule 35 (expression -> expression MOD expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 35 (expression -> expression MOD expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 35 (expression -> expression MOD expression .)
    CONJUNCTION     reduce using rule 35 (expression -> expression MOD expression .)
    DISJUNCTION     reduce using rule 35 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 35 (expression -> expression MOD expression .)
    COMMA           reduce using rule 35 (expression -> expression MOD expression .)
    LBRACE          reduce using rule 35 (expression -> expression MOD expression .)
    RBRACKET        reduce using rule 35 (expression -> expression MOD expression .)
    RBRACE          reduce using rule 35 (expression -> expression MOD expression .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 35 (expression -> expression MOD expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 89

    (36) expression -> expression RANGE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 36 (expression -> expression RANGE expression .)
    DOT             reduce using rule 36 (expression -> expression RANGE expression .)
    RANGE           reduce using rule 36 (expression -> expression RANGE expression .)
    RANGE_INCLUSIVE reduce using rule 36 (expression -> expression RANGE expression .)
    EQUAL_TO        reduce using rule 36 (expression -> expression RANGE expression .)
    NOT_EQUAL       reduce using rule 36 (expression -> expression RANGE expression .)
    LESS_THAN       reduce using rule 36 (expression -> expression RANGE expression .)
    GREATER_THAN    reduce using rule 36 (expression -> expression RANGE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 36 (expression -> expression RANGE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 36 (expression -> expression RANGE expression .)
    CONJUNCTION     reduce using rule 36 (expression -> expression RANGE expression .)
    DISJUNCTION     reduce using rule 36 (expression -> expression RANGE expression .)
    RPAREN          reduce using rule 36 (expression -> expression RANGE expression .)
    COMMA           reduce using rule 36 (expression -> expression RANGE expression .)
    LBRACE          reduce using rule 36 (expression -> expression RANGE expression .)
    RBRACKET        reduce using rule 36 (expression -> expression RANGE expression .)
    RBRACE          reduce using rule 36 (expression -> expression RANGE expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! MOD             [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! AS              [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 90

    (37) expression -> expression RANGE_INCLUSIVE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    DOT             reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RANGE           reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RANGE_INCLUSIVE reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    EQUAL_TO        reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    NOT_EQUAL       reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    LESS_THAN       reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    GREATER_THAN    reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    CONJUNCTION     reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    DISJUNCTION     reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RPAREN          reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    COMMA           reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    LBRACE          reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACKET        reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACE          reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MINUS           [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! TIMES           [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MOD             [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! AS              [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 91

    (38) expression -> expression EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    DOT             reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LESS_THAN       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RPAREN          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    COMMA           reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LBRACE          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RBRACKET        reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RBRACE          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 92

    (39) expression -> expression NOT_EQUAL expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    DOT             reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    EQUAL_TO        reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    NOT_EQUAL       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LESS_THAN       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    GREATER_THAN    reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    CONJUNCTION     reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    DISJUNCTION     reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    COMMA           reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LBRACE          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RBRACKET        reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RBRACE          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! MOD             [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! RANGE           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! AS              [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 93

    (40) expression -> expression LESS_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    DOT             reduce using rule 40 (expression -> expression LESS_THAN expression .)
    EQUAL_TO        reduce using rule 40 (expression -> expression LESS_THAN expression .)
    NOT_EQUAL       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LESS_THAN       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    GREATER_THAN    reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> expression LESS_THAN expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> expression LESS_THAN expression .)
    CONJUNCTION     reduce using rule 40 (expression -> expression LESS_THAN expression .)
    DISJUNCTION     reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RPAREN          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    COMMA           reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LBRACE          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RBRACKET        reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RBRACE          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! TIMES           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! MOD             [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! RANGE           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! AS              [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 94

    (41) expression -> expression GREATER_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    DOT             reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    EQUAL_TO        reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    NOT_EQUAL       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LESS_THAN       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    GREATER_THAN    reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    CONJUNCTION     reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    DISJUNCTION     reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RPAREN          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    COMMA           reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LBRACE          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RBRACKET        reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RBRACE          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! TIMES           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! MOD             [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! RANGE           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! AS              [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 95

    (42) expression -> expression LESS_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DOT             reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LESS_THAN       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    COMMA           reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LBRACE          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RBRACKET        reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RBRACE          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 96

    (43) expression -> expression GREATER_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DOT             reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LESS_THAN       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    COMMA           reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LBRACE          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RBRACKET        reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RBRACE          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 97

    (44) expression -> expression CONJUNCTION expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    DOT             reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    CONJUNCTION     reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    DISJUNCTION     reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    RPAREN          reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    COMMA           reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    LBRACE          reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    RBRACKET        reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    RBRACE          reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! TIMES           [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! MOD             [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! RANGE           [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! EQUAL_TO        [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! LESS_THAN       [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! GREATER_THAN    [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! AS              [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 98

    (45) expression -> expression DISJUNCTION expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    DOT             reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    DISJUNCTION     reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    RPAREN          reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    COMMA           reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    LBRACE          reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    RBRACKET        reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    RBRACE          reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! MINUS           [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! TIMES           [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! DIVIDE          [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! MOD             [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! RANGE           [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! EQUAL_TO        [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! NOT_EQUAL       [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! LESS_THAN       [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! GREATER_THAN    [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! CONJUNCTION     [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! AS              [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 99

    (56) expression -> expression AS type .

    SEMICOLON       reduce using rule 56 (expression -> expression AS type .)
    DOT             reduce using rule 56 (expression -> expression AS type .)
    PLUS            reduce using rule 56 (expression -> expression AS type .)
    MINUS           reduce using rule 56 (expression -> expression AS type .)
    TIMES           reduce using rule 56 (expression -> expression AS type .)
    DIVIDE          reduce using rule 56 (expression -> expression AS type .)
    MOD             reduce using rule 56 (expression -> expression AS type .)
    RANGE           reduce using rule 56 (expression -> expression AS type .)
    RANGE_INCLUSIVE reduce using rule 56 (expression -> expression AS type .)
    EQUAL_TO        reduce using rule 56 (expression -> expression AS type .)
    NOT_EQUAL       reduce using rule 56 (expression -> expression AS type .)
    LESS_THAN       reduce using rule 56 (expression -> expression AS type .)
    GREATER_THAN    reduce using rule 56 (expression -> expression AS type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 56 (expression -> expression AS type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 56 (expression -> expression AS type .)
    CONJUNCTION     reduce using rule 56 (expression -> expression AS type .)
    DISJUNCTION     reduce using rule 56 (expression -> expression AS type .)
    AS              reduce using rule 56 (expression -> expression AS type .)
    RPAREN          reduce using rule 56 (expression -> expression AS type .)
    COMMA           reduce using rule 56 (expression -> expression AS type .)
    LBRACE          reduce using rule 56 (expression -> expression AS type .)
    RBRACKET        reduce using rule 56 (expression -> expression AS type .)
    RBRACE          reduce using rule 56 (expression -> expression AS type .)


state 100

    (75) type -> TYPE_I32 .

    SEMICOLON       reduce using rule 75 (type -> TYPE_I32 .)
    DOT             reduce using rule 75 (type -> TYPE_I32 .)
    PLUS            reduce using rule 75 (type -> TYPE_I32 .)
    MINUS           reduce using rule 75 (type -> TYPE_I32 .)
    TIMES           reduce using rule 75 (type -> TYPE_I32 .)
    DIVIDE          reduce using rule 75 (type -> TYPE_I32 .)
    MOD             reduce using rule 75 (type -> TYPE_I32 .)
    RANGE           reduce using rule 75 (type -> TYPE_I32 .)
    RANGE_INCLUSIVE reduce using rule 75 (type -> TYPE_I32 .)
    EQUAL_TO        reduce using rule 75 (type -> TYPE_I32 .)
    NOT_EQUAL       reduce using rule 75 (type -> TYPE_I32 .)
    LESS_THAN       reduce using rule 75 (type -> TYPE_I32 .)
    GREATER_THAN    reduce using rule 75 (type -> TYPE_I32 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 75 (type -> TYPE_I32 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 75 (type -> TYPE_I32 .)
    CONJUNCTION     reduce using rule 75 (type -> TYPE_I32 .)
    DISJUNCTION     reduce using rule 75 (type -> TYPE_I32 .)
    AS              reduce using rule 75 (type -> TYPE_I32 .)
    RPAREN          reduce using rule 75 (type -> TYPE_I32 .)
    COMMA           reduce using rule 75 (type -> TYPE_I32 .)
    LBRACE          reduce using rule 75 (type -> TYPE_I32 .)
    RBRACKET        reduce using rule 75 (type -> TYPE_I32 .)
    RBRACE          reduce using rule 75 (type -> TYPE_I32 .)
    CLOSURE_PIPE    reduce using rule 75 (type -> TYPE_I32 .)
    ASIGNED_TO      reduce using rule 75 (type -> TYPE_I32 .)
    IDENTIFIER      reduce using rule 75 (type -> TYPE_I32 .)
    LPAREN          reduce using rule 75 (type -> TYPE_I32 .)
    NOT             reduce using rule 75 (type -> TYPE_I32 .)
    INTEGER         reduce using rule 75 (type -> TYPE_I32 .)
    FLOAT           reduce using rule 75 (type -> TYPE_I32 .)
    STRING          reduce using rule 75 (type -> TYPE_I32 .)
    CHAR            reduce using rule 75 (type -> TYPE_I32 .)
    BOOLEAN         reduce using rule 75 (type -> TYPE_I32 .)
    BIT_AND         reduce using rule 75 (type -> TYPE_I32 .)
    LBRACKET        reduce using rule 75 (type -> TYPE_I32 .)


state 101

    (76) type -> TYPE_U8 .

    SEMICOLON       reduce using rule 76 (type -> TYPE_U8 .)
    DOT             reduce using rule 76 (type -> TYPE_U8 .)
    PLUS            reduce using rule 76 (type -> TYPE_U8 .)
    MINUS           reduce using rule 76 (type -> TYPE_U8 .)
    TIMES           reduce using rule 76 (type -> TYPE_U8 .)
    DIVIDE          reduce using rule 76 (type -> TYPE_U8 .)
    MOD             reduce using rule 76 (type -> TYPE_U8 .)
    RANGE           reduce using rule 76 (type -> TYPE_U8 .)
    RANGE_INCLUSIVE reduce using rule 76 (type -> TYPE_U8 .)
    EQUAL_TO        reduce using rule 76 (type -> TYPE_U8 .)
    NOT_EQUAL       reduce using rule 76 (type -> TYPE_U8 .)
    LESS_THAN       reduce using rule 76 (type -> TYPE_U8 .)
    GREATER_THAN    reduce using rule 76 (type -> TYPE_U8 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 76 (type -> TYPE_U8 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 76 (type -> TYPE_U8 .)
    CONJUNCTION     reduce using rule 76 (type -> TYPE_U8 .)
    DISJUNCTION     reduce using rule 76 (type -> TYPE_U8 .)
    AS              reduce using rule 76 (type -> TYPE_U8 .)
    RPAREN          reduce using rule 76 (type -> TYPE_U8 .)
    COMMA           reduce using rule 76 (type -> TYPE_U8 .)
    LBRACE          reduce using rule 76 (type -> TYPE_U8 .)
    RBRACKET        reduce using rule 76 (type -> TYPE_U8 .)
    RBRACE          reduce using rule 76 (type -> TYPE_U8 .)
    CLOSURE_PIPE    reduce using rule 76 (type -> TYPE_U8 .)
    ASIGNED_TO      reduce using rule 76 (type -> TYPE_U8 .)
    IDENTIFIER      reduce using rule 76 (type -> TYPE_U8 .)
    LPAREN          reduce using rule 76 (type -> TYPE_U8 .)
    NOT             reduce using rule 76 (type -> TYPE_U8 .)
    INTEGER         reduce using rule 76 (type -> TYPE_U8 .)
    FLOAT           reduce using rule 76 (type -> TYPE_U8 .)
    STRING          reduce using rule 76 (type -> TYPE_U8 .)
    CHAR            reduce using rule 76 (type -> TYPE_U8 .)
    BOOLEAN         reduce using rule 76 (type -> TYPE_U8 .)
    BIT_AND         reduce using rule 76 (type -> TYPE_U8 .)
    LBRACKET        reduce using rule 76 (type -> TYPE_U8 .)


state 102

    (77) type -> TYPE_U16 .

    SEMICOLON       reduce using rule 77 (type -> TYPE_U16 .)
    DOT             reduce using rule 77 (type -> TYPE_U16 .)
    PLUS            reduce using rule 77 (type -> TYPE_U16 .)
    MINUS           reduce using rule 77 (type -> TYPE_U16 .)
    TIMES           reduce using rule 77 (type -> TYPE_U16 .)
    DIVIDE          reduce using rule 77 (type -> TYPE_U16 .)
    MOD             reduce using rule 77 (type -> TYPE_U16 .)
    RANGE           reduce using rule 77 (type -> TYPE_U16 .)
    RANGE_INCLUSIVE reduce using rule 77 (type -> TYPE_U16 .)
    EQUAL_TO        reduce using rule 77 (type -> TYPE_U16 .)
    NOT_EQUAL       reduce using rule 77 (type -> TYPE_U16 .)
    LESS_THAN       reduce using rule 77 (type -> TYPE_U16 .)
    GREATER_THAN    reduce using rule 77 (type -> TYPE_U16 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 77 (type -> TYPE_U16 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 77 (type -> TYPE_U16 .)
    CONJUNCTION     reduce using rule 77 (type -> TYPE_U16 .)
    DISJUNCTION     reduce using rule 77 (type -> TYPE_U16 .)
    AS              reduce using rule 77 (type -> TYPE_U16 .)
    RPAREN          reduce using rule 77 (type -> TYPE_U16 .)
    COMMA           reduce using rule 77 (type -> TYPE_U16 .)
    LBRACE          reduce using rule 77 (type -> TYPE_U16 .)
    RBRACKET        reduce using rule 77 (type -> TYPE_U16 .)
    RBRACE          reduce using rule 77 (type -> TYPE_U16 .)
    CLOSURE_PIPE    reduce using rule 77 (type -> TYPE_U16 .)
    ASIGNED_TO      reduce using rule 77 (type -> TYPE_U16 .)
    IDENTIFIER      reduce using rule 77 (type -> TYPE_U16 .)
    LPAREN          reduce using rule 77 (type -> TYPE_U16 .)
    NOT             reduce using rule 77 (type -> TYPE_U16 .)
    INTEGER         reduce using rule 77 (type -> TYPE_U16 .)
    FLOAT           reduce using rule 77 (type -> TYPE_U16 .)
    STRING          reduce using rule 77 (type -> TYPE_U16 .)
    CHAR            reduce using rule 77 (type -> TYPE_U16 .)
    BOOLEAN         reduce using rule 77 (type -> TYPE_U16 .)
    BIT_AND         reduce using rule 77 (type -> TYPE_U16 .)
    LBRACKET        reduce using rule 77 (type -> TYPE_U16 .)


state 103

    (78) type -> TYPE_U32 .

    SEMICOLON       reduce using rule 78 (type -> TYPE_U32 .)
    DOT             reduce using rule 78 (type -> TYPE_U32 .)
    PLUS            reduce using rule 78 (type -> TYPE_U32 .)
    MINUS           reduce using rule 78 (type -> TYPE_U32 .)
    TIMES           reduce using rule 78 (type -> TYPE_U32 .)
    DIVIDE          reduce using rule 78 (type -> TYPE_U32 .)
    MOD             reduce using rule 78 (type -> TYPE_U32 .)
    RANGE           reduce using rule 78 (type -> TYPE_U32 .)
    RANGE_INCLUSIVE reduce using rule 78 (type -> TYPE_U32 .)
    EQUAL_TO        reduce using rule 78 (type -> TYPE_U32 .)
    NOT_EQUAL       reduce using rule 78 (type -> TYPE_U32 .)
    LESS_THAN       reduce using rule 78 (type -> TYPE_U32 .)
    GREATER_THAN    reduce using rule 78 (type -> TYPE_U32 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 78 (type -> TYPE_U32 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 78 (type -> TYPE_U32 .)
    CONJUNCTION     reduce using rule 78 (type -> TYPE_U32 .)
    DISJUNCTION     reduce using rule 78 (type -> TYPE_U32 .)
    AS              reduce using rule 78 (type -> TYPE_U32 .)
    RPAREN          reduce using rule 78 (type -> TYPE_U32 .)
    COMMA           reduce using rule 78 (type -> TYPE_U32 .)
    LBRACE          reduce using rule 78 (type -> TYPE_U32 .)
    RBRACKET        reduce using rule 78 (type -> TYPE_U32 .)
    RBRACE          reduce using rule 78 (type -> TYPE_U32 .)
    CLOSURE_PIPE    reduce using rule 78 (type -> TYPE_U32 .)
    ASIGNED_TO      reduce using rule 78 (type -> TYPE_U32 .)
    IDENTIFIER      reduce using rule 78 (type -> TYPE_U32 .)
    LPAREN          reduce using rule 78 (type -> TYPE_U32 .)
    NOT             reduce using rule 78 (type -> TYPE_U32 .)
    INTEGER         reduce using rule 78 (type -> TYPE_U32 .)
    FLOAT           reduce using rule 78 (type -> TYPE_U32 .)
    STRING          reduce using rule 78 (type -> TYPE_U32 .)
    CHAR            reduce using rule 78 (type -> TYPE_U32 .)
    BOOLEAN         reduce using rule 78 (type -> TYPE_U32 .)
    BIT_AND         reduce using rule 78 (type -> TYPE_U32 .)
    LBRACKET        reduce using rule 78 (type -> TYPE_U32 .)


state 104

    (79) type -> TYPE_U64 .

    SEMICOLON       reduce using rule 79 (type -> TYPE_U64 .)
    DOT             reduce using rule 79 (type -> TYPE_U64 .)
    PLUS            reduce using rule 79 (type -> TYPE_U64 .)
    MINUS           reduce using rule 79 (type -> TYPE_U64 .)
    TIMES           reduce using rule 79 (type -> TYPE_U64 .)
    DIVIDE          reduce using rule 79 (type -> TYPE_U64 .)
    MOD             reduce using rule 79 (type -> TYPE_U64 .)
    RANGE           reduce using rule 79 (type -> TYPE_U64 .)
    RANGE_INCLUSIVE reduce using rule 79 (type -> TYPE_U64 .)
    EQUAL_TO        reduce using rule 79 (type -> TYPE_U64 .)
    NOT_EQUAL       reduce using rule 79 (type -> TYPE_U64 .)
    LESS_THAN       reduce using rule 79 (type -> TYPE_U64 .)
    GREATER_THAN    reduce using rule 79 (type -> TYPE_U64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 79 (type -> TYPE_U64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 79 (type -> TYPE_U64 .)
    CONJUNCTION     reduce using rule 79 (type -> TYPE_U64 .)
    DISJUNCTION     reduce using rule 79 (type -> TYPE_U64 .)
    AS              reduce using rule 79 (type -> TYPE_U64 .)
    RPAREN          reduce using rule 79 (type -> TYPE_U64 .)
    COMMA           reduce using rule 79 (type -> TYPE_U64 .)
    LBRACE          reduce using rule 79 (type -> TYPE_U64 .)
    RBRACKET        reduce using rule 79 (type -> TYPE_U64 .)
    RBRACE          reduce using rule 79 (type -> TYPE_U64 .)
    CLOSURE_PIPE    reduce using rule 79 (type -> TYPE_U64 .)
    ASIGNED_TO      reduce using rule 79 (type -> TYPE_U64 .)
    IDENTIFIER      reduce using rule 79 (type -> TYPE_U64 .)
    LPAREN          reduce using rule 79 (type -> TYPE_U64 .)
    NOT             reduce using rule 79 (type -> TYPE_U64 .)
    INTEGER         reduce using rule 79 (type -> TYPE_U64 .)
    FLOAT           reduce using rule 79 (type -> TYPE_U64 .)
    STRING          reduce using rule 79 (type -> TYPE_U64 .)
    CHAR            reduce using rule 79 (type -> TYPE_U64 .)
    BOOLEAN         reduce using rule 79 (type -> TYPE_U64 .)
    BIT_AND         reduce using rule 79 (type -> TYPE_U64 .)
    LBRACKET        reduce using rule 79 (type -> TYPE_U64 .)


state 105

    (80) type -> TYPE_F64 .

    SEMICOLON       reduce using rule 80 (type -> TYPE_F64 .)
    DOT             reduce using rule 80 (type -> TYPE_F64 .)
    PLUS            reduce using rule 80 (type -> TYPE_F64 .)
    MINUS           reduce using rule 80 (type -> TYPE_F64 .)
    TIMES           reduce using rule 80 (type -> TYPE_F64 .)
    DIVIDE          reduce using rule 80 (type -> TYPE_F64 .)
    MOD             reduce using rule 80 (type -> TYPE_F64 .)
    RANGE           reduce using rule 80 (type -> TYPE_F64 .)
    RANGE_INCLUSIVE reduce using rule 80 (type -> TYPE_F64 .)
    EQUAL_TO        reduce using rule 80 (type -> TYPE_F64 .)
    NOT_EQUAL       reduce using rule 80 (type -> TYPE_F64 .)
    LESS_THAN       reduce using rule 80 (type -> TYPE_F64 .)
    GREATER_THAN    reduce using rule 80 (type -> TYPE_F64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 80 (type -> TYPE_F64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 80 (type -> TYPE_F64 .)
    CONJUNCTION     reduce using rule 80 (type -> TYPE_F64 .)
    DISJUNCTION     reduce using rule 80 (type -> TYPE_F64 .)
    AS              reduce using rule 80 (type -> TYPE_F64 .)
    RPAREN          reduce using rule 80 (type -> TYPE_F64 .)
    COMMA           reduce using rule 80 (type -> TYPE_F64 .)
    LBRACE          reduce using rule 80 (type -> TYPE_F64 .)
    RBRACKET        reduce using rule 80 (type -> TYPE_F64 .)
    RBRACE          reduce using rule 80 (type -> TYPE_F64 .)
    CLOSURE_PIPE    reduce using rule 80 (type -> TYPE_F64 .)
    ASIGNED_TO      reduce using rule 80 (type -> TYPE_F64 .)
    IDENTIFIER      reduce using rule 80 (type -> TYPE_F64 .)
    LPAREN          reduce using rule 80 (type -> TYPE_F64 .)
    NOT             reduce using rule 80 (type -> TYPE_F64 .)
    INTEGER         reduce using rule 80 (type -> TYPE_F64 .)
    FLOAT           reduce using rule 80 (type -> TYPE_F64 .)
    STRING          reduce using rule 80 (type -> TYPE_F64 .)
    CHAR            reduce using rule 80 (type -> TYPE_F64 .)
    BOOLEAN         reduce using rule 80 (type -> TYPE_F64 .)
    BIT_AND         reduce using rule 80 (type -> TYPE_F64 .)
    LBRACKET        reduce using rule 80 (type -> TYPE_F64 .)


state 106

    (81) type -> TYPE_CHAR .

    SEMICOLON       reduce using rule 81 (type -> TYPE_CHAR .)
    DOT             reduce using rule 81 (type -> TYPE_CHAR .)
    PLUS            reduce using rule 81 (type -> TYPE_CHAR .)
    MINUS           reduce using rule 81 (type -> TYPE_CHAR .)
    TIMES           reduce using rule 81 (type -> TYPE_CHAR .)
    DIVIDE          reduce using rule 81 (type -> TYPE_CHAR .)
    MOD             reduce using rule 81 (type -> TYPE_CHAR .)
    RANGE           reduce using rule 81 (type -> TYPE_CHAR .)
    RANGE_INCLUSIVE reduce using rule 81 (type -> TYPE_CHAR .)
    EQUAL_TO        reduce using rule 81 (type -> TYPE_CHAR .)
    NOT_EQUAL       reduce using rule 81 (type -> TYPE_CHAR .)
    LESS_THAN       reduce using rule 81 (type -> TYPE_CHAR .)
    GREATER_THAN    reduce using rule 81 (type -> TYPE_CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 81 (type -> TYPE_CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 81 (type -> TYPE_CHAR .)
    CONJUNCTION     reduce using rule 81 (type -> TYPE_CHAR .)
    DISJUNCTION     reduce using rule 81 (type -> TYPE_CHAR .)
    AS              reduce using rule 81 (type -> TYPE_CHAR .)
    RPAREN          reduce using rule 81 (type -> TYPE_CHAR .)
    COMMA           reduce using rule 81 (type -> TYPE_CHAR .)
    LBRACE          reduce using rule 81 (type -> TYPE_CHAR .)
    RBRACKET        reduce using rule 81 (type -> TYPE_CHAR .)
    RBRACE          reduce using rule 81 (type -> TYPE_CHAR .)
    CLOSURE_PIPE    reduce using rule 81 (type -> TYPE_CHAR .)
    ASIGNED_TO      reduce using rule 81 (type -> TYPE_CHAR .)
    IDENTIFIER      reduce using rule 81 (type -> TYPE_CHAR .)
    LPAREN          reduce using rule 81 (type -> TYPE_CHAR .)
    NOT             reduce using rule 81 (type -> TYPE_CHAR .)
    INTEGER         reduce using rule 81 (type -> TYPE_CHAR .)
    FLOAT           reduce using rule 81 (type -> TYPE_CHAR .)
    STRING          reduce using rule 81 (type -> TYPE_CHAR .)
    CHAR            reduce using rule 81 (type -> TYPE_CHAR .)
    BOOLEAN         reduce using rule 81 (type -> TYPE_CHAR .)
    BIT_AND         reduce using rule 81 (type -> TYPE_CHAR .)
    LBRACKET        reduce using rule 81 (type -> TYPE_CHAR .)


state 107

    (82) type -> TYPE_STRING .

    SEMICOLON       reduce using rule 82 (type -> TYPE_STRING .)
    DOT             reduce using rule 82 (type -> TYPE_STRING .)
    PLUS            reduce using rule 82 (type -> TYPE_STRING .)
    MINUS           reduce using rule 82 (type -> TYPE_STRING .)
    TIMES           reduce using rule 82 (type -> TYPE_STRING .)
    DIVIDE          reduce using rule 82 (type -> TYPE_STRING .)
    MOD             reduce using rule 82 (type -> TYPE_STRING .)
    RANGE           reduce using rule 82 (type -> TYPE_STRING .)
    RANGE_INCLUSIVE reduce using rule 82 (type -> TYPE_STRING .)
    EQUAL_TO        reduce using rule 82 (type -> TYPE_STRING .)
    NOT_EQUAL       reduce using rule 82 (type -> TYPE_STRING .)
    LESS_THAN       reduce using rule 82 (type -> TYPE_STRING .)
    GREATER_THAN    reduce using rule 82 (type -> TYPE_STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 82 (type -> TYPE_STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 82 (type -> TYPE_STRING .)
    CONJUNCTION     reduce using rule 82 (type -> TYPE_STRING .)
    DISJUNCTION     reduce using rule 82 (type -> TYPE_STRING .)
    AS              reduce using rule 82 (type -> TYPE_STRING .)
    RPAREN          reduce using rule 82 (type -> TYPE_STRING .)
    COMMA           reduce using rule 82 (type -> TYPE_STRING .)
    LBRACE          reduce using rule 82 (type -> TYPE_STRING .)
    RBRACKET        reduce using rule 82 (type -> TYPE_STRING .)
    RBRACE          reduce using rule 82 (type -> TYPE_STRING .)
    CLOSURE_PIPE    reduce using rule 82 (type -> TYPE_STRING .)
    ASIGNED_TO      reduce using rule 82 (type -> TYPE_STRING .)
    IDENTIFIER      reduce using rule 82 (type -> TYPE_STRING .)
    LPAREN          reduce using rule 82 (type -> TYPE_STRING .)
    NOT             reduce using rule 82 (type -> TYPE_STRING .)
    INTEGER         reduce using rule 82 (type -> TYPE_STRING .)
    FLOAT           reduce using rule 82 (type -> TYPE_STRING .)
    STRING          reduce using rule 82 (type -> TYPE_STRING .)
    CHAR            reduce using rule 82 (type -> TYPE_STRING .)
    BOOLEAN         reduce using rule 82 (type -> TYPE_STRING .)
    BIT_AND         reduce using rule 82 (type -> TYPE_STRING .)
    LBRACKET        reduce using rule 82 (type -> TYPE_STRING .)


state 108

    (83) type -> TYPE_STR .

    SEMICOLON       reduce using rule 83 (type -> TYPE_STR .)
    DOT             reduce using rule 83 (type -> TYPE_STR .)
    PLUS            reduce using rule 83 (type -> TYPE_STR .)
    MINUS           reduce using rule 83 (type -> TYPE_STR .)
    TIMES           reduce using rule 83 (type -> TYPE_STR .)
    DIVIDE          reduce using rule 83 (type -> TYPE_STR .)
    MOD             reduce using rule 83 (type -> TYPE_STR .)
    RANGE           reduce using rule 83 (type -> TYPE_STR .)
    RANGE_INCLUSIVE reduce using rule 83 (type -> TYPE_STR .)
    EQUAL_TO        reduce using rule 83 (type -> TYPE_STR .)
    NOT_EQUAL       reduce using rule 83 (type -> TYPE_STR .)
    LESS_THAN       reduce using rule 83 (type -> TYPE_STR .)
    GREATER_THAN    reduce using rule 83 (type -> TYPE_STR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 83 (type -> TYPE_STR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 83 (type -> TYPE_STR .)
    CONJUNCTION     reduce using rule 83 (type -> TYPE_STR .)
    DISJUNCTION     reduce using rule 83 (type -> TYPE_STR .)
    AS              reduce using rule 83 (type -> TYPE_STR .)
    RPAREN          reduce using rule 83 (type -> TYPE_STR .)
    COMMA           reduce using rule 83 (type -> TYPE_STR .)
    LBRACE          reduce using rule 83 (type -> TYPE_STR .)
    RBRACKET        reduce using rule 83 (type -> TYPE_STR .)
    RBRACE          reduce using rule 83 (type -> TYPE_STR .)
    CLOSURE_PIPE    reduce using rule 83 (type -> TYPE_STR .)
    ASIGNED_TO      reduce using rule 83 (type -> TYPE_STR .)
    IDENTIFIER      reduce using rule 83 (type -> TYPE_STR .)
    LPAREN          reduce using rule 83 (type -> TYPE_STR .)
    NOT             reduce using rule 83 (type -> TYPE_STR .)
    INTEGER         reduce using rule 83 (type -> TYPE_STR .)
    FLOAT           reduce using rule 83 (type -> TYPE_STR .)
    STRING          reduce using rule 83 (type -> TYPE_STR .)
    CHAR            reduce using rule 83 (type -> TYPE_STR .)
    BOOLEAN         reduce using rule 83 (type -> TYPE_STR .)
    BIT_AND         reduce using rule 83 (type -> TYPE_STR .)
    LBRACKET        reduce using rule 83 (type -> TYPE_STR .)


state 109

    (84) type -> TYPE_BOOL .

    SEMICOLON       reduce using rule 84 (type -> TYPE_BOOL .)
    DOT             reduce using rule 84 (type -> TYPE_BOOL .)
    PLUS            reduce using rule 84 (type -> TYPE_BOOL .)
    MINUS           reduce using rule 84 (type -> TYPE_BOOL .)
    TIMES           reduce using rule 84 (type -> TYPE_BOOL .)
    DIVIDE          reduce using rule 84 (type -> TYPE_BOOL .)
    MOD             reduce using rule 84 (type -> TYPE_BOOL .)
    RANGE           reduce using rule 84 (type -> TYPE_BOOL .)
    RANGE_INCLUSIVE reduce using rule 84 (type -> TYPE_BOOL .)
    EQUAL_TO        reduce using rule 84 (type -> TYPE_BOOL .)
    NOT_EQUAL       reduce using rule 84 (type -> TYPE_BOOL .)
    LESS_THAN       reduce using rule 84 (type -> TYPE_BOOL .)
    GREATER_THAN    reduce using rule 84 (type -> TYPE_BOOL .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 84 (type -> TYPE_BOOL .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 84 (type -> TYPE_BOOL .)
    CONJUNCTION     reduce using rule 84 (type -> TYPE_BOOL .)
    DISJUNCTION     reduce using rule 84 (type -> TYPE_BOOL .)
    AS              reduce using rule 84 (type -> TYPE_BOOL .)
    RPAREN          reduce using rule 84 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 84 (type -> TYPE_BOOL .)
    LBRACE          reduce using rule 84 (type -> TYPE_BOOL .)
    RBRACKET        reduce using rule 84 (type -> TYPE_BOOL .)
    RBRACE          reduce using rule 84 (type -> TYPE_BOOL .)
    CLOSURE_PIPE    reduce using rule 84 (type -> TYPE_BOOL .)
    ASIGNED_TO      reduce using rule 84 (type -> TYPE_BOOL .)
    IDENTIFIER      reduce using rule 84 (type -> TYPE_BOOL .)
    LPAREN          reduce using rule 84 (type -> TYPE_BOOL .)
    NOT             reduce using rule 84 (type -> TYPE_BOOL .)
    INTEGER         reduce using rule 84 (type -> TYPE_BOOL .)
    FLOAT           reduce using rule 84 (type -> TYPE_BOOL .)
    STRING          reduce using rule 84 (type -> TYPE_BOOL .)
    CHAR            reduce using rule 84 (type -> TYPE_BOOL .)
    BOOLEAN         reduce using rule 84 (type -> TYPE_BOOL .)
    BIT_AND         reduce using rule 84 (type -> TYPE_BOOL .)
    LBRACKET        reduce using rule 84 (type -> TYPE_BOOL .)


state 110

    (85) type -> TYPE_TUPLE .

    SEMICOLON       reduce using rule 85 (type -> TYPE_TUPLE .)
    DOT             reduce using rule 85 (type -> TYPE_TUPLE .)
    PLUS            reduce using rule 85 (type -> TYPE_TUPLE .)
    MINUS           reduce using rule 85 (type -> TYPE_TUPLE .)
    TIMES           reduce using rule 85 (type -> TYPE_TUPLE .)
    DIVIDE          reduce using rule 85 (type -> TYPE_TUPLE .)
    MOD             reduce using rule 85 (type -> TYPE_TUPLE .)
    RANGE           reduce using rule 85 (type -> TYPE_TUPLE .)
    RANGE_INCLUSIVE reduce using rule 85 (type -> TYPE_TUPLE .)
    EQUAL_TO        reduce using rule 85 (type -> TYPE_TUPLE .)
    NOT_EQUAL       reduce using rule 85 (type -> TYPE_TUPLE .)
    LESS_THAN       reduce using rule 85 (type -> TYPE_TUPLE .)
    GREATER_THAN    reduce using rule 85 (type -> TYPE_TUPLE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 85 (type -> TYPE_TUPLE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 85 (type -> TYPE_TUPLE .)
    CONJUNCTION     reduce using rule 85 (type -> TYPE_TUPLE .)
    DISJUNCTION     reduce using rule 85 (type -> TYPE_TUPLE .)
    AS              reduce using rule 85 (type -> TYPE_TUPLE .)
    RPAREN          reduce using rule 85 (type -> TYPE_TUPLE .)
    COMMA           reduce using rule 85 (type -> TYPE_TUPLE .)
    LBRACE          reduce using rule 85 (type -> TYPE_TUPLE .)
    RBRACKET        reduce using rule 85 (type -> TYPE_TUPLE .)
    RBRACE          reduce using rule 85 (type -> TYPE_TUPLE .)
    CLOSURE_PIPE    reduce using rule 85 (type -> TYPE_TUPLE .)
    ASIGNED_TO      reduce using rule 85 (type -> TYPE_TUPLE .)
    IDENTIFIER      reduce using rule 85 (type -> TYPE_TUPLE .)
    LPAREN          reduce using rule 85 (type -> TYPE_TUPLE .)
    NOT             reduce using rule 85 (type -> TYPE_TUPLE .)
    INTEGER         reduce using rule 85 (type -> TYPE_TUPLE .)
    FLOAT           reduce using rule 85 (type -> TYPE_TUPLE .)
    STRING          reduce using rule 85 (type -> TYPE_TUPLE .)
    CHAR            reduce using rule 85 (type -> TYPE_TUPLE .)
    BOOLEAN         reduce using rule 85 (type -> TYPE_TUPLE .)
    BIT_AND         reduce using rule 85 (type -> TYPE_TUPLE .)
    LBRACKET        reduce using rule 85 (type -> TYPE_TUPLE .)


state 111

    (86) type -> LBRACKET . type RBRACKET
    (87) type -> LBRACKET . type COMMA INTEGER RBRACKET
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 157

state 112

    (88) type -> BIT_AND . type
    (89) type -> BIT_AND . MUT type
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    MUT             shift and go to state 159
    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 158

state 113

    (108) type -> LPAREN . tuple_type_list RPAREN
    (109) tuple_type_list -> . type
    (110) tuple_type_list -> . type COMMA tuple_type_list
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    tuple_type_list                shift and go to state 160
    type                           shift and go to state 161

state 114

    (69) statement -> IF condition LBRACE . program_opt RBRACE
    (70) statement -> IF condition LBRACE . program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    program_opt                    shift and go to state 162
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 115

    (63) condition -> condition CONJUNCTION . condition
    (57) condition -> . expression EQUAL_TO expression
    (58) condition -> . expression NOT_EQUAL expression
    (59) condition -> . expression LESS_THAN expression
    (60) condition -> . expression GREATER_THAN expression
    (61) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (63) condition -> . condition CONJUNCTION condition
    (64) condition -> . condition DISJUNCTION condition
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN condition RPAREN
    (67) condition -> . expression
    (68) condition -> . BOOLEAN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 54
    LPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 56
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    condition                      shift and go to state 165
    expression                     shift and go to state 53

state 116

    (64) condition -> condition DISJUNCTION . condition
    (57) condition -> . expression EQUAL_TO expression
    (58) condition -> . expression NOT_EQUAL expression
    (59) condition -> . expression LESS_THAN expression
    (60) condition -> . expression GREATER_THAN expression
    (61) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (63) condition -> . condition CONJUNCTION condition
    (64) condition -> . condition DISJUNCTION condition
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN condition RPAREN
    (67) condition -> . expression
    (68) condition -> . BOOLEAN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 54
    LPAREN          shift and go to state 55
    BOOLEAN         shift and go to state 56
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    condition                      shift and go to state 166
    expression                     shift and go to state 53

state 117

    (57) condition -> expression EQUAL_TO . expression
    (38) expression -> expression EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 167

state 118

    (58) condition -> expression NOT_EQUAL . expression
    (39) expression -> expression NOT_EQUAL . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 168

state 119

    (59) condition -> expression LESS_THAN . expression
    (40) expression -> expression LESS_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 169

state 120

    (60) condition -> expression GREATER_THAN . expression
    (41) expression -> expression GREATER_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 170

state 121

    (61) condition -> expression LESS_THAN_OR_EQUAL_TO . expression
    (42) expression -> expression LESS_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 171

state 122

    (62) condition -> expression GREATER_THAN_OR_EQUAL_TO . expression
    (43) expression -> expression GREATER_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 172

state 123

    (65) condition -> NOT condition .
    (63) condition -> condition . CONJUNCTION condition
    (64) condition -> condition . DISJUNCTION condition

    LBRACE          reduce using rule 65 (condition -> NOT condition .)
    CONJUNCTION     reduce using rule 65 (condition -> NOT condition .)
    DISJUNCTION     reduce using rule 65 (condition -> NOT condition .)
    RPAREN          reduce using rule 65 (condition -> NOT condition .)

  ! CONJUNCTION     [ shift and go to state 115 ]
  ! DISJUNCTION     [ shift and go to state 116 ]


state 124

    (46) expression -> NOT expression .
    (57) condition -> expression . EQUAL_TO expression
    (58) condition -> expression . NOT_EQUAL expression
    (59) condition -> expression . LESS_THAN expression
    (60) condition -> expression . GREATER_THAN expression
    (61) condition -> expression . LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (67) condition -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 46 (expression -> NOT expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 46 (expression -> NOT expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 46 (expression -> NOT expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 46 (expression -> NOT expression .)
    DOT             reduce using rule 46 (expression -> NOT expression .)
    CONJUNCTION     reduce using rule 46 (expression -> NOT expression .)
    DISJUNCTION     reduce using rule 46 (expression -> NOT expression .)
    LBRACE          reduce using rule 46 (expression -> NOT expression .)
    RPAREN          reduce using rule 46 (expression -> NOT expression .)
    COMMA           reduce using rule 46 (expression -> NOT expression .)
    EQUAL_TO        shift and go to state 117
    NOT_EQUAL       shift and go to state 118
    LESS_THAN       shift and go to state 119
    GREATER_THAN    shift and go to state 120
    LESS_THAN_OR_EQUAL_TO shift and go to state 121
    GREATER_THAN_OR_EQUAL_TO shift and go to state 122
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! EQUAL_TO        [ reduce using rule 46 (expression -> NOT expression .) ]
  ! NOT_EQUAL       [ reduce using rule 46 (expression -> NOT expression .) ]
  ! LESS_THAN       [ reduce using rule 46 (expression -> NOT expression .) ]
  ! GREATER_THAN    [ reduce using rule 46 (expression -> NOT expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 46 (expression -> NOT expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 46 (expression -> NOT expression .) ]
  ! PLUS            [ reduce using rule 46 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 46 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 46 (expression -> NOT expression .) ]
  ! RANGE           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 46 (expression -> NOT expression .) ]
  ! AS              [ reduce using rule 46 (expression -> NOT expression .) ]
  ! CONJUNCTION     [ reduce using rule 67 (condition -> expression .) ]
  ! DISJUNCTION     [ reduce using rule 67 (condition -> expression .) ]
  ! LBRACE          [ reduce using rule 67 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 67 (condition -> expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 125

    (66) condition -> LPAREN condition . RPAREN
    (63) condition -> condition . CONJUNCTION condition
    (64) condition -> condition . DISJUNCTION condition

    RPAREN          shift and go to state 173
    CONJUNCTION     shift and go to state 115
    DISJUNCTION     shift and go to state 116


state 126

    (30) expression -> LPAREN expression . RPAREN
    (57) condition -> expression . EQUAL_TO expression
    (58) condition -> expression . NOT_EQUAL expression
    (59) condition -> expression . LESS_THAN expression
    (60) condition -> expression . GREATER_THAN expression
    (61) condition -> expression . LESS_THAN_OR_EQUAL_TO expression
    (62) condition -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (67) condition -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER
    (112) tuple_value_list -> expression .
    (113) tuple_value_list -> expression . COMMA tuple_value_list

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for CONJUNCTION resolved as shift
  ! shift/reduce conflict for DISJUNCTION resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 79
    EQUAL_TO        shift and go to state 117
    NOT_EQUAL       shift and go to state 118
    LESS_THAN       shift and go to state 119
    GREATER_THAN    shift and go to state 120
    LESS_THAN_OR_EQUAL_TO shift and go to state 121
    GREATER_THAN_OR_EQUAL_TO shift and go to state 122
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    COMMA           shift and go to state 80

  ! RPAREN          [ reduce using rule 67 (condition -> expression .) ]
  ! CONJUNCTION     [ reduce using rule 67 (condition -> expression .) ]
  ! DISJUNCTION     [ reduce using rule 67 (condition -> expression .) ]
  ! RPAREN          [ reduce using rule 112 (tuple_value_list -> expression .) ]


state 127

    (71) statement -> IDENTIFIER ASIGNED_TO expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 174
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 128

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 175


state 129

    (123) expression -> IDENTIFIER LPAREN arguments_opt . RPAREN

    RPAREN          shift and go to state 176


state 130

    (14) arguments_opt -> argument_list .
    (16) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 14 (arguments_opt -> argument_list .)
    COMMA           shift and go to state 177


state 131

    (15) arguments_opt -> empty .

    RPAREN          reduce using rule 15 (arguments_opt -> empty .)


state 132

    (17) argument_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    COMMA           reduce using rule 17 (argument_list -> expression .)
    RPAREN          reduce using rule 17 (argument_list -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 133

    (102) expression -> IDENTIFIER LBRACKET expression . RBRACKET
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    RBRACKET        shift and go to state 178
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 134

    (103) expression -> IDENTIFIER LBRACKET INTEGER . RANGE INTEGER RBRACKET
    (104) expression -> IDENTIFIER LBRACKET INTEGER . RANGE_INCLUSIVE INTEGER RBRACKET
    (48) expression -> INTEGER .

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
    RANGE           shift and go to state 179
    RANGE_INCLUSIVE shift and go to state 180
    RBRACKET        reduce using rule 48 (expression -> INTEGER .)
    DOT             reduce using rule 48 (expression -> INTEGER .)
    PLUS            reduce using rule 48 (expression -> INTEGER .)
    MINUS           reduce using rule 48 (expression -> INTEGER .)
    TIMES           reduce using rule 48 (expression -> INTEGER .)
    DIVIDE          reduce using rule 48 (expression -> INTEGER .)
    MOD             reduce using rule 48 (expression -> INTEGER .)
    EQUAL_TO        reduce using rule 48 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN       reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN    reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    CONJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    DISJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    AS              reduce using rule 48 (expression -> INTEGER .)

  ! RANGE           [ reduce using rule 48 (expression -> INTEGER .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 48 (expression -> INTEGER .) ]


state 135

    (105) expression -> IDENTIFIER NOT LBRACKET . element_list RBRACKET
    (98) element_list -> . element_list COMMA expression
    (99) element_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    element_list                   shift and go to state 181
    expression                     shift and go to state 182

state 136

    (72) statement -> WHILE condition LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    program_opt                    shift and go to state 183
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 137

    (73) statement -> ASYNC FN function_name . LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> ASYNC FN function_name . LPAREN RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 184


state 138

    (118) function_name -> IDENTIFIER .

    LPAREN          reduce using rule 118 (function_name -> IDENTIFIER .)


state 139

    (119) function_name -> MAIN .

    LPAREN          reduce using rule 119 (function_name -> MAIN .)


state 140

    (115) statement -> FOR IDENTIFIER IN . expression LBRACE program_opt RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 185

state 141

    (120) statement -> maybe_pub FN function_name . LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> maybe_pub FN function_name . LPAREN RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 186


state 142

    (122) statement -> RETURN expression SEMICOLON .

    PRINTLN         reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    ASYNC           reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    BOOLEAN         reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    BIT_AND         reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    LET             reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    CONST           reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    FN              reduce using rule 122 (statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 122 (statement -> RETURN expression SEMICOLON .)


state 143

    (28) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE . closure_body
    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE . ARROW type closure_body
    (23) closure_body -> . expression
    (24) closure_body -> . LBRACE closure_block_content RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    ARROW           shift and go to state 188
    LBRACE          shift and go to state 190
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    closure_body                   shift and go to state 187
    expression                     shift and go to state 189

state 144

    (20) closure_params -> IDENTIFIER COLON . type
    (22) closure_params -> IDENTIFIER COLON . type COMMA closure_params
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 191

state 145

    (21) closure_params -> IDENTIFIER COMMA . closure_params
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 68

    closure_params                 shift and go to state 192

state 146

    (55) expression -> BIT_AND MUT IDENTIFIER .

    SEMICOLON       reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    DOT             reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    PLUS            reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    MINUS           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    TIMES           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    DIVIDE          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    MOD             reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RANGE           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    EQUAL_TO        reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    NOT_EQUAL       reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN       reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN    reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    CONJUNCTION     reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    DISJUNCTION     reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    AS              reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RPAREN          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    COMMA           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    LBRACE          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RBRACKET        reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RBRACE          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)


state 147

    (100) expression -> LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    DOT             reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    PLUS            reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    MINUS           reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    TIMES           reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    DIVIDE          reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    MOD             reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    RANGE           reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    EQUAL_TO        reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    NOT_EQUAL       reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    LESS_THAN       reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    GREATER_THAN    reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    CONJUNCTION     reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    DISJUNCTION     reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    AS              reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    LBRACE          reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 100 (expression -> LBRACKET element_list RBRACKET .)


state 148

    (98) element_list -> element_list COMMA . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 193

state 149

    (101) expression -> LBRACKET expression SEMICOLON . INTEGER RBRACKET

    INTEGER         shift and go to state 194


state 150

    (91) let_decl -> LET maybe_mut IDENTIFIER . maybe_type maybe_init SEMICOLON
    (94) maybe_type -> . COLON type
    (95) maybe_type -> . empty
    (5) empty -> .

    COLON           shift and go to state 196
    ASIGNED_TO      reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_type                     shift and go to state 195
    empty                          shift and go to state 197

state 151

    (107) const_decl -> CONST IDENTIFIER COLON . type ASIGNED_TO expression SEMICOLON
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 198

state 152

    (6) statement -> PRINTLN NOT LPAREN STRING . RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT LPAREN STRING . COMMA argument_list RPAREN SEMICOLON
    (50) expression -> STRING .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 199
    COMMA           shift and go to state 200
    DOT             reduce using rule 50 (expression -> STRING .)
    PLUS            reduce using rule 50 (expression -> STRING .)
    MINUS           reduce using rule 50 (expression -> STRING .)
    TIMES           reduce using rule 50 (expression -> STRING .)
    DIVIDE          reduce using rule 50 (expression -> STRING .)
    MOD             reduce using rule 50 (expression -> STRING .)
    RANGE           reduce using rule 50 (expression -> STRING .)
    RANGE_INCLUSIVE reduce using rule 50 (expression -> STRING .)
    EQUAL_TO        reduce using rule 50 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 50 (expression -> STRING .)
    LESS_THAN       reduce using rule 50 (expression -> STRING .)
    GREATER_THAN    reduce using rule 50 (expression -> STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    CONJUNCTION     reduce using rule 50 (expression -> STRING .)
    DISJUNCTION     reduce using rule 50 (expression -> STRING .)
    AS              reduce using rule 50 (expression -> STRING .)

  ! RPAREN          [ reduce using rule 50 (expression -> STRING .) ]


state 153

    (7) statement -> PRINTLN NOT LPAREN expression . RPAREN SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    RPAREN          shift and go to state 201
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 154

    (112) tuple_value_list -> expression .
    (113) tuple_value_list -> expression . COMMA tuple_value_list
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    RPAREN          reduce using rule 112 (tuple_value_list -> expression .)
    COMMA           shift and go to state 80
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 155

    (113) tuple_value_list -> expression COMMA tuple_value_list .

    RPAREN          reduce using rule 113 (tuple_value_list -> expression COMMA tuple_value_list .)


state 156

    (9) expression -> expression DOT IDENTIFIER LPAREN . expression COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER LPAREN . expression RPAREN
    (13) expression -> expression DOT IDENTIFIER LPAREN . arguments_opt RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (14) arguments_opt -> . argument_list
    (15) arguments_opt -> . empty
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (5) empty -> .

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    RPAREN          reduce using rule 5 (empty -> .)

    expression                     shift and go to state 202
    arguments_opt                  shift and go to state 203
    argument_list                  shift and go to state 130
    empty                          shift and go to state 131

state 157

    (86) type -> LBRACKET type . RBRACKET
    (87) type -> LBRACKET type . COMMA INTEGER RBRACKET

    RBRACKET        shift and go to state 204
    COMMA           shift and go to state 205


state 158

    (88) type -> BIT_AND type .

    SEMICOLON       reduce using rule 88 (type -> BIT_AND type .)
    DOT             reduce using rule 88 (type -> BIT_AND type .)
    PLUS            reduce using rule 88 (type -> BIT_AND type .)
    MINUS           reduce using rule 88 (type -> BIT_AND type .)
    TIMES           reduce using rule 88 (type -> BIT_AND type .)
    DIVIDE          reduce using rule 88 (type -> BIT_AND type .)
    MOD             reduce using rule 88 (type -> BIT_AND type .)
    RANGE           reduce using rule 88 (type -> BIT_AND type .)
    RANGE_INCLUSIVE reduce using rule 88 (type -> BIT_AND type .)
    EQUAL_TO        reduce using rule 88 (type -> BIT_AND type .)
    NOT_EQUAL       reduce using rule 88 (type -> BIT_AND type .)
    LESS_THAN       reduce using rule 88 (type -> BIT_AND type .)
    GREATER_THAN    reduce using rule 88 (type -> BIT_AND type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 88 (type -> BIT_AND type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 88 (type -> BIT_AND type .)
    CONJUNCTION     reduce using rule 88 (type -> BIT_AND type .)
    DISJUNCTION     reduce using rule 88 (type -> BIT_AND type .)
    AS              reduce using rule 88 (type -> BIT_AND type .)
    RPAREN          reduce using rule 88 (type -> BIT_AND type .)
    COMMA           reduce using rule 88 (type -> BIT_AND type .)
    LBRACE          reduce using rule 88 (type -> BIT_AND type .)
    RBRACKET        reduce using rule 88 (type -> BIT_AND type .)
    RBRACE          reduce using rule 88 (type -> BIT_AND type .)
    CLOSURE_PIPE    reduce using rule 88 (type -> BIT_AND type .)
    ASIGNED_TO      reduce using rule 88 (type -> BIT_AND type .)
    IDENTIFIER      reduce using rule 88 (type -> BIT_AND type .)
    LPAREN          reduce using rule 88 (type -> BIT_AND type .)
    NOT             reduce using rule 88 (type -> BIT_AND type .)
    INTEGER         reduce using rule 88 (type -> BIT_AND type .)
    FLOAT           reduce using rule 88 (type -> BIT_AND type .)
    STRING          reduce using rule 88 (type -> BIT_AND type .)
    CHAR            reduce using rule 88 (type -> BIT_AND type .)
    BOOLEAN         reduce using rule 88 (type -> BIT_AND type .)
    BIT_AND         reduce using rule 88 (type -> BIT_AND type .)
    LBRACKET        reduce using rule 88 (type -> BIT_AND type .)


state 159

    (89) type -> BIT_AND MUT . type
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 206

state 160

    (108) type -> LPAREN tuple_type_list . RPAREN

    RPAREN          shift and go to state 207


state 161

    (109) tuple_type_list -> type .
    (110) tuple_type_list -> type . COMMA tuple_type_list

    RPAREN          reduce using rule 109 (tuple_type_list -> type .)
    COMMA           shift and go to state 208


state 162

    (69) statement -> IF condition LBRACE program_opt . RBRACE
    (70) statement -> IF condition LBRACE program_opt . RBRACE ELSE LBRACE program_opt RBRACE

    RBRACE          shift and go to state 209


state 163

    (3) program_opt -> program .
    (1) program -> program . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    statement                      shift and go to state 28
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 164

    (4) program_opt -> empty .
    (117) maybe_pub -> empty .

    RBRACE          reduce using rule 4 (program_opt -> empty .)
    FN              reduce using rule 117 (maybe_pub -> empty .)


state 165

    (63) condition -> condition CONJUNCTION condition .
    (63) condition -> condition . CONJUNCTION condition
    (64) condition -> condition . DISJUNCTION condition

    LBRACE          reduce using rule 63 (condition -> condition CONJUNCTION condition .)
    CONJUNCTION     reduce using rule 63 (condition -> condition CONJUNCTION condition .)
    DISJUNCTION     reduce using rule 63 (condition -> condition CONJUNCTION condition .)
    RPAREN          reduce using rule 63 (condition -> condition CONJUNCTION condition .)

  ! CONJUNCTION     [ shift and go to state 115 ]
  ! DISJUNCTION     [ shift and go to state 116 ]


state 166

    (64) condition -> condition DISJUNCTION condition .
    (63) condition -> condition . CONJUNCTION condition
    (64) condition -> condition . DISJUNCTION condition

    LBRACE          reduce using rule 64 (condition -> condition DISJUNCTION condition .)
    DISJUNCTION     reduce using rule 64 (condition -> condition DISJUNCTION condition .)
    RPAREN          reduce using rule 64 (condition -> condition DISJUNCTION condition .)
    CONJUNCTION     shift and go to state 115

  ! CONJUNCTION     [ reduce using rule 64 (condition -> condition DISJUNCTION condition .) ]
  ! DISJUNCTION     [ shift and go to state 116 ]


state 167

    (57) condition -> expression EQUAL_TO expression .
    (38) expression -> expression EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 38 (expression -> expression EQUAL_TO expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 38 (expression -> expression EQUAL_TO expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 38 (expression -> expression EQUAL_TO expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 38 (expression -> expression EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LESS_THAN       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    DOT             reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LBRACE          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RPAREN          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    COMMA           reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! LBRACE          [ reduce using rule 57 (condition -> expression EQUAL_TO expression .) ]
  ! CONJUNCTION     [ reduce using rule 57 (condition -> expression EQUAL_TO expression .) ]
  ! DISJUNCTION     [ reduce using rule 57 (condition -> expression EQUAL_TO expression .) ]
  ! RPAREN          [ reduce using rule 57 (condition -> expression EQUAL_TO expression .) ]
  ! PLUS            [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 168

    (58) condition -> expression NOT_EQUAL expression .
    (39) expression -> expression NOT_EQUAL expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 39 (expression -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 39 (expression -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 39 (expression -> expression NOT_EQUAL expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (expression -> expression NOT_EQUAL expression .)
    EQUAL_TO        reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    NOT_EQUAL       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LESS_THAN       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    GREATER_THAN    reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    DOT             reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    CONJUNCTION     reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    DISJUNCTION     reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LBRACE          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    COMMA           reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! LBRACE          [ reduce using rule 58 (condition -> expression NOT_EQUAL expression .) ]
  ! CONJUNCTION     [ reduce using rule 58 (condition -> expression NOT_EQUAL expression .) ]
  ! DISJUNCTION     [ reduce using rule 58 (condition -> expression NOT_EQUAL expression .) ]
  ! RPAREN          [ reduce using rule 58 (condition -> expression NOT_EQUAL expression .) ]
  ! PLUS            [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! MOD             [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! RANGE           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! AS              [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 169

    (59) condition -> expression LESS_THAN expression .
    (40) expression -> expression LESS_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 40 (expression -> expression LESS_THAN expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 40 (expression -> expression LESS_THAN expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 40 (expression -> expression LESS_THAN expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 40 (expression -> expression LESS_THAN expression .)
    EQUAL_TO        reduce using rule 40 (expression -> expression LESS_THAN expression .)
    NOT_EQUAL       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LESS_THAN       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    GREATER_THAN    reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> expression LESS_THAN expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> expression LESS_THAN expression .)
    DOT             reduce using rule 40 (expression -> expression LESS_THAN expression .)
    CONJUNCTION     reduce using rule 40 (expression -> expression LESS_THAN expression .)
    DISJUNCTION     reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LBRACE          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RPAREN          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    COMMA           reduce using rule 40 (expression -> expression LESS_THAN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! LBRACE          [ reduce using rule 59 (condition -> expression LESS_THAN expression .) ]
  ! CONJUNCTION     [ reduce using rule 59 (condition -> expression LESS_THAN expression .) ]
  ! DISJUNCTION     [ reduce using rule 59 (condition -> expression LESS_THAN expression .) ]
  ! RPAREN          [ reduce using rule 59 (condition -> expression LESS_THAN expression .) ]
  ! PLUS            [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! TIMES           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! MOD             [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! RANGE           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! AS              [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 170

    (60) condition -> expression GREATER_THAN expression .
    (41) expression -> expression GREATER_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 41 (expression -> expression GREATER_THAN expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 41 (expression -> expression GREATER_THAN expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 41 (expression -> expression GREATER_THAN expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 41 (expression -> expression GREATER_THAN expression .)
    EQUAL_TO        reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    NOT_EQUAL       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LESS_THAN       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    GREATER_THAN    reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    DOT             reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    CONJUNCTION     reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    DISJUNCTION     reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LBRACE          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RPAREN          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    COMMA           reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! LBRACE          [ reduce using rule 60 (condition -> expression GREATER_THAN expression .) ]
  ! CONJUNCTION     [ reduce using rule 60 (condition -> expression GREATER_THAN expression .) ]
  ! DISJUNCTION     [ reduce using rule 60 (condition -> expression GREATER_THAN expression .) ]
  ! RPAREN          [ reduce using rule 60 (condition -> expression GREATER_THAN expression .) ]
  ! PLUS            [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! TIMES           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! MOD             [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! RANGE           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! AS              [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 171

    (61) condition -> expression LESS_THAN_OR_EQUAL_TO expression .
    (42) expression -> expression LESS_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LESS_THAN       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DOT             reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LBRACE          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    COMMA           reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! LBRACE          [ reduce using rule 61 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! CONJUNCTION     [ reduce using rule 61 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DISJUNCTION     [ reduce using rule 61 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RPAREN          [ reduce using rule 61 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! PLUS            [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 172

    (62) condition -> expression GREATER_THAN_OR_EQUAL_TO expression .
    (43) expression -> expression GREATER_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! reduce/reduce conflict for CONJUNCTION resolved using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
  ! reduce/reduce conflict for DISJUNCTION resolved using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
  ! reduce/reduce conflict for LBRACE resolved using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LESS_THAN       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DOT             reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LBRACE          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    COMMA           reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! LBRACE          [ reduce using rule 62 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! CONJUNCTION     [ reduce using rule 62 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DISJUNCTION     [ reduce using rule 62 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RPAREN          [ reduce using rule 62 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! PLUS            [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 173

    (66) condition -> LPAREN condition RPAREN .

    LBRACE          reduce using rule 66 (condition -> LPAREN condition RPAREN .)
    CONJUNCTION     reduce using rule 66 (condition -> LPAREN condition RPAREN .)
    DISJUNCTION     reduce using rule 66 (condition -> LPAREN condition RPAREN .)
    RPAREN          reduce using rule 66 (condition -> LPAREN condition RPAREN .)


state 174

    (71) statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .

    PRINTLN         reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    IF              reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    IDENTIFIER      reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    WHILE           reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    ASYNC           reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FOR             reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    RETURN          reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LPAREN          reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    NOT             reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    MINUS           reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    INTEGER         reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FLOAT           reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    STRING          reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CHAR            reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    BOOLEAN         reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    BIT_AND         reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LBRACKET        reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LET             reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CONST           reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    $end            reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FN              reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    RBRACE          reduce using rule 71 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)


state 175

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN . RPAREN

    RPAREN          shift and go to state 210


state 176

    (123) expression -> IDENTIFIER LPAREN arguments_opt RPAREN .

    SEMICOLON       reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DOT             reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    PLUS            reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    MINUS           reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    TIMES           reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DIVIDE          reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    MOD             reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE           reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE_INCLUSIVE reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    EQUAL_TO        reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    NOT_EQUAL       reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN       reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN    reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    CONJUNCTION     reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DISJUNCTION     reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    AS              reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RPAREN          reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    COMMA           reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LBRACE          reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACKET        reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACE          reduce using rule 123 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)


state 177

    (16) argument_list -> argument_list COMMA . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 211

state 178

    (102) expression -> IDENTIFIER LBRACKET expression RBRACKET .

    SEMICOLON       reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DOT             reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MOD             reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE           reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQUAL_TO        reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_THAN       reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_THAN    reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CONJUNCTION     reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DISJUNCTION     reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    AS              reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 102 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)


state 179

    (103) expression -> IDENTIFIER LBRACKET INTEGER RANGE . INTEGER RBRACKET

    INTEGER         shift and go to state 212


state 180

    (104) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE . INTEGER RBRACKET

    INTEGER         shift and go to state 213


state 181

    (105) expression -> IDENTIFIER NOT LBRACKET element_list . RBRACKET
    (98) element_list -> element_list . COMMA expression

    RBRACKET        shift and go to state 214
    COMMA           shift and go to state 148


state 182

    (99) element_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    RBRACKET        reduce using rule 99 (element_list -> expression .)
    COMMA           reduce using rule 99 (element_list -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 183

    (72) statement -> WHILE condition LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 215


state 184

    (73) statement -> ASYNC FN function_name LPAREN . RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> ASYNC FN function_name LPAREN . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 216


state 185

    (115) statement -> FOR IDENTIFIER IN expression . LBRACE program_opt RBRACE
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    LBRACE          shift and go to state 217
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 186

    (120) statement -> maybe_pub FN function_name LPAREN . RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> maybe_pub FN function_name LPAREN . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 218


state 187

    (28) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .

    SEMICOLON       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DOT             reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    PLUS            reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    MINUS           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    TIMES           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DIVIDE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    MOD             reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RANGE           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RANGE_INCLUSIVE reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    EQUAL_TO        reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    NOT_EQUAL       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LESS_THAN       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    GREATER_THAN    reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    CONJUNCTION     reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DISJUNCTION     reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    AS              reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RPAREN          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    COMMA           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LBRACE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RBRACKET        reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RBRACE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)


state 188

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW . type closure_body
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 219

state 189

    (23) closure_body -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for CONJUNCTION resolved as shift
  ! shift/reduce conflict for DISJUNCTION resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    SEMICOLON       reduce using rule 23 (closure_body -> expression .)
    RPAREN          reduce using rule 23 (closure_body -> expression .)
    COMMA           reduce using rule 23 (closure_body -> expression .)
    LBRACE          reduce using rule 23 (closure_body -> expression .)
    RBRACKET        reduce using rule 23 (closure_body -> expression .)
    RBRACE          reduce using rule 23 (closure_body -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! DOT             [ reduce using rule 23 (closure_body -> expression .) ]
  ! PLUS            [ reduce using rule 23 (closure_body -> expression .) ]
  ! MINUS           [ reduce using rule 23 (closure_body -> expression .) ]
  ! TIMES           [ reduce using rule 23 (closure_body -> expression .) ]
  ! DIVIDE          [ reduce using rule 23 (closure_body -> expression .) ]
  ! MOD             [ reduce using rule 23 (closure_body -> expression .) ]
  ! RANGE           [ reduce using rule 23 (closure_body -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 23 (closure_body -> expression .) ]
  ! EQUAL_TO        [ reduce using rule 23 (closure_body -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 23 (closure_body -> expression .) ]
  ! LESS_THAN       [ reduce using rule 23 (closure_body -> expression .) ]
  ! GREATER_THAN    [ reduce using rule 23 (closure_body -> expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 23 (closure_body -> expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 23 (closure_body -> expression .) ]
  ! CONJUNCTION     [ reduce using rule 23 (closure_body -> expression .) ]
  ! DISJUNCTION     [ reduce using rule 23 (closure_body -> expression .) ]
  ! AS              [ reduce using rule 23 (closure_body -> expression .) ]


state 190

    (24) closure_body -> LBRACE . closure_block_content RBRACE
    (25) closure_block_content -> . expression
    (26) closure_block_content -> . program expression
    (27) closure_block_content -> . program_opt
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (1) program -> . program statement
    (2) program -> . statement
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (5) empty -> .
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    IDENTIFIER      shift and go to state 224
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    LET             shift and go to state 25
    CONST           shift and go to state 26

    closure_block_content          shift and go to state 220
    expression                     shift and go to state 221
    program                        shift and go to state 222
    program_opt                    shift and go to state 223
    statement                      shift and go to state 2
    empty                          shift and go to state 164
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 191

    (20) closure_params -> IDENTIFIER COLON type .
    (22) closure_params -> IDENTIFIER COLON type . COMMA closure_params

    CLOSURE_PIPE    reduce using rule 20 (closure_params -> IDENTIFIER COLON type .)
    COMMA           shift and go to state 225


state 192

    (21) closure_params -> IDENTIFIER COMMA closure_params .

    CLOSURE_PIPE    reduce using rule 21 (closure_params -> IDENTIFIER COMMA closure_params .)


state 193

    (98) element_list -> element_list COMMA expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    RBRACKET        reduce using rule 98 (element_list -> element_list COMMA expression .)
    COMMA           reduce using rule 98 (element_list -> element_list COMMA expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 194

    (101) expression -> LBRACKET expression SEMICOLON INTEGER . RBRACKET

    RBRACKET        shift and go to state 226


state 195

    (91) let_decl -> LET maybe_mut IDENTIFIER maybe_type . maybe_init SEMICOLON
    (96) maybe_init -> . ASIGNED_TO expression
    (97) maybe_init -> . empty
    (5) empty -> .

    ASIGNED_TO      shift and go to state 228
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_init                     shift and go to state 227
    empty                          shift and go to state 229

state 196

    (94) maybe_type -> COLON . type
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 230

state 197

    (95) maybe_type -> empty .

    ASIGNED_TO      reduce using rule 95 (maybe_type -> empty .)
    SEMICOLON       reduce using rule 95 (maybe_type -> empty .)


state 198

    (107) const_decl -> CONST IDENTIFIER COLON type . ASIGNED_TO expression SEMICOLON

    ASIGNED_TO      shift and go to state 231


state 199

    (6) statement -> PRINTLN NOT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 232


state 200

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA . argument_list RPAREN SEMICOLON
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    argument_list                  shift and go to state 233
    expression                     shift and go to state 132

state 201

    (7) statement -> PRINTLN NOT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 234


state 202

    (9) expression -> expression DOT IDENTIFIER LPAREN expression . COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER LPAREN expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER
    (17) argument_list -> expression .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMMA           shift and go to state 235
    RPAREN          shift and go to state 236
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! COMMA           [ reduce using rule 17 (argument_list -> expression .) ]
  ! RPAREN          [ reduce using rule 17 (argument_list -> expression .) ]


state 203

    (13) expression -> expression DOT IDENTIFIER LPAREN arguments_opt . RPAREN

    RPAREN          shift and go to state 237


state 204

    (86) type -> LBRACKET type RBRACKET .

    SEMICOLON       reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    DOT             reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    PLUS            reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    MINUS           reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    TIMES           reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    DIVIDE          reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    MOD             reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    RANGE           reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    EQUAL_TO        reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    NOT_EQUAL       reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    LESS_THAN       reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    GREATER_THAN    reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    CONJUNCTION     reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    DISJUNCTION     reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    AS              reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    COMMA           reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    LBRACE          reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    RBRACE          reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    CLOSURE_PIPE    reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    ASIGNED_TO      reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    IDENTIFIER      reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    LPAREN          reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    NOT             reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    INTEGER         reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    FLOAT           reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    STRING          reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    CHAR            reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    BOOLEAN         reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    BIT_AND         reduce using rule 86 (type -> LBRACKET type RBRACKET .)
    LBRACKET        reduce using rule 86 (type -> LBRACKET type RBRACKET .)


state 205

    (87) type -> LBRACKET type COMMA . INTEGER RBRACKET

    INTEGER         shift and go to state 238


state 206

    (89) type -> BIT_AND MUT type .

    SEMICOLON       reduce using rule 89 (type -> BIT_AND MUT type .)
    DOT             reduce using rule 89 (type -> BIT_AND MUT type .)
    PLUS            reduce using rule 89 (type -> BIT_AND MUT type .)
    MINUS           reduce using rule 89 (type -> BIT_AND MUT type .)
    TIMES           reduce using rule 89 (type -> BIT_AND MUT type .)
    DIVIDE          reduce using rule 89 (type -> BIT_AND MUT type .)
    MOD             reduce using rule 89 (type -> BIT_AND MUT type .)
    RANGE           reduce using rule 89 (type -> BIT_AND MUT type .)
    RANGE_INCLUSIVE reduce using rule 89 (type -> BIT_AND MUT type .)
    EQUAL_TO        reduce using rule 89 (type -> BIT_AND MUT type .)
    NOT_EQUAL       reduce using rule 89 (type -> BIT_AND MUT type .)
    LESS_THAN       reduce using rule 89 (type -> BIT_AND MUT type .)
    GREATER_THAN    reduce using rule 89 (type -> BIT_AND MUT type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 89 (type -> BIT_AND MUT type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 89 (type -> BIT_AND MUT type .)
    CONJUNCTION     reduce using rule 89 (type -> BIT_AND MUT type .)
    DISJUNCTION     reduce using rule 89 (type -> BIT_AND MUT type .)
    AS              reduce using rule 89 (type -> BIT_AND MUT type .)
    RPAREN          reduce using rule 89 (type -> BIT_AND MUT type .)
    COMMA           reduce using rule 89 (type -> BIT_AND MUT type .)
    LBRACE          reduce using rule 89 (type -> BIT_AND MUT type .)
    RBRACKET        reduce using rule 89 (type -> BIT_AND MUT type .)
    RBRACE          reduce using rule 89 (type -> BIT_AND MUT type .)
    CLOSURE_PIPE    reduce using rule 89 (type -> BIT_AND MUT type .)
    ASIGNED_TO      reduce using rule 89 (type -> BIT_AND MUT type .)
    IDENTIFIER      reduce using rule 89 (type -> BIT_AND MUT type .)
    LPAREN          reduce using rule 89 (type -> BIT_AND MUT type .)
    NOT             reduce using rule 89 (type -> BIT_AND MUT type .)
    INTEGER         reduce using rule 89 (type -> BIT_AND MUT type .)
    FLOAT           reduce using rule 89 (type -> BIT_AND MUT type .)
    STRING          reduce using rule 89 (type -> BIT_AND MUT type .)
    CHAR            reduce using rule 89 (type -> BIT_AND MUT type .)
    BOOLEAN         reduce using rule 89 (type -> BIT_AND MUT type .)
    BIT_AND         reduce using rule 89 (type -> BIT_AND MUT type .)
    LBRACKET        reduce using rule 89 (type -> BIT_AND MUT type .)


state 207

    (108) type -> LPAREN tuple_type_list RPAREN .

    SEMICOLON       reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    DOT             reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    PLUS            reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    MINUS           reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    TIMES           reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    DIVIDE          reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    MOD             reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    RANGE           reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    RANGE_INCLUSIVE reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    EQUAL_TO        reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    NOT_EQUAL       reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    LESS_THAN       reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    GREATER_THAN    reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    CONJUNCTION     reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    DISJUNCTION     reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    AS              reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    RPAREN          reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    COMMA           reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    LBRACE          reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    RBRACKET        reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    RBRACE          reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    CLOSURE_PIPE    reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    ASIGNED_TO      reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    IDENTIFIER      reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    LPAREN          reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    NOT             reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    INTEGER         reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    FLOAT           reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    STRING          reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    CHAR            reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    BOOLEAN         reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    BIT_AND         reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)
    LBRACKET        reduce using rule 108 (type -> LPAREN tuple_type_list RPAREN .)


state 208

    (110) tuple_type_list -> type COMMA . tuple_type_list
    (109) tuple_type_list -> . type
    (110) tuple_type_list -> . type COMMA tuple_type_list
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 161
    tuple_type_list                shift and go to state 239

state 209

    (69) statement -> IF condition LBRACE program_opt RBRACE .
    (70) statement -> IF condition LBRACE program_opt RBRACE . ELSE LBRACE program_opt RBRACE

    PRINTLN         reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    IF              reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    FOR             reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    NOT             reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    STRING          reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    LET             reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    CONST           reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    $end            reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    FN              reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 69 (statement -> IF condition LBRACE program_opt RBRACE .)
    ELSE            shift and go to state 240


state 210

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MOD             reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RANGE           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RANGE_INCLUSIVE reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    EQUAL_TO        reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN    reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    CONJUNCTION     reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DISJUNCTION     reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    AS              reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)


state 211

    (16) argument_list -> argument_list COMMA expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    COMMA           reduce using rule 16 (argument_list -> argument_list COMMA expression .)
    RPAREN          reduce using rule 16 (argument_list -> argument_list COMMA expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 212

    (103) expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER . RBRACKET

    RBRACKET        shift and go to state 241


state 213

    (104) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER . RBRACKET

    RBRACKET        shift and go to state 242


state 214

    (105) expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DOT             reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    PLUS            reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    MINUS           reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    TIMES           reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DIVIDE          reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    MOD             reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RANGE           reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    EQUAL_TO        reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    NOT_EQUAL       reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LESS_THAN       reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    GREATER_THAN    reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    CONJUNCTION     reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DISJUNCTION     reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    AS              reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LBRACE          reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 105 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)


state 215

    (72) statement -> WHILE condition LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    IF              reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    FOR             reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    NOT             reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    STRING          reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    LET             reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    CONST           reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    $end            reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    FN              reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 72 (statement -> WHILE condition LBRACE program_opt RBRACE .)


state 216

    (73) statement -> ASYNC FN function_name LPAREN RPAREN . ARROW type LBRACE program_opt RBRACE
    (74) statement -> ASYNC FN function_name LPAREN RPAREN . LBRACE program_opt RBRACE

    ARROW           shift and go to state 243
    LBRACE          shift and go to state 244


state 217

    (115) statement -> FOR IDENTIFIER IN expression LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    expression                     shift and go to state 7
    program_opt                    shift and go to state 245
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 218

    (120) statement -> maybe_pub FN function_name LPAREN RPAREN . ARROW type LBRACE program_opt RBRACE
    (121) statement -> maybe_pub FN function_name LPAREN RPAREN . LBRACE program_opt RBRACE

    ARROW           shift and go to state 246
    LBRACE          shift and go to state 247


state 219

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type . closure_body
    (23) closure_body -> . expression
    (24) closure_body -> . LBRACE closure_block_content RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    LBRACE          shift and go to state 190
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    closure_body                   shift and go to state 248
    expression                     shift and go to state 189

state 220

    (24) closure_body -> LBRACE closure_block_content . RBRACE

    RBRACE          shift and go to state 249


state 221

    (25) closure_block_content -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 25 (closure_block_content -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    SEMICOLON       shift and go to state 34


state 222

    (26) closure_block_content -> program . expression
    (1) program -> program . statement
    (3) program_opt -> program .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    IDENTIFIER      shift and go to state 224
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    expression                     shift and go to state 250
    statement                      shift and go to state 28
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 223

    (27) closure_block_content -> program_opt .

    RBRACE          reduce using rule 27 (closure_block_content -> program_opt .)


state 224

    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (53) expression -> IDENTIFIER .
    (102) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (103) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (123) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN
    (71) statement -> IDENTIFIER . ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> IDENTIFIER .

    DOUBLE_COLON    shift and go to state 58
    DOT             reduce using rule 53 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 53 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 53 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 53 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (expression -> IDENTIFIER .)
    MOD             reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE           reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 53 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    AS              reduce using rule 53 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 60
    NOT             shift and go to state 61
    LPAREN          shift and go to state 59
    ASIGNED_TO      shift and go to state 57
    FN              reduce using rule 116 (maybe_pub -> IDENTIFIER .)


state 225

    (22) closure_params -> IDENTIFIER COLON type COMMA . closure_params
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 68

    closure_params                 shift and go to state 251

state 226

    (101) expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .

    SEMICOLON       reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DOT             reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    PLUS            reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    MINUS           reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    TIMES           reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DIVIDE          reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    MOD             reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RANGE           reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    AS              reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RPAREN          reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    COMMA           reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LBRACE          reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RBRACKET        reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RBRACE          reduce using rule 101 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)


state 227

    (91) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init . SEMICOLON

    SEMICOLON       shift and go to state 252


state 228

    (96) maybe_init -> ASIGNED_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 253

state 229

    (97) maybe_init -> empty .

    SEMICOLON       reduce using rule 97 (maybe_init -> empty .)


state 230

    (94) maybe_type -> COLON type .

    ASIGNED_TO      reduce using rule 94 (maybe_type -> COLON type .)
    SEMICOLON       reduce using rule 94 (maybe_type -> COLON type .)


state 231

    (107) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 254

state 232

    (6) statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .

    PRINTLN         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    ASYNC           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LPAREN          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    NOT             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    MINUS           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    INTEGER         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FLOAT           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    STRING          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CHAR            reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LET             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CONST           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    $end            reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FN              reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RBRACE          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)


state 233

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list . RPAREN SEMICOLON
    (16) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 255
    COMMA           shift and go to state 177


state 234

    (7) statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .

    PRINTLN         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    ASYNC           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    INTEGER         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FLOAT           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CHAR            reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LET             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FN              reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)


state 235

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA . expression RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 256

state 236

    (10) expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DOT             reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    PLUS            reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    MINUS           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    TIMES           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    MOD             reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RANGE           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    EQUAL_TO        reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    CONJUNCTION     reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DISJUNCTION     reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    AS              reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RPAREN          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    COMMA           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LBRACE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RBRACE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)


state 237

    (13) expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .

    SEMICOLON       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DOT             reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    PLUS            reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    MINUS           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    TIMES           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DIVIDE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    MOD             reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE_INCLUSIVE reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    EQUAL_TO        reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    NOT_EQUAL       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN    reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    CONJUNCTION     reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DISJUNCTION     reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    AS              reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RPAREN          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    COMMA           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LBRACE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACKET        reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)


state 238

    (87) type -> LBRACKET type COMMA INTEGER . RBRACKET

    RBRACKET        shift and go to state 257


state 239

    (110) tuple_type_list -> type COMMA tuple_type_list .

    RPAREN          reduce using rule 110 (tuple_type_list -> type COMMA tuple_type_list .)


state 240

    (70) statement -> IF condition LBRACE program_opt RBRACE ELSE . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 258


state 241

    (103) expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .

    SEMICOLON       reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DOT             reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    PLUS            reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MINUS           reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    TIMES           reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MOD             reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RANGE           reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    AS              reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RPAREN          reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    COMMA           reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LBRACE          reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACE          reduce using rule 103 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)


state 242

    (104) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .

    SEMICOLON       reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DOT             reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    PLUS            reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MINUS           reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    TIMES           reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MOD             reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RANGE           reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    AS              reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RPAREN          reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    COMMA           reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LBRACE          reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACE          reduce using rule 104 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)


state 243

    (73) statement -> ASYNC FN function_name LPAREN RPAREN ARROW . type LBRACE program_opt RBRACE
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 259

state 244

    (74) statement -> ASYNC FN function_name LPAREN RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    program_opt                    shift and go to state 260
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 245

    (115) statement -> FOR IDENTIFIER IN expression LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 261


state 246

    (120) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW . type LBRACE program_opt RBRACE
    (75) type -> . TYPE_I32
    (76) type -> . TYPE_U8
    (77) type -> . TYPE_U16
    (78) type -> . TYPE_U32
    (79) type -> . TYPE_U64
    (80) type -> . TYPE_F64
    (81) type -> . TYPE_CHAR
    (82) type -> . TYPE_STRING
    (83) type -> . TYPE_STR
    (84) type -> . TYPE_BOOL
    (85) type -> . TYPE_TUPLE
    (86) type -> . LBRACKET type RBRACKET
    (87) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (88) type -> . BIT_AND type
    (89) type -> . BIT_AND MUT type
    (108) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 100
    TYPE_U8         shift and go to state 101
    TYPE_U16        shift and go to state 102
    TYPE_U32        shift and go to state 103
    TYPE_U64        shift and go to state 104
    TYPE_F64        shift and go to state 105
    TYPE_CHAR       shift and go to state 106
    TYPE_STRING     shift and go to state 107
    TYPE_STR        shift and go to state 108
    TYPE_BOOL       shift and go to state 109
    TYPE_TUPLE      shift and go to state 110
    LBRACKET        shift and go to state 111
    BIT_AND         shift and go to state 112
    LPAREN          shift and go to state 113

    type                           shift and go to state 262

state 247

    (121) statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    maybe_pub                      shift and go to state 15
    program_opt                    shift and go to state 263
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13

state 248

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .

    SEMICOLON       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DOT             reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    PLUS            reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    MINUS           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    TIMES           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DIVIDE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    MOD             reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RANGE           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RANGE_INCLUSIVE reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    EQUAL_TO        reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    NOT_EQUAL       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LESS_THAN       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    GREATER_THAN    reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    CONJUNCTION     reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DISJUNCTION     reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    AS              reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RPAREN          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    COMMA           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LBRACE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RBRACKET        reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RBRACE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)


state 249

    (24) closure_body -> LBRACE closure_block_content RBRACE .

    DOT             reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    PLUS            reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    MINUS           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    TIMES           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    DIVIDE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    MOD             reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RANGE           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RANGE_INCLUSIVE reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    EQUAL_TO        reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    NOT_EQUAL       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LESS_THAN       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    GREATER_THAN    reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    CONJUNCTION     reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    DISJUNCTION     reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    AS              reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    SEMICOLON       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RPAREN          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    COMMA           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LBRACE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RBRACKET        reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RBRACE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)


state 250

    (26) closure_block_content -> program expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 26 (closure_block_content -> program expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    SEMICOLON       shift and go to state 34


state 251

    (22) closure_params -> IDENTIFIER COLON type COMMA closure_params .

    CLOSURE_PIPE    reduce using rule 22 (closure_params -> IDENTIFIER COLON type COMMA closure_params .)


state 252

    (91) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .

    PRINTLN         reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IF              reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IDENTIFIER      reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    WHILE           reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    ASYNC           reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FOR             reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RETURN          reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LPAREN          reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    NOT             reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    MINUS           reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    INTEGER         reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FLOAT           reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    STRING          reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CHAR            reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    BOOLEAN         reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    BIT_AND         reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LBRACKET        reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LET             reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CONST           reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    $end            reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FN              reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RBRACE          reduce using rule 91 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)


state 253

    (96) maybe_init -> ASIGNED_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 96 (maybe_init -> ASIGNED_TO expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 254

    (107) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 264
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 255

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 265


state 256

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (114) expression -> expression . DOT INTEGER

    RPAREN          shift and go to state 266
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 257

    (87) type -> LBRACKET type COMMA INTEGER RBRACKET .

    SEMICOLON       reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    DOT             reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    PLUS            reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    MINUS           reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    TIMES           reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    DIVIDE          reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    MOD             reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RANGE           reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    AS              reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RPAREN          reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    COMMA           reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LBRACE          reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RBRACKET        reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RBRACE          reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    CLOSURE_PIPE    reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    ASIGNED_TO      reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    IDENTIFIER      reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LPAREN          reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    NOT             reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    INTEGER         reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    FLOAT           reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    STRING          reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    CHAR            reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    BOOLEAN         reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    BIT_AND         reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LBRACKET        reduce using rule 87 (type -> LBRACKET type COMMA INTEGER RBRACKET .)


state 258

    (70) statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    program_opt                    shift and go to state 267
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 259

    (73) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 268


state 260

    (74) statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 269


state 261

    (115) statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    IF              reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FOR             reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    NOT             reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    STRING          reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LET             reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CONST           reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    $end            reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FN              reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 115 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)


state 262

    (120) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 270


state 263

    (121) statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 271


state 264

    (107) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .

    PRINTLN         reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    IF              reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    IDENTIFIER      reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    WHILE           reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    ASYNC           reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FOR             reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    RETURN          reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LPAREN          reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    NOT             reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    MINUS           reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    INTEGER         reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FLOAT           reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    STRING          reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CHAR            reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    BOOLEAN         reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    BIT_AND         reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LBRACKET        reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LET             reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CONST           reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    $end            reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FN              reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    RBRACE          reduce using rule 107 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)


state 265

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .

    PRINTLN         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    IF              reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    ASYNC           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FOR             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LPAREN          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    NOT             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    MINUS           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    INTEGER         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    STRING          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CHAR            reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LET             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CONST           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FN              reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)


state 266

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .

    SEMICOLON       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DOT             reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    PLUS            reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    MINUS           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    TIMES           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DIVIDE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    MOD             reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RANGE           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    EQUAL_TO        reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    NOT_EQUAL       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LESS_THAN       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    GREATER_THAN    reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    CONJUNCTION     reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DISJUNCTION     reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    AS              reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RPAREN          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    COMMA           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LBRACE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RBRACKET        reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RBRACE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)


state 267

    (70) statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 272


state 268

    (73) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    program_opt                    shift and go to state 273
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 269

    (74) statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FOR             reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    NOT             reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    STRING          reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 74 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)


state 270

    (120) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (69) statement -> . IF condition LBRACE program_opt RBRACE
    (70) statement -> . IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (71) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (72) statement -> . WHILE condition LBRACE program_opt RBRACE
    (73) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (74) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (90) statement -> . let_decl
    (106) statement -> . const_decl
    (115) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (120) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (121) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (122) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (100) expression -> . LBRACKET element_list RBRACKET
    (101) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (102) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (103) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (104) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (105) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (111) expression -> . LPAREN tuple_value_list RPAREN
    (114) expression -> . expression DOT INTEGER
    (123) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (91) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (107) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (116) maybe_pub -> . IDENTIFIER
    (117) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    maybe_pub                      shift and go to state 15
    program_opt                    shift and go to state 274
    program                        shift and go to state 163
    empty                          shift and go to state 164
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13

state 271

    (121) statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FOR             reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    NOT             reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    STRING          reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 121 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)


state 272

    (70) statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    IF              reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    FOR             reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    NOT             reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    STRING          reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    LET             reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    CONST           reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    $end            reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    FN              reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 70 (statement -> IF condition LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)


state 273

    (73) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 275


state 274

    (120) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 276


state 275

    (73) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IF              reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FOR             reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    NOT             reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    STRING          reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LET             reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CONST           reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    $end            reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FN              reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 73 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)


state 276

    (120) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IF              reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FOR             reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    NOT             reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    STRING          reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LET             reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CONST           reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    $end            reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FN              reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 120 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 32 resolved as shift
WARNING: shift/reduce conflict for CONJUNCTION in state 53 resolved as shift
WARNING: shift/reduce conflict for DISJUNCTION in state 53 resolved as shift
WARNING: shift/reduce conflict for DOT in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 70 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 70 resolved as shift
WARNING: shift/reduce conflict for MOD in state 70 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 70 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 70 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 70 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 70 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 70 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 70 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_OR_EQUAL_TO in state 70 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO in state 70 resolved as shift
WARNING: shift/reduce conflict for CONJUNCTION in state 70 resolved as shift
WARNING: shift/reduce conflict for DISJUNCTION in state 70 resolved as shift
WARNING: shift/reduce conflict for AS in state 70 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 126 resolved as shift
WARNING: shift/reduce conflict for CONJUNCTION in state 126 resolved as shift
WARNING: shift/reduce conflict for DISJUNCTION in state 126 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 126 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 134 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 134 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 152 resolved as shift
WARNING: shift/reduce conflict for DOT in state 189 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 189 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 189 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 189 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 189 resolved as shift
WARNING: shift/reduce conflict for MOD in state 189 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 189 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 189 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 189 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 189 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 189 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 189 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_OR_EQUAL_TO in state 189 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO in state 189 resolved as shift
WARNING: shift/reduce conflict for CONJUNCTION in state 189 resolved as shift
WARNING: shift/reduce conflict for DISJUNCTION in state 189 resolved as shift
WARNING: shift/reduce conflict for AS in state 189 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 202 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 202 resolved as shift
WARNING: reduce/reduce conflict in state 56 resolved using rule (expression -> BOOLEAN)
WARNING: rejected rule (condition -> BOOLEAN) in state 56
WARNING: reduce/reduce conflict in state 124 resolved using rule (expression -> NOT expression)
WARNING: rejected rule (condition -> expression) in state 124
WARNING: reduce/reduce conflict in state 167 resolved using rule (expression -> expression EQUAL_TO expression)
WARNING: rejected rule (condition -> expression EQUAL_TO expression) in state 167
WARNING: reduce/reduce conflict in state 168 resolved using rule (expression -> expression NOT_EQUAL expression)
WARNING: rejected rule (condition -> expression NOT_EQUAL expression) in state 168
WARNING: reduce/reduce conflict in state 169 resolved using rule (expression -> expression LESS_THAN expression)
WARNING: rejected rule (condition -> expression LESS_THAN expression) in state 169
WARNING: reduce/reduce conflict in state 170 resolved using rule (expression -> expression GREATER_THAN expression)
WARNING: rejected rule (condition -> expression GREATER_THAN expression) in state 170
WARNING: reduce/reduce conflict in state 171 resolved using rule (expression -> expression LESS_THAN_OR_EQUAL_TO expression)
WARNING: rejected rule (condition -> expression LESS_THAN_OR_EQUAL_TO expression) in state 171
WARNING: reduce/reduce conflict in state 172 resolved using rule (expression -> expression GREATER_THAN_OR_EQUAL_TO expression)
WARNING: rejected rule (condition -> expression GREATER_THAN_OR_EQUAL_TO expression) in state 172
WARNING: Rule (condition -> BOOLEAN) is never reduced
WARNING: Rule (condition -> expression EQUAL_TO expression) is never reduced
WARNING: Rule (condition -> expression NOT_EQUAL expression) is never reduced
WARNING: Rule (condition -> expression LESS_THAN expression) is never reduced
WARNING: Rule (condition -> expression GREATER_THAN expression) is never reduced
WARNING: Rule (condition -> expression LESS_THAN_OR_EQUAL_TO expression) is never reduced
WARNING: Rule (condition -> expression GREATER_THAN_OR_EQUAL_TO expression) is never reduced
