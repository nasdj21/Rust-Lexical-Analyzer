Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BIT_NOT
    BIT_OR
    BIT_XOR
    BREAK
    CONTINUE
    DIVIDE_EQUAL
    ELSE
    ENUM
    LOOP
    MATCH
    MINUS_EQUAL
    MOD_EQUAL
    PLUS_EQUAL
    SHIFT_LEFT
    SHIFT_RIGHT
    THEN
    TIMES_EQUAL
    WHERE

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     program_opt -> program
Rule 4     program_opt -> empty
Rule 5     empty -> <empty>
Rule 6     statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
Rule 7     statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON
Rule 8     statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
Rule 9     expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
Rule 10    expression -> expression DOT IDENTIFIER LPAREN expression RPAREN
Rule 11    expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
Rule 12    statement -> expression SEMICOLON
Rule 13    expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
Rule 14    arguments_opt -> argument_list
Rule 15    arguments_opt -> empty
Rule 16    argument_list -> argument_list COMMA expression
Rule 17    argument_list -> expression
Rule 18    closure_params -> <empty>
Rule 19    closure_params -> IDENTIFIER
Rule 20    closure_params -> IDENTIFIER COLON type
Rule 21    closure_params -> IDENTIFIER COMMA closure_params
Rule 22    closure_params -> IDENTIFIER COLON type COMMA closure_params
Rule 23    closure_body -> expression
Rule 24    closure_body -> LBRACE closure_block_content RBRACE
Rule 25    closure_block_content -> expression
Rule 26    closure_block_content -> program expression
Rule 27    closure_block_content -> program_opt
Rule 28    expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
Rule 29    expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
Rule 30    expression -> LPAREN expression RPAREN
Rule 31    expression -> expression PLUS expression
Rule 32    expression -> expression MINUS expression
Rule 33    expression -> expression TIMES expression
Rule 34    expression -> expression DIVIDE expression
Rule 35    expression -> expression MOD expression
Rule 36    expression -> NOT expression
Rule 37    expression -> INTEGER
Rule 38    expression -> FLOAT
Rule 39    expression -> STRING
Rule 40    expression -> CHAR
Rule 41    expression -> BOOLEAN
Rule 42    expression -> IDENTIFIER
Rule 43    expression -> BIT_AND expression
Rule 44    expression -> BIT_AND MUT IDENTIFIER
Rule 45    expression -> expression AS type
Rule 46    condition -> expression EQUAL_TO expression
Rule 47    condition -> expression NOT_EQUAL expression
Rule 48    condition -> expression LESS_THAN expression
Rule 49    condition -> expression GREATER_THAN expression
Rule 50    condition -> expression LESS_THAN_OR_EQUAL_TO expression
Rule 51    condition -> expression GREATER_THAN_OR_EQUAL_TO expression
Rule 52    condition -> condition CONJUNCTION condition
Rule 53    condition -> condition DISJUNCTION condition
Rule 54    condition -> NOT condition
Rule 55    condition -> LPAREN condition RPAREN
Rule 56    statement -> IF condition LBRACE program_opt RBRACE
Rule 57    statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON
Rule 58    statement -> WHILE condition LBRACE program_opt RBRACE
Rule 59    statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
Rule 60    statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
Rule 61    type -> TYPE_I32
Rule 62    type -> TYPE_U64
Rule 63    type -> TYPE_F64
Rule 64    type -> TYPE_CHAR
Rule 65    type -> TYPE_STRING
Rule 66    type -> TYPE_BOOL
Rule 67    type -> TYPE_TUPLE
Rule 68    type -> LBRACKET type RBRACKET
Rule 69    type -> BIT_AND type
Rule 70    type -> BIT_AND MUT type
Rule 71    statement -> let_decl
Rule 72    let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
Rule 73    maybe_mut -> MUT
Rule 74    maybe_mut -> empty
Rule 75    maybe_type -> COLON type
Rule 76    maybe_type -> empty
Rule 77    maybe_init -> ASIGNED_TO expression
Rule 78    maybe_init -> empty
Rule 79    element_list -> element_list COMMA expression
Rule 80    element_list -> expression
Rule 81    expression -> LBRACKET element_list RBRACKET
Rule 82    expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET
Rule 83    expression -> IDENTIFIER LBRACKET expression RBRACKET
Rule 84    expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
Rule 85    expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
Rule 86    expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET
Rule 87    statement -> const_decl
Rule 88    const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
Rule 89    type -> LPAREN tuple_type_list RPAREN
Rule 90    tuple_type_list -> type
Rule 91    tuple_type_list -> type COMMA tuple_type_list
Rule 92    expression -> LPAREN tuple_value_list RPAREN
Rule 93    tuple_value_list -> expression
Rule 94    tuple_value_list -> expression COMMA tuple_value_list
Rule 95    expression -> expression DOT INTEGER
Rule 96    statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
Rule 97    maybe_pub -> IDENTIFIER
Rule 98    maybe_pub -> empty
Rule 99    function_name -> IDENTIFIER
Rule 100   function_name -> MAIN
Rule 101   statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
Rule 102   statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
Rule 103   statement -> RETURN expression SEMICOLON
Rule 104   expression -> IDENTIFIER LPAREN arguments_opt RPAREN

Terminals, with rules where they appear

ARROW                : 29 59 101
AS                   : 45
ASIGNED_TO           : 57 77 88
ASYNC                : 59 60
BIT_AND              : 43 44 69 70
BIT_NOT              : 
BIT_OR               : 
BIT_XOR              : 
BOOLEAN              : 41
BREAK                : 
CHAR                 : 40
CLOSURE_PIPE         : 28 28 29 29
COLON                : 20 22 75 88
COMMA                : 8 9 16 21 22 79 91 94
CONJUNCTION          : 52
CONST                : 88
CONTINUE             : 
DISJUNCTION          : 53
DIVIDE               : 34
DIVIDE_EQUAL         : 
DOT                  : 9 10 13 95
DOUBLE_COLON         : 11
ELSE                 : 
ENUM                 : 
EQUAL_TO             : 46
FLOAT                : 38
FN                   : 59 60 101 102
FOR                  : 96
GREATER_THAN         : 49
GREATER_THAN_OR_EQUAL_TO : 51
IDENTIFIER           : 9 10 11 11 13 19 20 21 22 42 44 57 72 83 84 85 86 88 96 97 99 104
IF                   : 56
IN                   : 96
INTEGER              : 37 82 84 84 85 85 95
LBRACE               : 24 56 58 59 60 96 101 102
LBRACKET             : 68 81 82 83 84 85 86
LESS_THAN            : 48
LESS_THAN_OR_EQUAL_TO : 50
LET                  : 72
LOOP                 : 
LPAREN               : 6 7 8 9 10 11 13 30 55 59 60 89 92 101 102 104
MAIN                 : 100
MATCH                : 
MINUS                : 32
MINUS_EQUAL          : 
MOD                  : 35
MOD_EQUAL            : 
MUT                  : 44 70 73
NOT                  : 6 7 8 36 54 86
NOT_EQUAL            : 47
PLUS                 : 31
PLUS_EQUAL           : 
PRINTLN              : 6 7 8
RANGE                : 84
RANGE_INCLUSIVE      : 85
RBRACE               : 24 56 58 59 60 96 101 102
RBRACKET             : 68 81 82 83 84 85 86
RETURN               : 103
RPAREN               : 6 7 8 9 10 11 13 30 55 59 60 89 92 101 102 104
SEMICOLON            : 6 7 8 12 57 72 82 88 103
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
STRING               : 6 8 39
THEN                 : 
TIMES                : 33
TIMES_EQUAL          : 
TYPE_BOOL            : 66
TYPE_CHAR            : 64
TYPE_F64             : 63
TYPE_I32             : 61
TYPE_STRING          : 65
TYPE_TUPLE           : 67
TYPE_U64             : 62
WHERE                : 
WHILE                : 58
error                : 

Nonterminals, with rules where they appear

argument_list        : 8 14 16
arguments_opt        : 13 104
closure_block_content : 24
closure_body         : 28 29
closure_params       : 21 22 28 29
condition            : 52 52 53 53 54 55 56 58
const_decl           : 87
element_list         : 79 81 86
empty                : 4 15 74 76 78 98
expression           : 7 9 9 9 10 10 12 13 16 17 23 25 26 30 31 31 32 32 33 33 34 34 35 35 36 43 45 46 46 47 47 48 48 49 49 50 50 51 51 57 77 79 80 82 83 88 93 94 95 96 103
function_name        : 59 60 101 102
let_decl             : 71
maybe_init           : 72
maybe_mut            : 72
maybe_pub            : 101 102
maybe_type           : 72
program              : 1 3 26 0
program_opt          : 27 56 58 59 60 96 101 102
statement            : 1 2
tuple_type_list      : 89 91
tuple_value_list     : 92 94
type                 : 20 22 29 45 59 68 69 70 75 88 90 91 101

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25
    FN              reduce using rule 5 (empty -> .)

    program                        shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 26

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25
    FN              reduce using rule 5 (empty -> .)

    statement                      shift and go to state 27
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 26

state 2

    (2) program -> statement .

    PRINTLN         reduce using rule 2 (program -> statement .)
    IF              reduce using rule 2 (program -> statement .)
    IDENTIFIER      reduce using rule 2 (program -> statement .)
    WHILE           reduce using rule 2 (program -> statement .)
    ASYNC           reduce using rule 2 (program -> statement .)
    FOR             reduce using rule 2 (program -> statement .)
    RETURN          reduce using rule 2 (program -> statement .)
    CLOSURE_PIPE    reduce using rule 2 (program -> statement .)
    LPAREN          reduce using rule 2 (program -> statement .)
    NOT             reduce using rule 2 (program -> statement .)
    INTEGER         reduce using rule 2 (program -> statement .)
    FLOAT           reduce using rule 2 (program -> statement .)
    STRING          reduce using rule 2 (program -> statement .)
    CHAR            reduce using rule 2 (program -> statement .)
    BOOLEAN         reduce using rule 2 (program -> statement .)
    BIT_AND         reduce using rule 2 (program -> statement .)
    LBRACKET        reduce using rule 2 (program -> statement .)
    LET             reduce using rule 2 (program -> statement .)
    CONST           reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)
    FN              reduce using rule 2 (program -> statement .)
    RBRACE          reduce using rule 2 (program -> statement .)


state 3

    (6) statement -> PRINTLN . NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN . NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> PRINTLN . NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON

    NOT             shift and go to state 28


state 4

    (36) expression -> NOT . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 29

state 5

    (30) expression -> LPAREN . expression RPAREN
    (92) expression -> LPAREN . tuple_value_list RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (93) tuple_value_list -> . expression
    (94) tuple_value_list -> . expression COMMA tuple_value_list

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 31
    tuple_value_list               shift and go to state 32

state 6

    (39) expression -> STRING .

    SEMICOLON       reduce using rule 39 (expression -> STRING .)
    DOT             reduce using rule 39 (expression -> STRING .)
    PLUS            reduce using rule 39 (expression -> STRING .)
    MINUS           reduce using rule 39 (expression -> STRING .)
    TIMES           reduce using rule 39 (expression -> STRING .)
    DIVIDE          reduce using rule 39 (expression -> STRING .)
    MOD             reduce using rule 39 (expression -> STRING .)
    AS              reduce using rule 39 (expression -> STRING .)
    RPAREN          reduce using rule 39 (expression -> STRING .)
    COMMA           reduce using rule 39 (expression -> STRING .)
    EQUAL_TO        reduce using rule 39 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 39 (expression -> STRING .)
    LESS_THAN       reduce using rule 39 (expression -> STRING .)
    GREATER_THAN    reduce using rule 39 (expression -> STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> STRING .)
    RBRACKET        reduce using rule 39 (expression -> STRING .)
    LBRACE          reduce using rule 39 (expression -> STRING .)
    CONJUNCTION     reduce using rule 39 (expression -> STRING .)
    DISJUNCTION     reduce using rule 39 (expression -> STRING .)
    RBRACE          reduce using rule 39 (expression -> STRING .)


state 7

    (12) statement -> expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 33
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 8

    (56) statement -> IF . condition LBRACE program_opt RBRACE
    (46) condition -> . expression EQUAL_TO expression
    (47) condition -> . expression NOT_EQUAL expression
    (48) condition -> . expression LESS_THAN expression
    (49) condition -> . expression GREATER_THAN expression
    (50) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (52) condition -> . condition CONJUNCTION condition
    (53) condition -> . condition DISJUNCTION condition
    (54) condition -> . NOT condition
    (55) condition -> . LPAREN condition RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 43
    LPAREN          shift and go to state 44
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    condition                      shift and go to state 41
    expression                     shift and go to state 42

state 9

    (57) statement -> IDENTIFIER . ASIGNED_TO expression SEMICOLON
    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (42) expression -> IDENTIFIER .
    (83) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (84) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (104) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN
    (97) maybe_pub -> IDENTIFIER .

    ASIGNED_TO      shift and go to state 45
    DOUBLE_COLON    shift and go to state 46
    SEMICOLON       reduce using rule 42 (expression -> IDENTIFIER .)
    DOT             reduce using rule 42 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 42 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 42 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 42 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 42 (expression -> IDENTIFIER .)
    MOD             reduce using rule 42 (expression -> IDENTIFIER .)
    AS              reduce using rule 42 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 48
    NOT             shift and go to state 49
    LPAREN          shift and go to state 47
    FN              reduce using rule 97 (maybe_pub -> IDENTIFIER .)


state 10

    (58) statement -> WHILE . condition LBRACE program_opt RBRACE
    (46) condition -> . expression EQUAL_TO expression
    (47) condition -> . expression NOT_EQUAL expression
    (48) condition -> . expression LESS_THAN expression
    (49) condition -> . expression GREATER_THAN expression
    (50) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (52) condition -> . condition CONJUNCTION condition
    (53) condition -> . condition DISJUNCTION condition
    (54) condition -> . NOT condition
    (55) condition -> . LPAREN condition RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 43
    LPAREN          shift and go to state 44
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    condition                      shift and go to state 50
    expression                     shift and go to state 42

state 11

    (59) statement -> ASYNC . FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> ASYNC . FN function_name LPAREN RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 51


state 12

    (71) statement -> let_decl .

    PRINTLN         reduce using rule 71 (statement -> let_decl .)
    IF              reduce using rule 71 (statement -> let_decl .)
    IDENTIFIER      reduce using rule 71 (statement -> let_decl .)
    WHILE           reduce using rule 71 (statement -> let_decl .)
    ASYNC           reduce using rule 71 (statement -> let_decl .)
    FOR             reduce using rule 71 (statement -> let_decl .)
    RETURN          reduce using rule 71 (statement -> let_decl .)
    CLOSURE_PIPE    reduce using rule 71 (statement -> let_decl .)
    LPAREN          reduce using rule 71 (statement -> let_decl .)
    NOT             reduce using rule 71 (statement -> let_decl .)
    INTEGER         reduce using rule 71 (statement -> let_decl .)
    FLOAT           reduce using rule 71 (statement -> let_decl .)
    STRING          reduce using rule 71 (statement -> let_decl .)
    CHAR            reduce using rule 71 (statement -> let_decl .)
    BOOLEAN         reduce using rule 71 (statement -> let_decl .)
    BIT_AND         reduce using rule 71 (statement -> let_decl .)
    LBRACKET        reduce using rule 71 (statement -> let_decl .)
    LET             reduce using rule 71 (statement -> let_decl .)
    CONST           reduce using rule 71 (statement -> let_decl .)
    $end            reduce using rule 71 (statement -> let_decl .)
    FN              reduce using rule 71 (statement -> let_decl .)
    RBRACE          reduce using rule 71 (statement -> let_decl .)


state 13

    (87) statement -> const_decl .

    PRINTLN         reduce using rule 87 (statement -> const_decl .)
    IF              reduce using rule 87 (statement -> const_decl .)
    IDENTIFIER      reduce using rule 87 (statement -> const_decl .)
    WHILE           reduce using rule 87 (statement -> const_decl .)
    ASYNC           reduce using rule 87 (statement -> const_decl .)
    FOR             reduce using rule 87 (statement -> const_decl .)
    RETURN          reduce using rule 87 (statement -> const_decl .)
    CLOSURE_PIPE    reduce using rule 87 (statement -> const_decl .)
    LPAREN          reduce using rule 87 (statement -> const_decl .)
    NOT             reduce using rule 87 (statement -> const_decl .)
    INTEGER         reduce using rule 87 (statement -> const_decl .)
    FLOAT           reduce using rule 87 (statement -> const_decl .)
    STRING          reduce using rule 87 (statement -> const_decl .)
    CHAR            reduce using rule 87 (statement -> const_decl .)
    BOOLEAN         reduce using rule 87 (statement -> const_decl .)
    BIT_AND         reduce using rule 87 (statement -> const_decl .)
    LBRACKET        reduce using rule 87 (statement -> const_decl .)
    LET             reduce using rule 87 (statement -> const_decl .)
    CONST           reduce using rule 87 (statement -> const_decl .)
    $end            reduce using rule 87 (statement -> const_decl .)
    FN              reduce using rule 87 (statement -> const_decl .)
    RBRACE          reduce using rule 87 (statement -> const_decl .)


state 14

    (96) statement -> FOR . IDENTIFIER IN expression LBRACE program_opt RBRACE

    IDENTIFIER      shift and go to state 52


state 15

    (101) statement -> maybe_pub . FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> maybe_pub . FN function_name LPAREN RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 53


state 16

    (103) statement -> RETURN . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 54

state 17

    (28) expression -> CLOSURE_PIPE . closure_params CLOSURE_PIPE closure_body
    (29) expression -> CLOSURE_PIPE . closure_params CLOSURE_PIPE ARROW type closure_body
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 56

    closure_params                 shift and go to state 55

state 18

    (37) expression -> INTEGER .

    SEMICOLON       reduce using rule 37 (expression -> INTEGER .)
    DOT             reduce using rule 37 (expression -> INTEGER .)
    PLUS            reduce using rule 37 (expression -> INTEGER .)
    MINUS           reduce using rule 37 (expression -> INTEGER .)
    TIMES           reduce using rule 37 (expression -> INTEGER .)
    DIVIDE          reduce using rule 37 (expression -> INTEGER .)
    MOD             reduce using rule 37 (expression -> INTEGER .)
    AS              reduce using rule 37 (expression -> INTEGER .)
    RPAREN          reduce using rule 37 (expression -> INTEGER .)
    COMMA           reduce using rule 37 (expression -> INTEGER .)
    EQUAL_TO        reduce using rule 37 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 37 (expression -> INTEGER .)
    LESS_THAN       reduce using rule 37 (expression -> INTEGER .)
    GREATER_THAN    reduce using rule 37 (expression -> INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 37 (expression -> INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 37 (expression -> INTEGER .)
    RBRACKET        reduce using rule 37 (expression -> INTEGER .)
    LBRACE          reduce using rule 37 (expression -> INTEGER .)
    CONJUNCTION     reduce using rule 37 (expression -> INTEGER .)
    DISJUNCTION     reduce using rule 37 (expression -> INTEGER .)
    RBRACE          reduce using rule 37 (expression -> INTEGER .)


state 19

    (38) expression -> FLOAT .

    SEMICOLON       reduce using rule 38 (expression -> FLOAT .)
    DOT             reduce using rule 38 (expression -> FLOAT .)
    PLUS            reduce using rule 38 (expression -> FLOAT .)
    MINUS           reduce using rule 38 (expression -> FLOAT .)
    TIMES           reduce using rule 38 (expression -> FLOAT .)
    DIVIDE          reduce using rule 38 (expression -> FLOAT .)
    MOD             reduce using rule 38 (expression -> FLOAT .)
    AS              reduce using rule 38 (expression -> FLOAT .)
    RPAREN          reduce using rule 38 (expression -> FLOAT .)
    COMMA           reduce using rule 38 (expression -> FLOAT .)
    EQUAL_TO        reduce using rule 38 (expression -> FLOAT .)
    NOT_EQUAL       reduce using rule 38 (expression -> FLOAT .)
    LESS_THAN       reduce using rule 38 (expression -> FLOAT .)
    GREATER_THAN    reduce using rule 38 (expression -> FLOAT .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> FLOAT .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> FLOAT .)
    RBRACKET        reduce using rule 38 (expression -> FLOAT .)
    LBRACE          reduce using rule 38 (expression -> FLOAT .)
    CONJUNCTION     reduce using rule 38 (expression -> FLOAT .)
    DISJUNCTION     reduce using rule 38 (expression -> FLOAT .)
    RBRACE          reduce using rule 38 (expression -> FLOAT .)


state 20

    (40) expression -> CHAR .

    SEMICOLON       reduce using rule 40 (expression -> CHAR .)
    DOT             reduce using rule 40 (expression -> CHAR .)
    PLUS            reduce using rule 40 (expression -> CHAR .)
    MINUS           reduce using rule 40 (expression -> CHAR .)
    TIMES           reduce using rule 40 (expression -> CHAR .)
    DIVIDE          reduce using rule 40 (expression -> CHAR .)
    MOD             reduce using rule 40 (expression -> CHAR .)
    AS              reduce using rule 40 (expression -> CHAR .)
    RPAREN          reduce using rule 40 (expression -> CHAR .)
    COMMA           reduce using rule 40 (expression -> CHAR .)
    EQUAL_TO        reduce using rule 40 (expression -> CHAR .)
    NOT_EQUAL       reduce using rule 40 (expression -> CHAR .)
    LESS_THAN       reduce using rule 40 (expression -> CHAR .)
    GREATER_THAN    reduce using rule 40 (expression -> CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> CHAR .)
    RBRACKET        reduce using rule 40 (expression -> CHAR .)
    LBRACE          reduce using rule 40 (expression -> CHAR .)
    CONJUNCTION     reduce using rule 40 (expression -> CHAR .)
    DISJUNCTION     reduce using rule 40 (expression -> CHAR .)
    RBRACE          reduce using rule 40 (expression -> CHAR .)


state 21

    (41) expression -> BOOLEAN .

    SEMICOLON       reduce using rule 41 (expression -> BOOLEAN .)
    DOT             reduce using rule 41 (expression -> BOOLEAN .)
    PLUS            reduce using rule 41 (expression -> BOOLEAN .)
    MINUS           reduce using rule 41 (expression -> BOOLEAN .)
    TIMES           reduce using rule 41 (expression -> BOOLEAN .)
    DIVIDE          reduce using rule 41 (expression -> BOOLEAN .)
    MOD             reduce using rule 41 (expression -> BOOLEAN .)
    AS              reduce using rule 41 (expression -> BOOLEAN .)
    RPAREN          reduce using rule 41 (expression -> BOOLEAN .)
    COMMA           reduce using rule 41 (expression -> BOOLEAN .)
    EQUAL_TO        reduce using rule 41 (expression -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 41 (expression -> BOOLEAN .)
    LESS_THAN       reduce using rule 41 (expression -> BOOLEAN .)
    GREATER_THAN    reduce using rule 41 (expression -> BOOLEAN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> BOOLEAN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> BOOLEAN .)
    RBRACKET        reduce using rule 41 (expression -> BOOLEAN .)
    LBRACE          reduce using rule 41 (expression -> BOOLEAN .)
    CONJUNCTION     reduce using rule 41 (expression -> BOOLEAN .)
    DISJUNCTION     reduce using rule 41 (expression -> BOOLEAN .)
    RBRACE          reduce using rule 41 (expression -> BOOLEAN .)


state 22

    (43) expression -> BIT_AND . expression
    (44) expression -> BIT_AND . MUT IDENTIFIER
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    MUT             shift and go to state 58
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 57

state 23

    (81) expression -> LBRACKET . element_list RBRACKET
    (82) expression -> LBRACKET . expression SEMICOLON INTEGER RBRACKET
    (79) element_list -> . element_list COMMA expression
    (80) element_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    element_list                   shift and go to state 59
    expression                     shift and go to state 60

state 24

    (72) let_decl -> LET . maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (73) maybe_mut -> . MUT
    (74) maybe_mut -> . empty
    (5) empty -> .

    MUT             shift and go to state 62
    IDENTIFIER      reduce using rule 5 (empty -> .)

    maybe_mut                      shift and go to state 61
    empty                          shift and go to state 63

state 25

    (88) const_decl -> CONST . IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON

    IDENTIFIER      shift and go to state 64


state 26

    (98) maybe_pub -> empty .

    FN              reduce using rule 98 (maybe_pub -> empty .)


state 27

    (1) program -> program statement .

    PRINTLN         reduce using rule 1 (program -> program statement .)
    IF              reduce using rule 1 (program -> program statement .)
    IDENTIFIER      reduce using rule 1 (program -> program statement .)
    WHILE           reduce using rule 1 (program -> program statement .)
    ASYNC           reduce using rule 1 (program -> program statement .)
    FOR             reduce using rule 1 (program -> program statement .)
    RETURN          reduce using rule 1 (program -> program statement .)
    CLOSURE_PIPE    reduce using rule 1 (program -> program statement .)
    LPAREN          reduce using rule 1 (program -> program statement .)
    NOT             reduce using rule 1 (program -> program statement .)
    INTEGER         reduce using rule 1 (program -> program statement .)
    FLOAT           reduce using rule 1 (program -> program statement .)
    STRING          reduce using rule 1 (program -> program statement .)
    CHAR            reduce using rule 1 (program -> program statement .)
    BOOLEAN         reduce using rule 1 (program -> program statement .)
    BIT_AND         reduce using rule 1 (program -> program statement .)
    LBRACKET        reduce using rule 1 (program -> program statement .)
    LET             reduce using rule 1 (program -> program statement .)
    CONST           reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)
    FN              reduce using rule 1 (program -> program statement .)
    RBRACE          reduce using rule 1 (program -> program statement .)


state 28

    (6) statement -> PRINTLN NOT . LPAREN STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN NOT . LPAREN expression RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT . LPAREN STRING COMMA argument_list RPAREN SEMICOLON

    LPAREN          shift and go to state 65


state 29

    (36) expression -> NOT expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 36 (expression -> NOT expression .)
    DOT             reduce using rule 36 (expression -> NOT expression .)
    RPAREN          reduce using rule 36 (expression -> NOT expression .)
    COMMA           reduce using rule 36 (expression -> NOT expression .)
    EQUAL_TO        reduce using rule 36 (expression -> NOT expression .)
    NOT_EQUAL       reduce using rule 36 (expression -> NOT expression .)
    LESS_THAN       reduce using rule 36 (expression -> NOT expression .)
    GREATER_THAN    reduce using rule 36 (expression -> NOT expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 36 (expression -> NOT expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 36 (expression -> NOT expression .)
    RBRACKET        reduce using rule 36 (expression -> NOT expression .)
    LBRACE          reduce using rule 36 (expression -> NOT expression .)
    CONJUNCTION     reduce using rule 36 (expression -> NOT expression .)
    DISJUNCTION     reduce using rule 36 (expression -> NOT expression .)
    RBRACE          reduce using rule 36 (expression -> NOT expression .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! PLUS            [ reduce using rule 36 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 36 (expression -> NOT expression .) ]
  ! AS              [ reduce using rule 36 (expression -> NOT expression .) ]
  ! DOT             [ shift and go to state 34 ]


state 30

    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (42) expression -> IDENTIFIER .
    (83) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (84) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (104) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN

    DOUBLE_COLON    shift and go to state 46
    DOT             reduce using rule 42 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 42 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 42 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 42 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 42 (expression -> IDENTIFIER .)
    MOD             reduce using rule 42 (expression -> IDENTIFIER .)
    AS              reduce using rule 42 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 42 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 42 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 42 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 42 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 42 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 42 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 42 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 42 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 42 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 42 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 42 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 42 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 48
    NOT             shift and go to state 49
    LPAREN          shift and go to state 47


state 31

    (30) expression -> LPAREN expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER
    (93) tuple_value_list -> expression .
    (94) tuple_value_list -> expression . COMMA tuple_value_list

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 66
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40
    COMMA           shift and go to state 67

  ! RPAREN          [ reduce using rule 93 (tuple_value_list -> expression .) ]


state 32

    (92) expression -> LPAREN tuple_value_list . RPAREN

    RPAREN          shift and go to state 68


state 33

    (12) statement -> expression SEMICOLON .

    PRINTLN         reduce using rule 12 (statement -> expression SEMICOLON .)
    IF              reduce using rule 12 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 12 (statement -> expression SEMICOLON .)
    ASYNC           reduce using rule 12 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 12 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 12 (statement -> expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 12 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 12 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 12 (statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 12 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 12 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 12 (statement -> expression SEMICOLON .)
    CHAR            reduce using rule 12 (statement -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 12 (statement -> expression SEMICOLON .)
    BIT_AND         reduce using rule 12 (statement -> expression SEMICOLON .)
    LBRACKET        reduce using rule 12 (statement -> expression SEMICOLON .)
    LET             reduce using rule 12 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 12 (statement -> expression SEMICOLON .)
    $end            reduce using rule 12 (statement -> expression SEMICOLON .)
    FN              reduce using rule 12 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 12 (statement -> expression SEMICOLON .)


state 34

    (9) expression -> expression DOT . IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression DOT . IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression DOT . IDENTIFIER LPAREN arguments_opt RPAREN
    (95) expression -> expression DOT . INTEGER

    IDENTIFIER      shift and go to state 69
    INTEGER         shift and go to state 70


state 35

    (31) expression -> expression PLUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 71

state 36

    (32) expression -> expression MINUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 72

state 37

    (33) expression -> expression TIMES . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 73

state 38

    (34) expression -> expression DIVIDE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 74

state 39

    (35) expression -> expression MOD . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 75

state 40

    (45) expression -> expression AS . type
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 76

state 41

    (56) statement -> IF condition . LBRACE program_opt RBRACE
    (52) condition -> condition . CONJUNCTION condition
    (53) condition -> condition . DISJUNCTION condition

    LBRACE          shift and go to state 87
    CONJUNCTION     shift and go to state 88
    DISJUNCTION     shift and go to state 89


state 42

    (46) condition -> expression . EQUAL_TO expression
    (47) condition -> expression . NOT_EQUAL expression
    (48) condition -> expression . LESS_THAN expression
    (49) condition -> expression . GREATER_THAN expression
    (50) condition -> expression . LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    EQUAL_TO        shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS_THAN       shift and go to state 92
    GREATER_THAN    shift and go to state 93
    LESS_THAN_OR_EQUAL_TO shift and go to state 94
    GREATER_THAN_OR_EQUAL_TO shift and go to state 95
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 43

    (54) condition -> NOT . condition
    (36) expression -> NOT . expression
    (46) condition -> . expression EQUAL_TO expression
    (47) condition -> . expression NOT_EQUAL expression
    (48) condition -> . expression LESS_THAN expression
    (49) condition -> . expression GREATER_THAN expression
    (50) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (52) condition -> . condition CONJUNCTION condition
    (53) condition -> . condition DISJUNCTION condition
    (54) condition -> . NOT condition
    (55) condition -> . LPAREN condition RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 43
    LPAREN          shift and go to state 44
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    condition                      shift and go to state 96
    expression                     shift and go to state 97

state 44

    (55) condition -> LPAREN . condition RPAREN
    (30) expression -> LPAREN . expression RPAREN
    (92) expression -> LPAREN . tuple_value_list RPAREN
    (46) condition -> . expression EQUAL_TO expression
    (47) condition -> . expression NOT_EQUAL expression
    (48) condition -> . expression LESS_THAN expression
    (49) condition -> . expression GREATER_THAN expression
    (50) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (52) condition -> . condition CONJUNCTION condition
    (53) condition -> . condition DISJUNCTION condition
    (54) condition -> . NOT condition
    (55) condition -> . LPAREN condition RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (93) tuple_value_list -> . expression
    (94) tuple_value_list -> . expression COMMA tuple_value_list

    NOT             shift and go to state 43
    LPAREN          shift and go to state 44
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    condition                      shift and go to state 98
    expression                     shift and go to state 99
    tuple_value_list               shift and go to state 32

state 45

    (57) statement -> IDENTIFIER ASIGNED_TO . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 100

state 46

    (11) expression -> IDENTIFIER DOUBLE_COLON . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 101


state 47

    (104) expression -> IDENTIFIER LPAREN . arguments_opt RPAREN
    (14) arguments_opt -> . argument_list
    (15) arguments_opt -> . empty
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (5) empty -> .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    arguments_opt                  shift and go to state 102
    argument_list                  shift and go to state 103
    empty                          shift and go to state 104
    expression                     shift and go to state 105

state 48

    (83) expression -> IDENTIFIER LBRACKET . expression RBRACKET
    (84) expression -> IDENTIFIER LBRACKET . INTEGER RANGE INTEGER RBRACKET
    (85) expression -> IDENTIFIER LBRACKET . INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    INTEGER         shift and go to state 107
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 106

state 49

    (86) expression -> IDENTIFIER NOT . LBRACKET element_list RBRACKET

    LBRACKET        shift and go to state 108


state 50

    (58) statement -> WHILE condition . LBRACE program_opt RBRACE
    (52) condition -> condition . CONJUNCTION condition
    (53) condition -> condition . DISJUNCTION condition

    LBRACE          shift and go to state 109
    CONJUNCTION     shift and go to state 88
    DISJUNCTION     shift and go to state 89


state 51

    (59) statement -> ASYNC FN . function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> ASYNC FN . function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (99) function_name -> . IDENTIFIER
    (100) function_name -> . MAIN

    IDENTIFIER      shift and go to state 111
    MAIN            shift and go to state 112

    function_name                  shift and go to state 110

state 52

    (96) statement -> FOR IDENTIFIER . IN expression LBRACE program_opt RBRACE

    IN              shift and go to state 113


state 53

    (101) statement -> maybe_pub FN . function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> maybe_pub FN . function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (99) function_name -> . IDENTIFIER
    (100) function_name -> . MAIN

    IDENTIFIER      shift and go to state 111
    MAIN            shift and go to state 112

    function_name                  shift and go to state 114

state 54

    (103) statement -> RETURN expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 115
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 55

    (28) expression -> CLOSURE_PIPE closure_params . CLOSURE_PIPE closure_body
    (29) expression -> CLOSURE_PIPE closure_params . CLOSURE_PIPE ARROW type closure_body

    CLOSURE_PIPE    shift and go to state 116


state 56

    (19) closure_params -> IDENTIFIER .
    (20) closure_params -> IDENTIFIER . COLON type
    (21) closure_params -> IDENTIFIER . COMMA closure_params
    (22) closure_params -> IDENTIFIER . COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 19 (closure_params -> IDENTIFIER .)
    COLON           shift and go to state 117
    COMMA           shift and go to state 118


state 57

    (43) expression -> BIT_AND expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    SEMICOLON       reduce using rule 43 (expression -> BIT_AND expression .)
    RPAREN          reduce using rule 43 (expression -> BIT_AND expression .)
    COMMA           reduce using rule 43 (expression -> BIT_AND expression .)
    EQUAL_TO        reduce using rule 43 (expression -> BIT_AND expression .)
    NOT_EQUAL       reduce using rule 43 (expression -> BIT_AND expression .)
    LESS_THAN       reduce using rule 43 (expression -> BIT_AND expression .)
    GREATER_THAN    reduce using rule 43 (expression -> BIT_AND expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> BIT_AND expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> BIT_AND expression .)
    RBRACKET        reduce using rule 43 (expression -> BIT_AND expression .)
    LBRACE          reduce using rule 43 (expression -> BIT_AND expression .)
    CONJUNCTION     reduce using rule 43 (expression -> BIT_AND expression .)
    DISJUNCTION     reduce using rule 43 (expression -> BIT_AND expression .)
    RBRACE          reduce using rule 43 (expression -> BIT_AND expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! DOT             [ reduce using rule 43 (expression -> BIT_AND expression .) ]
  ! PLUS            [ reduce using rule 43 (expression -> BIT_AND expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> BIT_AND expression .) ]
  ! TIMES           [ reduce using rule 43 (expression -> BIT_AND expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> BIT_AND expression .) ]
  ! MOD             [ reduce using rule 43 (expression -> BIT_AND expression .) ]
  ! AS              [ reduce using rule 43 (expression -> BIT_AND expression .) ]


state 58

    (44) expression -> BIT_AND MUT . IDENTIFIER

    IDENTIFIER      shift and go to state 119


state 59

    (81) expression -> LBRACKET element_list . RBRACKET
    (79) element_list -> element_list . COMMA expression

    RBRACKET        shift and go to state 120
    COMMA           shift and go to state 121


state 60

    (82) expression -> LBRACKET expression . SEMICOLON INTEGER RBRACKET
    (80) element_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 122
    RBRACKET        reduce using rule 80 (element_list -> expression .)
    COMMA           reduce using rule 80 (element_list -> expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 61

    (72) let_decl -> LET maybe_mut . IDENTIFIER maybe_type maybe_init SEMICOLON

    IDENTIFIER      shift and go to state 123


state 62

    (73) maybe_mut -> MUT .

    IDENTIFIER      reduce using rule 73 (maybe_mut -> MUT .)


state 63

    (74) maybe_mut -> empty .

    IDENTIFIER      reduce using rule 74 (maybe_mut -> empty .)


state 64

    (88) const_decl -> CONST IDENTIFIER . COLON type ASIGNED_TO expression SEMICOLON

    COLON           shift and go to state 124


state 65

    (6) statement -> PRINTLN NOT LPAREN . STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN NOT LPAREN . expression RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT LPAREN . STRING COMMA argument_list RPAREN SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    STRING          shift and go to state 125
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 126

state 66

    (30) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    AS              reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    EQUAL_TO        reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    CONJUNCTION     reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DISJUNCTION     reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)


state 67

    (94) tuple_value_list -> expression COMMA . tuple_value_list
    (93) tuple_value_list -> . expression
    (94) tuple_value_list -> . expression COMMA tuple_value_list
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 127
    tuple_value_list               shift and go to state 128

state 68

    (92) expression -> LPAREN tuple_value_list RPAREN .

    SEMICOLON       reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    DOT             reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    PLUS            reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    MINUS           reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    TIMES           reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    DIVIDE          reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    MOD             reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    AS              reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    RPAREN          reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    COMMA           reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    EQUAL_TO        reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    NOT_EQUAL       reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    LESS_THAN       reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    GREATER_THAN    reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    RBRACKET        reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    LBRACE          reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    CONJUNCTION     reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    DISJUNCTION     reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)
    RBRACE          reduce using rule 92 (expression -> LPAREN tuple_value_list RPAREN .)


state 69

    (9) expression -> expression DOT IDENTIFIER . LPAREN expression COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER . LPAREN expression RPAREN
    (13) expression -> expression DOT IDENTIFIER . LPAREN arguments_opt RPAREN

    LPAREN          shift and go to state 129


state 70

    (95) expression -> expression DOT INTEGER .

    SEMICOLON       reduce using rule 95 (expression -> expression DOT INTEGER .)
    DOT             reduce using rule 95 (expression -> expression DOT INTEGER .)
    PLUS            reduce using rule 95 (expression -> expression DOT INTEGER .)
    MINUS           reduce using rule 95 (expression -> expression DOT INTEGER .)
    TIMES           reduce using rule 95 (expression -> expression DOT INTEGER .)
    DIVIDE          reduce using rule 95 (expression -> expression DOT INTEGER .)
    MOD             reduce using rule 95 (expression -> expression DOT INTEGER .)
    AS              reduce using rule 95 (expression -> expression DOT INTEGER .)
    RPAREN          reduce using rule 95 (expression -> expression DOT INTEGER .)
    COMMA           reduce using rule 95 (expression -> expression DOT INTEGER .)
    EQUAL_TO        reduce using rule 95 (expression -> expression DOT INTEGER .)
    NOT_EQUAL       reduce using rule 95 (expression -> expression DOT INTEGER .)
    LESS_THAN       reduce using rule 95 (expression -> expression DOT INTEGER .)
    GREATER_THAN    reduce using rule 95 (expression -> expression DOT INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 95 (expression -> expression DOT INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 95 (expression -> expression DOT INTEGER .)
    RBRACKET        reduce using rule 95 (expression -> expression DOT INTEGER .)
    LBRACE          reduce using rule 95 (expression -> expression DOT INTEGER .)
    CONJUNCTION     reduce using rule 95 (expression -> expression DOT INTEGER .)
    DISJUNCTION     reduce using rule 95 (expression -> expression DOT INTEGER .)
    RBRACE          reduce using rule 95 (expression -> expression DOT INTEGER .)


state 71

    (31) expression -> expression PLUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 31 (expression -> expression PLUS expression .)
    DOT             reduce using rule 31 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 31 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 31 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 31 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 31 (expression -> expression PLUS expression .)
    EQUAL_TO        reduce using rule 31 (expression -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 31 (expression -> expression PLUS expression .)
    LESS_THAN       reduce using rule 31 (expression -> expression PLUS expression .)
    GREATER_THAN    reduce using rule 31 (expression -> expression PLUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 31 (expression -> expression PLUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 31 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 31 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 31 (expression -> expression PLUS expression .)
    CONJUNCTION     reduce using rule 31 (expression -> expression PLUS expression .)
    DISJUNCTION     reduce using rule 31 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 31 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! TIMES           [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! AS              [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DOT             [ shift and go to state 34 ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 36 ]


state 72

    (32) expression -> expression MINUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 32 (expression -> expression MINUS expression .)
    DOT             reduce using rule 32 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 32 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 32 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 32 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 32 (expression -> expression MINUS expression .)
    EQUAL_TO        reduce using rule 32 (expression -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 32 (expression -> expression MINUS expression .)
    LESS_THAN       reduce using rule 32 (expression -> expression MINUS expression .)
    GREATER_THAN    reduce using rule 32 (expression -> expression MINUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 32 (expression -> expression MINUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 32 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 32 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 32 (expression -> expression MINUS expression .)
    CONJUNCTION     reduce using rule 32 (expression -> expression MINUS expression .)
    DISJUNCTION     reduce using rule 32 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 32 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! TIMES           [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! AS              [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DOT             [ shift and go to state 34 ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 36 ]


state 73

    (33) expression -> expression TIMES expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 33 (expression -> expression TIMES expression .)
    DOT             reduce using rule 33 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 33 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 33 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 33 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 33 (expression -> expression TIMES expression .)
    MOD             reduce using rule 33 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 33 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 33 (expression -> expression TIMES expression .)
    EQUAL_TO        reduce using rule 33 (expression -> expression TIMES expression .)
    NOT_EQUAL       reduce using rule 33 (expression -> expression TIMES expression .)
    LESS_THAN       reduce using rule 33 (expression -> expression TIMES expression .)
    GREATER_THAN    reduce using rule 33 (expression -> expression TIMES expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 33 (expression -> expression TIMES expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 33 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 33 (expression -> expression TIMES expression .)
    LBRACE          reduce using rule 33 (expression -> expression TIMES expression .)
    CONJUNCTION     reduce using rule 33 (expression -> expression TIMES expression .)
    DISJUNCTION     reduce using rule 33 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 33 (expression -> expression TIMES expression .)
    AS              shift and go to state 40

  ! AS              [ reduce using rule 33 (expression -> expression TIMES expression .) ]
  ! DOT             [ shift and go to state 34 ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 36 ]
  ! TIMES           [ shift and go to state 37 ]
  ! DIVIDE          [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]


state 74

    (34) expression -> expression DIVIDE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 34 (expression -> expression DIVIDE expression .)
    DOT             reduce using rule 34 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 34 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 34 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 34 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    MOD             reduce using rule 34 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 34 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 34 (expression -> expression DIVIDE expression .)
    EQUAL_TO        reduce using rule 34 (expression -> expression DIVIDE expression .)
    NOT_EQUAL       reduce using rule 34 (expression -> expression DIVIDE expression .)
    LESS_THAN       reduce using rule 34 (expression -> expression DIVIDE expression .)
    GREATER_THAN    reduce using rule 34 (expression -> expression DIVIDE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 34 (expression -> expression DIVIDE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 34 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 34 (expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    CONJUNCTION     reduce using rule 34 (expression -> expression DIVIDE expression .)
    DISJUNCTION     reduce using rule 34 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    AS              shift and go to state 40

  ! AS              [ reduce using rule 34 (expression -> expression DIVIDE expression .) ]
  ! DOT             [ shift and go to state 34 ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 36 ]
  ! TIMES           [ shift and go to state 37 ]
  ! DIVIDE          [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]


state 75

    (35) expression -> expression MOD expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 35 (expression -> expression MOD expression .)
    DOT             reduce using rule 35 (expression -> expression MOD expression .)
    PLUS            reduce using rule 35 (expression -> expression MOD expression .)
    MINUS           reduce using rule 35 (expression -> expression MOD expression .)
    TIMES           reduce using rule 35 (expression -> expression MOD expression .)
    DIVIDE          reduce using rule 35 (expression -> expression MOD expression .)
    MOD             reduce using rule 35 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 35 (expression -> expression MOD expression .)
    COMMA           reduce using rule 35 (expression -> expression MOD expression .)
    EQUAL_TO        reduce using rule 35 (expression -> expression MOD expression .)
    NOT_EQUAL       reduce using rule 35 (expression -> expression MOD expression .)
    LESS_THAN       reduce using rule 35 (expression -> expression MOD expression .)
    GREATER_THAN    reduce using rule 35 (expression -> expression MOD expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 35 (expression -> expression MOD expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 35 (expression -> expression MOD expression .)
    RBRACKET        reduce using rule 35 (expression -> expression MOD expression .)
    LBRACE          reduce using rule 35 (expression -> expression MOD expression .)
    CONJUNCTION     reduce using rule 35 (expression -> expression MOD expression .)
    DISJUNCTION     reduce using rule 35 (expression -> expression MOD expression .)
    RBRACE          reduce using rule 35 (expression -> expression MOD expression .)
    AS              shift and go to state 40

  ! AS              [ reduce using rule 35 (expression -> expression MOD expression .) ]
  ! DOT             [ shift and go to state 34 ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 36 ]
  ! TIMES           [ shift and go to state 37 ]
  ! DIVIDE          [ shift and go to state 38 ]
  ! MOD             [ shift and go to state 39 ]


state 76

    (45) expression -> expression AS type .

    SEMICOLON       reduce using rule 45 (expression -> expression AS type .)
    DOT             reduce using rule 45 (expression -> expression AS type .)
    PLUS            reduce using rule 45 (expression -> expression AS type .)
    MINUS           reduce using rule 45 (expression -> expression AS type .)
    TIMES           reduce using rule 45 (expression -> expression AS type .)
    DIVIDE          reduce using rule 45 (expression -> expression AS type .)
    MOD             reduce using rule 45 (expression -> expression AS type .)
    AS              reduce using rule 45 (expression -> expression AS type .)
    RPAREN          reduce using rule 45 (expression -> expression AS type .)
    COMMA           reduce using rule 45 (expression -> expression AS type .)
    EQUAL_TO        reduce using rule 45 (expression -> expression AS type .)
    NOT_EQUAL       reduce using rule 45 (expression -> expression AS type .)
    LESS_THAN       reduce using rule 45 (expression -> expression AS type .)
    GREATER_THAN    reduce using rule 45 (expression -> expression AS type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 45 (expression -> expression AS type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 45 (expression -> expression AS type .)
    RBRACKET        reduce using rule 45 (expression -> expression AS type .)
    LBRACE          reduce using rule 45 (expression -> expression AS type .)
    CONJUNCTION     reduce using rule 45 (expression -> expression AS type .)
    DISJUNCTION     reduce using rule 45 (expression -> expression AS type .)
    RBRACE          reduce using rule 45 (expression -> expression AS type .)


state 77

    (61) type -> TYPE_I32 .

    SEMICOLON       reduce using rule 61 (type -> TYPE_I32 .)
    DOT             reduce using rule 61 (type -> TYPE_I32 .)
    PLUS            reduce using rule 61 (type -> TYPE_I32 .)
    MINUS           reduce using rule 61 (type -> TYPE_I32 .)
    TIMES           reduce using rule 61 (type -> TYPE_I32 .)
    DIVIDE          reduce using rule 61 (type -> TYPE_I32 .)
    MOD             reduce using rule 61 (type -> TYPE_I32 .)
    AS              reduce using rule 61 (type -> TYPE_I32 .)
    RPAREN          reduce using rule 61 (type -> TYPE_I32 .)
    COMMA           reduce using rule 61 (type -> TYPE_I32 .)
    EQUAL_TO        reduce using rule 61 (type -> TYPE_I32 .)
    NOT_EQUAL       reduce using rule 61 (type -> TYPE_I32 .)
    LESS_THAN       reduce using rule 61 (type -> TYPE_I32 .)
    GREATER_THAN    reduce using rule 61 (type -> TYPE_I32 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 61 (type -> TYPE_I32 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 61 (type -> TYPE_I32 .)
    RBRACKET        reduce using rule 61 (type -> TYPE_I32 .)
    LBRACE          reduce using rule 61 (type -> TYPE_I32 .)
    CONJUNCTION     reduce using rule 61 (type -> TYPE_I32 .)
    DISJUNCTION     reduce using rule 61 (type -> TYPE_I32 .)
    RBRACE          reduce using rule 61 (type -> TYPE_I32 .)
    CLOSURE_PIPE    reduce using rule 61 (type -> TYPE_I32 .)
    ASIGNED_TO      reduce using rule 61 (type -> TYPE_I32 .)
    IDENTIFIER      reduce using rule 61 (type -> TYPE_I32 .)
    LPAREN          reduce using rule 61 (type -> TYPE_I32 .)
    NOT             reduce using rule 61 (type -> TYPE_I32 .)
    INTEGER         reduce using rule 61 (type -> TYPE_I32 .)
    FLOAT           reduce using rule 61 (type -> TYPE_I32 .)
    STRING          reduce using rule 61 (type -> TYPE_I32 .)
    CHAR            reduce using rule 61 (type -> TYPE_I32 .)
    BOOLEAN         reduce using rule 61 (type -> TYPE_I32 .)
    BIT_AND         reduce using rule 61 (type -> TYPE_I32 .)
    LBRACKET        reduce using rule 61 (type -> TYPE_I32 .)


state 78

    (62) type -> TYPE_U64 .

    SEMICOLON       reduce using rule 62 (type -> TYPE_U64 .)
    DOT             reduce using rule 62 (type -> TYPE_U64 .)
    PLUS            reduce using rule 62 (type -> TYPE_U64 .)
    MINUS           reduce using rule 62 (type -> TYPE_U64 .)
    TIMES           reduce using rule 62 (type -> TYPE_U64 .)
    DIVIDE          reduce using rule 62 (type -> TYPE_U64 .)
    MOD             reduce using rule 62 (type -> TYPE_U64 .)
    AS              reduce using rule 62 (type -> TYPE_U64 .)
    RPAREN          reduce using rule 62 (type -> TYPE_U64 .)
    COMMA           reduce using rule 62 (type -> TYPE_U64 .)
    EQUAL_TO        reduce using rule 62 (type -> TYPE_U64 .)
    NOT_EQUAL       reduce using rule 62 (type -> TYPE_U64 .)
    LESS_THAN       reduce using rule 62 (type -> TYPE_U64 .)
    GREATER_THAN    reduce using rule 62 (type -> TYPE_U64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 62 (type -> TYPE_U64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 62 (type -> TYPE_U64 .)
    RBRACKET        reduce using rule 62 (type -> TYPE_U64 .)
    LBRACE          reduce using rule 62 (type -> TYPE_U64 .)
    CONJUNCTION     reduce using rule 62 (type -> TYPE_U64 .)
    DISJUNCTION     reduce using rule 62 (type -> TYPE_U64 .)
    RBRACE          reduce using rule 62 (type -> TYPE_U64 .)
    CLOSURE_PIPE    reduce using rule 62 (type -> TYPE_U64 .)
    ASIGNED_TO      reduce using rule 62 (type -> TYPE_U64 .)
    IDENTIFIER      reduce using rule 62 (type -> TYPE_U64 .)
    LPAREN          reduce using rule 62 (type -> TYPE_U64 .)
    NOT             reduce using rule 62 (type -> TYPE_U64 .)
    INTEGER         reduce using rule 62 (type -> TYPE_U64 .)
    FLOAT           reduce using rule 62 (type -> TYPE_U64 .)
    STRING          reduce using rule 62 (type -> TYPE_U64 .)
    CHAR            reduce using rule 62 (type -> TYPE_U64 .)
    BOOLEAN         reduce using rule 62 (type -> TYPE_U64 .)
    BIT_AND         reduce using rule 62 (type -> TYPE_U64 .)
    LBRACKET        reduce using rule 62 (type -> TYPE_U64 .)


state 79

    (63) type -> TYPE_F64 .

    SEMICOLON       reduce using rule 63 (type -> TYPE_F64 .)
    DOT             reduce using rule 63 (type -> TYPE_F64 .)
    PLUS            reduce using rule 63 (type -> TYPE_F64 .)
    MINUS           reduce using rule 63 (type -> TYPE_F64 .)
    TIMES           reduce using rule 63 (type -> TYPE_F64 .)
    DIVIDE          reduce using rule 63 (type -> TYPE_F64 .)
    MOD             reduce using rule 63 (type -> TYPE_F64 .)
    AS              reduce using rule 63 (type -> TYPE_F64 .)
    RPAREN          reduce using rule 63 (type -> TYPE_F64 .)
    COMMA           reduce using rule 63 (type -> TYPE_F64 .)
    EQUAL_TO        reduce using rule 63 (type -> TYPE_F64 .)
    NOT_EQUAL       reduce using rule 63 (type -> TYPE_F64 .)
    LESS_THAN       reduce using rule 63 (type -> TYPE_F64 .)
    GREATER_THAN    reduce using rule 63 (type -> TYPE_F64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 63 (type -> TYPE_F64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 63 (type -> TYPE_F64 .)
    RBRACKET        reduce using rule 63 (type -> TYPE_F64 .)
    LBRACE          reduce using rule 63 (type -> TYPE_F64 .)
    CONJUNCTION     reduce using rule 63 (type -> TYPE_F64 .)
    DISJUNCTION     reduce using rule 63 (type -> TYPE_F64 .)
    RBRACE          reduce using rule 63 (type -> TYPE_F64 .)
    CLOSURE_PIPE    reduce using rule 63 (type -> TYPE_F64 .)
    ASIGNED_TO      reduce using rule 63 (type -> TYPE_F64 .)
    IDENTIFIER      reduce using rule 63 (type -> TYPE_F64 .)
    LPAREN          reduce using rule 63 (type -> TYPE_F64 .)
    NOT             reduce using rule 63 (type -> TYPE_F64 .)
    INTEGER         reduce using rule 63 (type -> TYPE_F64 .)
    FLOAT           reduce using rule 63 (type -> TYPE_F64 .)
    STRING          reduce using rule 63 (type -> TYPE_F64 .)
    CHAR            reduce using rule 63 (type -> TYPE_F64 .)
    BOOLEAN         reduce using rule 63 (type -> TYPE_F64 .)
    BIT_AND         reduce using rule 63 (type -> TYPE_F64 .)
    LBRACKET        reduce using rule 63 (type -> TYPE_F64 .)


state 80

    (64) type -> TYPE_CHAR .

    SEMICOLON       reduce using rule 64 (type -> TYPE_CHAR .)
    DOT             reduce using rule 64 (type -> TYPE_CHAR .)
    PLUS            reduce using rule 64 (type -> TYPE_CHAR .)
    MINUS           reduce using rule 64 (type -> TYPE_CHAR .)
    TIMES           reduce using rule 64 (type -> TYPE_CHAR .)
    DIVIDE          reduce using rule 64 (type -> TYPE_CHAR .)
    MOD             reduce using rule 64 (type -> TYPE_CHAR .)
    AS              reduce using rule 64 (type -> TYPE_CHAR .)
    RPAREN          reduce using rule 64 (type -> TYPE_CHAR .)
    COMMA           reduce using rule 64 (type -> TYPE_CHAR .)
    EQUAL_TO        reduce using rule 64 (type -> TYPE_CHAR .)
    NOT_EQUAL       reduce using rule 64 (type -> TYPE_CHAR .)
    LESS_THAN       reduce using rule 64 (type -> TYPE_CHAR .)
    GREATER_THAN    reduce using rule 64 (type -> TYPE_CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 64 (type -> TYPE_CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 64 (type -> TYPE_CHAR .)
    RBRACKET        reduce using rule 64 (type -> TYPE_CHAR .)
    LBRACE          reduce using rule 64 (type -> TYPE_CHAR .)
    CONJUNCTION     reduce using rule 64 (type -> TYPE_CHAR .)
    DISJUNCTION     reduce using rule 64 (type -> TYPE_CHAR .)
    RBRACE          reduce using rule 64 (type -> TYPE_CHAR .)
    CLOSURE_PIPE    reduce using rule 64 (type -> TYPE_CHAR .)
    ASIGNED_TO      reduce using rule 64 (type -> TYPE_CHAR .)
    IDENTIFIER      reduce using rule 64 (type -> TYPE_CHAR .)
    LPAREN          reduce using rule 64 (type -> TYPE_CHAR .)
    NOT             reduce using rule 64 (type -> TYPE_CHAR .)
    INTEGER         reduce using rule 64 (type -> TYPE_CHAR .)
    FLOAT           reduce using rule 64 (type -> TYPE_CHAR .)
    STRING          reduce using rule 64 (type -> TYPE_CHAR .)
    CHAR            reduce using rule 64 (type -> TYPE_CHAR .)
    BOOLEAN         reduce using rule 64 (type -> TYPE_CHAR .)
    BIT_AND         reduce using rule 64 (type -> TYPE_CHAR .)
    LBRACKET        reduce using rule 64 (type -> TYPE_CHAR .)


state 81

    (65) type -> TYPE_STRING .

    SEMICOLON       reduce using rule 65 (type -> TYPE_STRING .)
    DOT             reduce using rule 65 (type -> TYPE_STRING .)
    PLUS            reduce using rule 65 (type -> TYPE_STRING .)
    MINUS           reduce using rule 65 (type -> TYPE_STRING .)
    TIMES           reduce using rule 65 (type -> TYPE_STRING .)
    DIVIDE          reduce using rule 65 (type -> TYPE_STRING .)
    MOD             reduce using rule 65 (type -> TYPE_STRING .)
    AS              reduce using rule 65 (type -> TYPE_STRING .)
    RPAREN          reduce using rule 65 (type -> TYPE_STRING .)
    COMMA           reduce using rule 65 (type -> TYPE_STRING .)
    EQUAL_TO        reduce using rule 65 (type -> TYPE_STRING .)
    NOT_EQUAL       reduce using rule 65 (type -> TYPE_STRING .)
    LESS_THAN       reduce using rule 65 (type -> TYPE_STRING .)
    GREATER_THAN    reduce using rule 65 (type -> TYPE_STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 65 (type -> TYPE_STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 65 (type -> TYPE_STRING .)
    RBRACKET        reduce using rule 65 (type -> TYPE_STRING .)
    LBRACE          reduce using rule 65 (type -> TYPE_STRING .)
    CONJUNCTION     reduce using rule 65 (type -> TYPE_STRING .)
    DISJUNCTION     reduce using rule 65 (type -> TYPE_STRING .)
    RBRACE          reduce using rule 65 (type -> TYPE_STRING .)
    CLOSURE_PIPE    reduce using rule 65 (type -> TYPE_STRING .)
    ASIGNED_TO      reduce using rule 65 (type -> TYPE_STRING .)
    IDENTIFIER      reduce using rule 65 (type -> TYPE_STRING .)
    LPAREN          reduce using rule 65 (type -> TYPE_STRING .)
    NOT             reduce using rule 65 (type -> TYPE_STRING .)
    INTEGER         reduce using rule 65 (type -> TYPE_STRING .)
    FLOAT           reduce using rule 65 (type -> TYPE_STRING .)
    STRING          reduce using rule 65 (type -> TYPE_STRING .)
    CHAR            reduce using rule 65 (type -> TYPE_STRING .)
    BOOLEAN         reduce using rule 65 (type -> TYPE_STRING .)
    BIT_AND         reduce using rule 65 (type -> TYPE_STRING .)
    LBRACKET        reduce using rule 65 (type -> TYPE_STRING .)


state 82

    (66) type -> TYPE_BOOL .

    SEMICOLON       reduce using rule 66 (type -> TYPE_BOOL .)
    DOT             reduce using rule 66 (type -> TYPE_BOOL .)
    PLUS            reduce using rule 66 (type -> TYPE_BOOL .)
    MINUS           reduce using rule 66 (type -> TYPE_BOOL .)
    TIMES           reduce using rule 66 (type -> TYPE_BOOL .)
    DIVIDE          reduce using rule 66 (type -> TYPE_BOOL .)
    MOD             reduce using rule 66 (type -> TYPE_BOOL .)
    AS              reduce using rule 66 (type -> TYPE_BOOL .)
    RPAREN          reduce using rule 66 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 66 (type -> TYPE_BOOL .)
    EQUAL_TO        reduce using rule 66 (type -> TYPE_BOOL .)
    NOT_EQUAL       reduce using rule 66 (type -> TYPE_BOOL .)
    LESS_THAN       reduce using rule 66 (type -> TYPE_BOOL .)
    GREATER_THAN    reduce using rule 66 (type -> TYPE_BOOL .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 66 (type -> TYPE_BOOL .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 66 (type -> TYPE_BOOL .)
    RBRACKET        reduce using rule 66 (type -> TYPE_BOOL .)
    LBRACE          reduce using rule 66 (type -> TYPE_BOOL .)
    CONJUNCTION     reduce using rule 66 (type -> TYPE_BOOL .)
    DISJUNCTION     reduce using rule 66 (type -> TYPE_BOOL .)
    RBRACE          reduce using rule 66 (type -> TYPE_BOOL .)
    CLOSURE_PIPE    reduce using rule 66 (type -> TYPE_BOOL .)
    ASIGNED_TO      reduce using rule 66 (type -> TYPE_BOOL .)
    IDENTIFIER      reduce using rule 66 (type -> TYPE_BOOL .)
    LPAREN          reduce using rule 66 (type -> TYPE_BOOL .)
    NOT             reduce using rule 66 (type -> TYPE_BOOL .)
    INTEGER         reduce using rule 66 (type -> TYPE_BOOL .)
    FLOAT           reduce using rule 66 (type -> TYPE_BOOL .)
    STRING          reduce using rule 66 (type -> TYPE_BOOL .)
    CHAR            reduce using rule 66 (type -> TYPE_BOOL .)
    BOOLEAN         reduce using rule 66 (type -> TYPE_BOOL .)
    BIT_AND         reduce using rule 66 (type -> TYPE_BOOL .)
    LBRACKET        reduce using rule 66 (type -> TYPE_BOOL .)


state 83

    (67) type -> TYPE_TUPLE .

    SEMICOLON       reduce using rule 67 (type -> TYPE_TUPLE .)
    DOT             reduce using rule 67 (type -> TYPE_TUPLE .)
    PLUS            reduce using rule 67 (type -> TYPE_TUPLE .)
    MINUS           reduce using rule 67 (type -> TYPE_TUPLE .)
    TIMES           reduce using rule 67 (type -> TYPE_TUPLE .)
    DIVIDE          reduce using rule 67 (type -> TYPE_TUPLE .)
    MOD             reduce using rule 67 (type -> TYPE_TUPLE .)
    AS              reduce using rule 67 (type -> TYPE_TUPLE .)
    RPAREN          reduce using rule 67 (type -> TYPE_TUPLE .)
    COMMA           reduce using rule 67 (type -> TYPE_TUPLE .)
    EQUAL_TO        reduce using rule 67 (type -> TYPE_TUPLE .)
    NOT_EQUAL       reduce using rule 67 (type -> TYPE_TUPLE .)
    LESS_THAN       reduce using rule 67 (type -> TYPE_TUPLE .)
    GREATER_THAN    reduce using rule 67 (type -> TYPE_TUPLE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 67 (type -> TYPE_TUPLE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 67 (type -> TYPE_TUPLE .)
    RBRACKET        reduce using rule 67 (type -> TYPE_TUPLE .)
    LBRACE          reduce using rule 67 (type -> TYPE_TUPLE .)
    CONJUNCTION     reduce using rule 67 (type -> TYPE_TUPLE .)
    DISJUNCTION     reduce using rule 67 (type -> TYPE_TUPLE .)
    RBRACE          reduce using rule 67 (type -> TYPE_TUPLE .)
    CLOSURE_PIPE    reduce using rule 67 (type -> TYPE_TUPLE .)
    ASIGNED_TO      reduce using rule 67 (type -> TYPE_TUPLE .)
    IDENTIFIER      reduce using rule 67 (type -> TYPE_TUPLE .)
    LPAREN          reduce using rule 67 (type -> TYPE_TUPLE .)
    NOT             reduce using rule 67 (type -> TYPE_TUPLE .)
    INTEGER         reduce using rule 67 (type -> TYPE_TUPLE .)
    FLOAT           reduce using rule 67 (type -> TYPE_TUPLE .)
    STRING          reduce using rule 67 (type -> TYPE_TUPLE .)
    CHAR            reduce using rule 67 (type -> TYPE_TUPLE .)
    BOOLEAN         reduce using rule 67 (type -> TYPE_TUPLE .)
    BIT_AND         reduce using rule 67 (type -> TYPE_TUPLE .)
    LBRACKET        reduce using rule 67 (type -> TYPE_TUPLE .)


state 84

    (68) type -> LBRACKET . type RBRACKET
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 130

state 85

    (69) type -> BIT_AND . type
    (70) type -> BIT_AND . MUT type
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    MUT             shift and go to state 132
    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 131

state 86

    (89) type -> LPAREN . tuple_type_list RPAREN
    (90) tuple_type_list -> . type
    (91) tuple_type_list -> . type COMMA tuple_type_list
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    tuple_type_list                shift and go to state 133
    type                           shift and go to state 134

state 87

    (56) statement -> IF condition LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    program_opt                    shift and go to state 135
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 88

    (52) condition -> condition CONJUNCTION . condition
    (46) condition -> . expression EQUAL_TO expression
    (47) condition -> . expression NOT_EQUAL expression
    (48) condition -> . expression LESS_THAN expression
    (49) condition -> . expression GREATER_THAN expression
    (50) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (52) condition -> . condition CONJUNCTION condition
    (53) condition -> . condition DISJUNCTION condition
    (54) condition -> . NOT condition
    (55) condition -> . LPAREN condition RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 43
    LPAREN          shift and go to state 44
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    condition                      shift and go to state 138
    expression                     shift and go to state 42

state 89

    (53) condition -> condition DISJUNCTION . condition
    (46) condition -> . expression EQUAL_TO expression
    (47) condition -> . expression NOT_EQUAL expression
    (48) condition -> . expression LESS_THAN expression
    (49) condition -> . expression GREATER_THAN expression
    (50) condition -> . expression LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (52) condition -> . condition CONJUNCTION condition
    (53) condition -> . condition DISJUNCTION condition
    (54) condition -> . NOT condition
    (55) condition -> . LPAREN condition RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    NOT             shift and go to state 43
    LPAREN          shift and go to state 44
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    condition                      shift and go to state 139
    expression                     shift and go to state 42

state 90

    (46) condition -> expression EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 140

state 91

    (47) condition -> expression NOT_EQUAL . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 141

state 92

    (48) condition -> expression LESS_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 142

state 93

    (49) condition -> expression GREATER_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 143

state 94

    (50) condition -> expression LESS_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 144

state 95

    (51) condition -> expression GREATER_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 145

state 96

    (54) condition -> NOT condition .
    (52) condition -> condition . CONJUNCTION condition
    (53) condition -> condition . DISJUNCTION condition

    LBRACE          reduce using rule 54 (condition -> NOT condition .)
    CONJUNCTION     reduce using rule 54 (condition -> NOT condition .)
    DISJUNCTION     reduce using rule 54 (condition -> NOT condition .)
    RPAREN          reduce using rule 54 (condition -> NOT condition .)

  ! CONJUNCTION     [ shift and go to state 88 ]
  ! DISJUNCTION     [ shift and go to state 89 ]


state 97

    (36) expression -> NOT expression .
    (46) condition -> expression . EQUAL_TO expression
    (47) condition -> expression . NOT_EQUAL expression
    (48) condition -> expression . LESS_THAN expression
    (49) condition -> expression . GREATER_THAN expression
    (50) condition -> expression . LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    DOT             reduce using rule 36 (expression -> NOT expression .)
    RPAREN          reduce using rule 36 (expression -> NOT expression .)
    COMMA           reduce using rule 36 (expression -> NOT expression .)
    EQUAL_TO        shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS_THAN       shift and go to state 92
    GREATER_THAN    shift and go to state 93
    LESS_THAN_OR_EQUAL_TO shift and go to state 94
    GREATER_THAN_OR_EQUAL_TO shift and go to state 95
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! EQUAL_TO        [ reduce using rule 36 (expression -> NOT expression .) ]
  ! NOT_EQUAL       [ reduce using rule 36 (expression -> NOT expression .) ]
  ! LESS_THAN       [ reduce using rule 36 (expression -> NOT expression .) ]
  ! GREATER_THAN    [ reduce using rule 36 (expression -> NOT expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 36 (expression -> NOT expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 36 (expression -> NOT expression .) ]
  ! PLUS            [ reduce using rule 36 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 36 (expression -> NOT expression .) ]
  ! AS              [ reduce using rule 36 (expression -> NOT expression .) ]
  ! DOT             [ shift and go to state 34 ]


state 98

    (55) condition -> LPAREN condition . RPAREN
    (52) condition -> condition . CONJUNCTION condition
    (53) condition -> condition . DISJUNCTION condition

    RPAREN          shift and go to state 146
    CONJUNCTION     shift and go to state 88
    DISJUNCTION     shift and go to state 89


state 99

    (30) expression -> LPAREN expression . RPAREN
    (46) condition -> expression . EQUAL_TO expression
    (47) condition -> expression . NOT_EQUAL expression
    (48) condition -> expression . LESS_THAN expression
    (49) condition -> expression . GREATER_THAN expression
    (50) condition -> expression . LESS_THAN_OR_EQUAL_TO expression
    (51) condition -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER
    (93) tuple_value_list -> expression .
    (94) tuple_value_list -> expression . COMMA tuple_value_list

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 66
    EQUAL_TO        shift and go to state 90
    NOT_EQUAL       shift and go to state 91
    LESS_THAN       shift and go to state 92
    GREATER_THAN    shift and go to state 93
    LESS_THAN_OR_EQUAL_TO shift and go to state 94
    GREATER_THAN_OR_EQUAL_TO shift and go to state 95
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40
    COMMA           shift and go to state 67

  ! RPAREN          [ reduce using rule 93 (tuple_value_list -> expression .) ]


state 100

    (57) statement -> IDENTIFIER ASIGNED_TO expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 147
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 101

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 148


state 102

    (104) expression -> IDENTIFIER LPAREN arguments_opt . RPAREN

    RPAREN          shift and go to state 149


state 103

    (14) arguments_opt -> argument_list .
    (16) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 14 (arguments_opt -> argument_list .)
    COMMA           shift and go to state 150


state 104

    (15) arguments_opt -> empty .

    RPAREN          reduce using rule 15 (arguments_opt -> empty .)


state 105

    (17) argument_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    COMMA           reduce using rule 17 (argument_list -> expression .)
    RPAREN          reduce using rule 17 (argument_list -> expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 106

    (83) expression -> IDENTIFIER LBRACKET expression . RBRACKET
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    RBRACKET        shift and go to state 151
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 107

    (84) expression -> IDENTIFIER LBRACKET INTEGER . RANGE INTEGER RBRACKET
    (85) expression -> IDENTIFIER LBRACKET INTEGER . RANGE_INCLUSIVE INTEGER RBRACKET
    (37) expression -> INTEGER .

    RANGE           shift and go to state 152
    RANGE_INCLUSIVE shift and go to state 153
    RBRACKET        reduce using rule 37 (expression -> INTEGER .)
    DOT             reduce using rule 37 (expression -> INTEGER .)
    PLUS            reduce using rule 37 (expression -> INTEGER .)
    MINUS           reduce using rule 37 (expression -> INTEGER .)
    TIMES           reduce using rule 37 (expression -> INTEGER .)
    DIVIDE          reduce using rule 37 (expression -> INTEGER .)
    MOD             reduce using rule 37 (expression -> INTEGER .)
    AS              reduce using rule 37 (expression -> INTEGER .)


state 108

    (86) expression -> IDENTIFIER NOT LBRACKET . element_list RBRACKET
    (79) element_list -> . element_list COMMA expression
    (80) element_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    element_list                   shift and go to state 154
    expression                     shift and go to state 155

state 109

    (58) statement -> WHILE condition LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    program_opt                    shift and go to state 156
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 110

    (59) statement -> ASYNC FN function_name . LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> ASYNC FN function_name . LPAREN RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 157


state 111

    (99) function_name -> IDENTIFIER .

    LPAREN          reduce using rule 99 (function_name -> IDENTIFIER .)


state 112

    (100) function_name -> MAIN .

    LPAREN          reduce using rule 100 (function_name -> MAIN .)


state 113

    (96) statement -> FOR IDENTIFIER IN . expression LBRACE program_opt RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 158

state 114

    (101) statement -> maybe_pub FN function_name . LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> maybe_pub FN function_name . LPAREN RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 159


state 115

    (103) statement -> RETURN expression SEMICOLON .

    PRINTLN         reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    ASYNC           reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    BOOLEAN         reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    BIT_AND         reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    LET             reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    CONST           reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    FN              reduce using rule 103 (statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 103 (statement -> RETURN expression SEMICOLON .)


state 116

    (28) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE . closure_body
    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE . ARROW type closure_body
    (23) closure_body -> . expression
    (24) closure_body -> . LBRACE closure_block_content RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    ARROW           shift and go to state 161
    LBRACE          shift and go to state 163
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    closure_body                   shift and go to state 160
    expression                     shift and go to state 162

state 117

    (20) closure_params -> IDENTIFIER COLON . type
    (22) closure_params -> IDENTIFIER COLON . type COMMA closure_params
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 164

state 118

    (21) closure_params -> IDENTIFIER COMMA . closure_params
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 56

    closure_params                 shift and go to state 165

state 119

    (44) expression -> BIT_AND MUT IDENTIFIER .

    SEMICOLON       reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    DOT             reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    PLUS            reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    MINUS           reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    TIMES           reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    DIVIDE          reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    MOD             reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    AS              reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    RPAREN          reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    COMMA           reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    EQUAL_TO        reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    NOT_EQUAL       reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN       reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN    reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    RBRACKET        reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    LBRACE          reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    CONJUNCTION     reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    DISJUNCTION     reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)
    RBRACE          reduce using rule 44 (expression -> BIT_AND MUT IDENTIFIER .)


state 120

    (81) expression -> LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    DOT             reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    PLUS            reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    MINUS           reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    TIMES           reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    DIVIDE          reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    MOD             reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    AS              reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    EQUAL_TO        reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    NOT_EQUAL       reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    LESS_THAN       reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    GREATER_THAN    reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    LBRACE          reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    CONJUNCTION     reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    DISJUNCTION     reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 81 (expression -> LBRACKET element_list RBRACKET .)


state 121

    (79) element_list -> element_list COMMA . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 166

state 122

    (82) expression -> LBRACKET expression SEMICOLON . INTEGER RBRACKET

    INTEGER         shift and go to state 167


state 123

    (72) let_decl -> LET maybe_mut IDENTIFIER . maybe_type maybe_init SEMICOLON
    (75) maybe_type -> . COLON type
    (76) maybe_type -> . empty
    (5) empty -> .

    COLON           shift and go to state 169
    ASIGNED_TO      reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_type                     shift and go to state 168
    empty                          shift and go to state 170

state 124

    (88) const_decl -> CONST IDENTIFIER COLON . type ASIGNED_TO expression SEMICOLON
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 171

state 125

    (6) statement -> PRINTLN NOT LPAREN STRING . RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT LPAREN STRING . COMMA argument_list RPAREN SEMICOLON
    (39) expression -> STRING .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 172
    COMMA           shift and go to state 173
    DOT             reduce using rule 39 (expression -> STRING .)
    PLUS            reduce using rule 39 (expression -> STRING .)
    MINUS           reduce using rule 39 (expression -> STRING .)
    TIMES           reduce using rule 39 (expression -> STRING .)
    DIVIDE          reduce using rule 39 (expression -> STRING .)
    MOD             reduce using rule 39 (expression -> STRING .)
    AS              reduce using rule 39 (expression -> STRING .)

  ! RPAREN          [ reduce using rule 39 (expression -> STRING .) ]


state 126

    (7) statement -> PRINTLN NOT LPAREN expression . RPAREN SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    RPAREN          shift and go to state 174
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 127

    (93) tuple_value_list -> expression .
    (94) tuple_value_list -> expression . COMMA tuple_value_list
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    RPAREN          reduce using rule 93 (tuple_value_list -> expression .)
    COMMA           shift and go to state 67
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 128

    (94) tuple_value_list -> expression COMMA tuple_value_list .

    RPAREN          reduce using rule 94 (tuple_value_list -> expression COMMA tuple_value_list .)


state 129

    (9) expression -> expression DOT IDENTIFIER LPAREN . expression COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER LPAREN . expression RPAREN
    (13) expression -> expression DOT IDENTIFIER LPAREN . arguments_opt RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (14) arguments_opt -> . argument_list
    (15) arguments_opt -> . empty
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (5) empty -> .

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    RPAREN          reduce using rule 5 (empty -> .)

    expression                     shift and go to state 175
    arguments_opt                  shift and go to state 176
    argument_list                  shift and go to state 103
    empty                          shift and go to state 104

state 130

    (68) type -> LBRACKET type . RBRACKET

    RBRACKET        shift and go to state 177


state 131

    (69) type -> BIT_AND type .

    SEMICOLON       reduce using rule 69 (type -> BIT_AND type .)
    DOT             reduce using rule 69 (type -> BIT_AND type .)
    PLUS            reduce using rule 69 (type -> BIT_AND type .)
    MINUS           reduce using rule 69 (type -> BIT_AND type .)
    TIMES           reduce using rule 69 (type -> BIT_AND type .)
    DIVIDE          reduce using rule 69 (type -> BIT_AND type .)
    MOD             reduce using rule 69 (type -> BIT_AND type .)
    AS              reduce using rule 69 (type -> BIT_AND type .)
    RPAREN          reduce using rule 69 (type -> BIT_AND type .)
    COMMA           reduce using rule 69 (type -> BIT_AND type .)
    EQUAL_TO        reduce using rule 69 (type -> BIT_AND type .)
    NOT_EQUAL       reduce using rule 69 (type -> BIT_AND type .)
    LESS_THAN       reduce using rule 69 (type -> BIT_AND type .)
    GREATER_THAN    reduce using rule 69 (type -> BIT_AND type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 69 (type -> BIT_AND type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 69 (type -> BIT_AND type .)
    RBRACKET        reduce using rule 69 (type -> BIT_AND type .)
    LBRACE          reduce using rule 69 (type -> BIT_AND type .)
    CONJUNCTION     reduce using rule 69 (type -> BIT_AND type .)
    DISJUNCTION     reduce using rule 69 (type -> BIT_AND type .)
    RBRACE          reduce using rule 69 (type -> BIT_AND type .)
    CLOSURE_PIPE    reduce using rule 69 (type -> BIT_AND type .)
    ASIGNED_TO      reduce using rule 69 (type -> BIT_AND type .)
    IDENTIFIER      reduce using rule 69 (type -> BIT_AND type .)
    LPAREN          reduce using rule 69 (type -> BIT_AND type .)
    NOT             reduce using rule 69 (type -> BIT_AND type .)
    INTEGER         reduce using rule 69 (type -> BIT_AND type .)
    FLOAT           reduce using rule 69 (type -> BIT_AND type .)
    STRING          reduce using rule 69 (type -> BIT_AND type .)
    CHAR            reduce using rule 69 (type -> BIT_AND type .)
    BOOLEAN         reduce using rule 69 (type -> BIT_AND type .)
    BIT_AND         reduce using rule 69 (type -> BIT_AND type .)
    LBRACKET        reduce using rule 69 (type -> BIT_AND type .)


state 132

    (70) type -> BIT_AND MUT . type
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 178

state 133

    (89) type -> LPAREN tuple_type_list . RPAREN

    RPAREN          shift and go to state 179


state 134

    (90) tuple_type_list -> type .
    (91) tuple_type_list -> type . COMMA tuple_type_list

    RPAREN          reduce using rule 90 (tuple_type_list -> type .)
    COMMA           shift and go to state 180


state 135

    (56) statement -> IF condition LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 181


state 136

    (3) program_opt -> program .
    (1) program -> program . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25
    FN              reduce using rule 5 (empty -> .)

    statement                      shift and go to state 27
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 26

state 137

    (4) program_opt -> empty .
    (98) maybe_pub -> empty .

    RBRACE          reduce using rule 4 (program_opt -> empty .)
    FN              reduce using rule 98 (maybe_pub -> empty .)


state 138

    (52) condition -> condition CONJUNCTION condition .
    (52) condition -> condition . CONJUNCTION condition
    (53) condition -> condition . DISJUNCTION condition

    LBRACE          reduce using rule 52 (condition -> condition CONJUNCTION condition .)
    CONJUNCTION     reduce using rule 52 (condition -> condition CONJUNCTION condition .)
    DISJUNCTION     reduce using rule 52 (condition -> condition CONJUNCTION condition .)
    RPAREN          reduce using rule 52 (condition -> condition CONJUNCTION condition .)

  ! CONJUNCTION     [ shift and go to state 88 ]
  ! DISJUNCTION     [ shift and go to state 89 ]


state 139

    (53) condition -> condition DISJUNCTION condition .
    (52) condition -> condition . CONJUNCTION condition
    (53) condition -> condition . DISJUNCTION condition

    LBRACE          reduce using rule 53 (condition -> condition DISJUNCTION condition .)
    DISJUNCTION     reduce using rule 53 (condition -> condition DISJUNCTION condition .)
    RPAREN          reduce using rule 53 (condition -> condition DISJUNCTION condition .)
    CONJUNCTION     shift and go to state 88

  ! CONJUNCTION     [ reduce using rule 53 (condition -> condition DISJUNCTION condition .) ]
  ! DISJUNCTION     [ shift and go to state 89 ]


state 140

    (46) condition -> expression EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          reduce using rule 46 (condition -> expression EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 46 (condition -> expression EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 46 (condition -> expression EQUAL_TO expression .)
    RPAREN          reduce using rule 46 (condition -> expression EQUAL_TO expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 141

    (47) condition -> expression NOT_EQUAL expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          reduce using rule 47 (condition -> expression NOT_EQUAL expression .)
    CONJUNCTION     reduce using rule 47 (condition -> expression NOT_EQUAL expression .)
    DISJUNCTION     reduce using rule 47 (condition -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 47 (condition -> expression NOT_EQUAL expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 142

    (48) condition -> expression LESS_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          reduce using rule 48 (condition -> expression LESS_THAN expression .)
    CONJUNCTION     reduce using rule 48 (condition -> expression LESS_THAN expression .)
    DISJUNCTION     reduce using rule 48 (condition -> expression LESS_THAN expression .)
    RPAREN          reduce using rule 48 (condition -> expression LESS_THAN expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 143

    (49) condition -> expression GREATER_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          reduce using rule 49 (condition -> expression GREATER_THAN expression .)
    CONJUNCTION     reduce using rule 49 (condition -> expression GREATER_THAN expression .)
    DISJUNCTION     reduce using rule 49 (condition -> expression GREATER_THAN expression .)
    RPAREN          reduce using rule 49 (condition -> expression GREATER_THAN expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 144

    (50) condition -> expression LESS_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          reduce using rule 50 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 50 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 50 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 50 (condition -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 145

    (51) condition -> expression GREATER_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          reduce using rule 51 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 51 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 51 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 51 (condition -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 146

    (55) condition -> LPAREN condition RPAREN .

    LBRACE          reduce using rule 55 (condition -> LPAREN condition RPAREN .)
    CONJUNCTION     reduce using rule 55 (condition -> LPAREN condition RPAREN .)
    DISJUNCTION     reduce using rule 55 (condition -> LPAREN condition RPAREN .)
    RPAREN          reduce using rule 55 (condition -> LPAREN condition RPAREN .)


state 147

    (57) statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .

    PRINTLN         reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    IF              reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    IDENTIFIER      reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    WHILE           reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    ASYNC           reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FOR             reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    RETURN          reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LPAREN          reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    NOT             reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    INTEGER         reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FLOAT           reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    STRING          reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CHAR            reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    BOOLEAN         reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    BIT_AND         reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LBRACKET        reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LET             reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CONST           reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    $end            reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FN              reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    RBRACE          reduce using rule 57 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)


state 148

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN . RPAREN

    RPAREN          shift and go to state 182


state 149

    (104) expression -> IDENTIFIER LPAREN arguments_opt RPAREN .

    SEMICOLON       reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DOT             reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    PLUS            reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    MINUS           reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    TIMES           reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DIVIDE          reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    MOD             reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    AS              reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RPAREN          reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    COMMA           reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    EQUAL_TO        reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    NOT_EQUAL       reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN       reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN    reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACKET        reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LBRACE          reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    CONJUNCTION     reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DISJUNCTION     reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACE          reduce using rule 104 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)


state 150

    (16) argument_list -> argument_list COMMA . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 183

state 151

    (83) expression -> IDENTIFIER LBRACKET expression RBRACKET .

    SEMICOLON       reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DOT             reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MOD             reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    AS              reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQUAL_TO        reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_THAN       reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_THAN    reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CONJUNCTION     reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DISJUNCTION     reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 83 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)


state 152

    (84) expression -> IDENTIFIER LBRACKET INTEGER RANGE . INTEGER RBRACKET

    INTEGER         shift and go to state 184


state 153

    (85) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE . INTEGER RBRACKET

    INTEGER         shift and go to state 185


state 154

    (86) expression -> IDENTIFIER NOT LBRACKET element_list . RBRACKET
    (79) element_list -> element_list . COMMA expression

    RBRACKET        shift and go to state 186
    COMMA           shift and go to state 121


state 155

    (80) element_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    RBRACKET        reduce using rule 80 (element_list -> expression .)
    COMMA           reduce using rule 80 (element_list -> expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 156

    (58) statement -> WHILE condition LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 187


state 157

    (59) statement -> ASYNC FN function_name LPAREN . RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> ASYNC FN function_name LPAREN . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 188


state 158

    (96) statement -> FOR IDENTIFIER IN expression . LBRACE program_opt RBRACE
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    LBRACE          shift and go to state 189
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 159

    (101) statement -> maybe_pub FN function_name LPAREN . RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> maybe_pub FN function_name LPAREN . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 190


state 160

    (28) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .

    SEMICOLON       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DOT             reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    PLUS            reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    MINUS           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    TIMES           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DIVIDE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    MOD             reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    AS              reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RPAREN          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    COMMA           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    EQUAL_TO        reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    NOT_EQUAL       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LESS_THAN       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    GREATER_THAN    reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RBRACKET        reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LBRACE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    CONJUNCTION     reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DISJUNCTION     reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RBRACE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)


state 161

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW . type closure_body
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 191

state 162

    (23) closure_body -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    SEMICOLON       reduce using rule 23 (closure_body -> expression .)
    RPAREN          reduce using rule 23 (closure_body -> expression .)
    COMMA           reduce using rule 23 (closure_body -> expression .)
    EQUAL_TO        reduce using rule 23 (closure_body -> expression .)
    NOT_EQUAL       reduce using rule 23 (closure_body -> expression .)
    LESS_THAN       reduce using rule 23 (closure_body -> expression .)
    GREATER_THAN    reduce using rule 23 (closure_body -> expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 23 (closure_body -> expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 23 (closure_body -> expression .)
    RBRACKET        reduce using rule 23 (closure_body -> expression .)
    LBRACE          reduce using rule 23 (closure_body -> expression .)
    CONJUNCTION     reduce using rule 23 (closure_body -> expression .)
    DISJUNCTION     reduce using rule 23 (closure_body -> expression .)
    RBRACE          reduce using rule 23 (closure_body -> expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! DOT             [ reduce using rule 23 (closure_body -> expression .) ]
  ! PLUS            [ reduce using rule 23 (closure_body -> expression .) ]
  ! MINUS           [ reduce using rule 23 (closure_body -> expression .) ]
  ! TIMES           [ reduce using rule 23 (closure_body -> expression .) ]
  ! DIVIDE          [ reduce using rule 23 (closure_body -> expression .) ]
  ! MOD             [ reduce using rule 23 (closure_body -> expression .) ]
  ! AS              [ reduce using rule 23 (closure_body -> expression .) ]


state 163

    (24) closure_body -> LBRACE . closure_block_content RBRACE
    (25) closure_block_content -> . expression
    (26) closure_block_content -> . program expression
    (27) closure_block_content -> . program_opt
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (1) program -> . program statement
    (2) program -> . statement
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (5) empty -> .
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    IDENTIFIER      shift and go to state 196
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    LET             shift and go to state 24
    CONST           shift and go to state 25

    closure_block_content          shift and go to state 192
    expression                     shift and go to state 193
    program                        shift and go to state 194
    program_opt                    shift and go to state 195
    statement                      shift and go to state 2
    empty                          shift and go to state 137
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 164

    (20) closure_params -> IDENTIFIER COLON type .
    (22) closure_params -> IDENTIFIER COLON type . COMMA closure_params

    CLOSURE_PIPE    reduce using rule 20 (closure_params -> IDENTIFIER COLON type .)
    COMMA           shift and go to state 197


state 165

    (21) closure_params -> IDENTIFIER COMMA closure_params .

    CLOSURE_PIPE    reduce using rule 21 (closure_params -> IDENTIFIER COMMA closure_params .)


state 166

    (79) element_list -> element_list COMMA expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    RBRACKET        reduce using rule 79 (element_list -> element_list COMMA expression .)
    COMMA           reduce using rule 79 (element_list -> element_list COMMA expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 167

    (82) expression -> LBRACKET expression SEMICOLON INTEGER . RBRACKET

    RBRACKET        shift and go to state 198


state 168

    (72) let_decl -> LET maybe_mut IDENTIFIER maybe_type . maybe_init SEMICOLON
    (77) maybe_init -> . ASIGNED_TO expression
    (78) maybe_init -> . empty
    (5) empty -> .

    ASIGNED_TO      shift and go to state 200
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_init                     shift and go to state 199
    empty                          shift and go to state 201

state 169

    (75) maybe_type -> COLON . type
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 202

state 170

    (76) maybe_type -> empty .

    ASIGNED_TO      reduce using rule 76 (maybe_type -> empty .)
    SEMICOLON       reduce using rule 76 (maybe_type -> empty .)


state 171

    (88) const_decl -> CONST IDENTIFIER COLON type . ASIGNED_TO expression SEMICOLON

    ASIGNED_TO      shift and go to state 203


state 172

    (6) statement -> PRINTLN NOT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 204


state 173

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA . argument_list RPAREN SEMICOLON
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    argument_list                  shift and go to state 205
    expression                     shift and go to state 105

state 174

    (7) statement -> PRINTLN NOT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 206


state 175

    (9) expression -> expression DOT IDENTIFIER LPAREN expression . COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER LPAREN expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER
    (17) argument_list -> expression .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMMA           shift and go to state 207
    RPAREN          shift and go to state 208
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40

  ! COMMA           [ reduce using rule 17 (argument_list -> expression .) ]
  ! RPAREN          [ reduce using rule 17 (argument_list -> expression .) ]


state 176

    (13) expression -> expression DOT IDENTIFIER LPAREN arguments_opt . RPAREN

    RPAREN          shift and go to state 209


state 177

    (68) type -> LBRACKET type RBRACKET .

    SEMICOLON       reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    DOT             reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    PLUS            reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    MINUS           reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    TIMES           reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    DIVIDE          reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    MOD             reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    AS              reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    COMMA           reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    EQUAL_TO        reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    NOT_EQUAL       reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    LESS_THAN       reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    GREATER_THAN    reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    LBRACE          reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    CONJUNCTION     reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    DISJUNCTION     reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    RBRACE          reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    CLOSURE_PIPE    reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    ASIGNED_TO      reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    IDENTIFIER      reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    LPAREN          reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    NOT             reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    INTEGER         reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    FLOAT           reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    STRING          reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    CHAR            reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    BOOLEAN         reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    BIT_AND         reduce using rule 68 (type -> LBRACKET type RBRACKET .)
    LBRACKET        reduce using rule 68 (type -> LBRACKET type RBRACKET .)


state 178

    (70) type -> BIT_AND MUT type .

    SEMICOLON       reduce using rule 70 (type -> BIT_AND MUT type .)
    DOT             reduce using rule 70 (type -> BIT_AND MUT type .)
    PLUS            reduce using rule 70 (type -> BIT_AND MUT type .)
    MINUS           reduce using rule 70 (type -> BIT_AND MUT type .)
    TIMES           reduce using rule 70 (type -> BIT_AND MUT type .)
    DIVIDE          reduce using rule 70 (type -> BIT_AND MUT type .)
    MOD             reduce using rule 70 (type -> BIT_AND MUT type .)
    AS              reduce using rule 70 (type -> BIT_AND MUT type .)
    RPAREN          reduce using rule 70 (type -> BIT_AND MUT type .)
    COMMA           reduce using rule 70 (type -> BIT_AND MUT type .)
    EQUAL_TO        reduce using rule 70 (type -> BIT_AND MUT type .)
    NOT_EQUAL       reduce using rule 70 (type -> BIT_AND MUT type .)
    LESS_THAN       reduce using rule 70 (type -> BIT_AND MUT type .)
    GREATER_THAN    reduce using rule 70 (type -> BIT_AND MUT type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 70 (type -> BIT_AND MUT type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 70 (type -> BIT_AND MUT type .)
    RBRACKET        reduce using rule 70 (type -> BIT_AND MUT type .)
    LBRACE          reduce using rule 70 (type -> BIT_AND MUT type .)
    CONJUNCTION     reduce using rule 70 (type -> BIT_AND MUT type .)
    DISJUNCTION     reduce using rule 70 (type -> BIT_AND MUT type .)
    RBRACE          reduce using rule 70 (type -> BIT_AND MUT type .)
    CLOSURE_PIPE    reduce using rule 70 (type -> BIT_AND MUT type .)
    ASIGNED_TO      reduce using rule 70 (type -> BIT_AND MUT type .)
    IDENTIFIER      reduce using rule 70 (type -> BIT_AND MUT type .)
    LPAREN          reduce using rule 70 (type -> BIT_AND MUT type .)
    NOT             reduce using rule 70 (type -> BIT_AND MUT type .)
    INTEGER         reduce using rule 70 (type -> BIT_AND MUT type .)
    FLOAT           reduce using rule 70 (type -> BIT_AND MUT type .)
    STRING          reduce using rule 70 (type -> BIT_AND MUT type .)
    CHAR            reduce using rule 70 (type -> BIT_AND MUT type .)
    BOOLEAN         reduce using rule 70 (type -> BIT_AND MUT type .)
    BIT_AND         reduce using rule 70 (type -> BIT_AND MUT type .)
    LBRACKET        reduce using rule 70 (type -> BIT_AND MUT type .)


state 179

    (89) type -> LPAREN tuple_type_list RPAREN .

    SEMICOLON       reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    DOT             reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    PLUS            reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    MINUS           reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    TIMES           reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    DIVIDE          reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    MOD             reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    AS              reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    RPAREN          reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    COMMA           reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    EQUAL_TO        reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    NOT_EQUAL       reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    LESS_THAN       reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    GREATER_THAN    reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    RBRACKET        reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    LBRACE          reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    CONJUNCTION     reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    DISJUNCTION     reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    RBRACE          reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    CLOSURE_PIPE    reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    ASIGNED_TO      reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    IDENTIFIER      reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    LPAREN          reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    NOT             reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    INTEGER         reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    FLOAT           reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    STRING          reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    CHAR            reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    BOOLEAN         reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    BIT_AND         reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)
    LBRACKET        reduce using rule 89 (type -> LPAREN tuple_type_list RPAREN .)


state 180

    (91) tuple_type_list -> type COMMA . tuple_type_list
    (90) tuple_type_list -> . type
    (91) tuple_type_list -> . type COMMA tuple_type_list
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 134
    tuple_type_list                shift and go to state 210

state 181

    (56) statement -> IF condition LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    IF              reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    FOR             reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    NOT             reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    STRING          reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    LET             reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    CONST           reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    $end            reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    FN              reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 56 (statement -> IF condition LBRACE program_opt RBRACE .)


state 182

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MOD             reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    AS              reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    EQUAL_TO        reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN    reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    CONJUNCTION     reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DISJUNCTION     reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)


state 183

    (16) argument_list -> argument_list COMMA expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    COMMA           reduce using rule 16 (argument_list -> argument_list COMMA expression .)
    RPAREN          reduce using rule 16 (argument_list -> argument_list COMMA expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 184

    (84) expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER . RBRACKET

    RBRACKET        shift and go to state 211


state 185

    (85) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER . RBRACKET

    RBRACKET        shift and go to state 212


state 186

    (86) expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DOT             reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    PLUS            reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    MINUS           reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    TIMES           reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DIVIDE          reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    MOD             reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    AS              reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    EQUAL_TO        reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    NOT_EQUAL       reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LESS_THAN       reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    GREATER_THAN    reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LBRACE          reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    CONJUNCTION     reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DISJUNCTION     reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 86 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)


state 187

    (58) statement -> WHILE condition LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    IF              reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    FOR             reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    NOT             reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    STRING          reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    LET             reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    CONST           reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    $end            reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    FN              reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 58 (statement -> WHILE condition LBRACE program_opt RBRACE .)


state 188

    (59) statement -> ASYNC FN function_name LPAREN RPAREN . ARROW type LBRACE program_opt RBRACE
    (60) statement -> ASYNC FN function_name LPAREN RPAREN . LBRACE program_opt RBRACE

    ARROW           shift and go to state 213
    LBRACE          shift and go to state 214


state 189

    (96) statement -> FOR IDENTIFIER IN expression LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    expression                     shift and go to state 7
    program_opt                    shift and go to state 215
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 190

    (101) statement -> maybe_pub FN function_name LPAREN RPAREN . ARROW type LBRACE program_opt RBRACE
    (102) statement -> maybe_pub FN function_name LPAREN RPAREN . LBRACE program_opt RBRACE

    ARROW           shift and go to state 216
    LBRACE          shift and go to state 217


state 191

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type . closure_body
    (23) closure_body -> . expression
    (24) closure_body -> . LBRACE closure_block_content RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    LBRACE          shift and go to state 163
    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    closure_body                   shift and go to state 218
    expression                     shift and go to state 162

state 192

    (24) closure_body -> LBRACE closure_block_content . RBRACE

    RBRACE          shift and go to state 219


state 193

    (25) closure_block_content -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 25 (closure_block_content -> expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40
    SEMICOLON       shift and go to state 33


state 194

    (26) closure_block_content -> program . expression
    (1) program -> program . statement
    (3) program_opt -> program .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    IDENTIFIER      shift and go to state 196
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    LET             shift and go to state 24
    CONST           shift and go to state 25
    FN              reduce using rule 5 (empty -> .)

    expression                     shift and go to state 220
    statement                      shift and go to state 27
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 26

state 195

    (27) closure_block_content -> program_opt .

    RBRACE          reduce using rule 27 (closure_block_content -> program_opt .)


state 196

    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (42) expression -> IDENTIFIER .
    (83) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (84) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (104) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN
    (57) statement -> IDENTIFIER . ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> IDENTIFIER .

    DOUBLE_COLON    shift and go to state 46
    DOT             reduce using rule 42 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 42 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 42 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 42 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 42 (expression -> IDENTIFIER .)
    MOD             reduce using rule 42 (expression -> IDENTIFIER .)
    AS              reduce using rule 42 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 42 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 42 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 48
    NOT             shift and go to state 49
    LPAREN          shift and go to state 47
    ASIGNED_TO      shift and go to state 45
    FN              reduce using rule 97 (maybe_pub -> IDENTIFIER .)


state 197

    (22) closure_params -> IDENTIFIER COLON type COMMA . closure_params
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 56

    closure_params                 shift and go to state 221

state 198

    (82) expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .

    SEMICOLON       reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DOT             reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    PLUS            reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    MINUS           reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    TIMES           reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DIVIDE          reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    MOD             reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    AS              reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RPAREN          reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    COMMA           reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RBRACKET        reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LBRACE          reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RBRACE          reduce using rule 82 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)


state 199

    (72) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init . SEMICOLON

    SEMICOLON       shift and go to state 222


state 200

    (77) maybe_init -> ASIGNED_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 223

state 201

    (78) maybe_init -> empty .

    SEMICOLON       reduce using rule 78 (maybe_init -> empty .)


state 202

    (75) maybe_type -> COLON type .

    ASIGNED_TO      reduce using rule 75 (maybe_type -> COLON type .)
    SEMICOLON       reduce using rule 75 (maybe_type -> COLON type .)


state 203

    (88) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 224

state 204

    (6) statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .

    PRINTLN         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    ASYNC           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LPAREN          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    NOT             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    INTEGER         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FLOAT           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    STRING          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CHAR            reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LET             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CONST           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    $end            reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FN              reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RBRACE          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)


state 205

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list . RPAREN SEMICOLON
    (16) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 225
    COMMA           shift and go to state 150


state 206

    (7) statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .

    PRINTLN         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    ASYNC           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    INTEGER         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FLOAT           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CHAR            reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LET             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FN              reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)


state 207

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA . expression RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 30
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23

    expression                     shift and go to state 226

state 208

    (10) expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DOT             reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    PLUS            reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    MINUS           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    TIMES           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    MOD             reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    AS              reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RPAREN          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    COMMA           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    EQUAL_TO        reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LBRACE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    CONJUNCTION     reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DISJUNCTION     reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RBRACE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)


state 209

    (13) expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .

    SEMICOLON       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DOT             reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    PLUS            reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    MINUS           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    TIMES           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DIVIDE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    MOD             reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    AS              reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RPAREN          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    COMMA           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    EQUAL_TO        reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    NOT_EQUAL       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN    reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACKET        reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LBRACE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    CONJUNCTION     reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DISJUNCTION     reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)


state 210

    (91) tuple_type_list -> type COMMA tuple_type_list .

    RPAREN          reduce using rule 91 (tuple_type_list -> type COMMA tuple_type_list .)


state 211

    (84) expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .

    SEMICOLON       reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DOT             reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    PLUS            reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MINUS           reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    TIMES           reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MOD             reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    AS              reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RPAREN          reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    COMMA           reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LBRACE          reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACE          reduce using rule 84 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)


state 212

    (85) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .

    SEMICOLON       reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DOT             reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    PLUS            reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MINUS           reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    TIMES           reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MOD             reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    AS              reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RPAREN          reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    COMMA           reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LBRACE          reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACE          reduce using rule 85 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)


state 213

    (59) statement -> ASYNC FN function_name LPAREN RPAREN ARROW . type LBRACE program_opt RBRACE
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 227

state 214

    (60) statement -> ASYNC FN function_name LPAREN RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    program_opt                    shift and go to state 228
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 215

    (96) statement -> FOR IDENTIFIER IN expression LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 229


state 216

    (101) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW . type LBRACE program_opt RBRACE
    (61) type -> . TYPE_I32
    (62) type -> . TYPE_U64
    (63) type -> . TYPE_F64
    (64) type -> . TYPE_CHAR
    (65) type -> . TYPE_STRING
    (66) type -> . TYPE_BOOL
    (67) type -> . TYPE_TUPLE
    (68) type -> . LBRACKET type RBRACKET
    (69) type -> . BIT_AND type
    (70) type -> . BIT_AND MUT type
    (89) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 77
    TYPE_U64        shift and go to state 78
    TYPE_F64        shift and go to state 79
    TYPE_CHAR       shift and go to state 80
    TYPE_STRING     shift and go to state 81
    TYPE_BOOL       shift and go to state 82
    TYPE_TUPLE      shift and go to state 83
    LBRACKET        shift and go to state 84
    BIT_AND         shift and go to state 85
    LPAREN          shift and go to state 86

    type                           shift and go to state 230

state 217

    (102) statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    maybe_pub                      shift and go to state 15
    program_opt                    shift and go to state 231
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13

state 218

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .

    SEMICOLON       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DOT             reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    PLUS            reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    MINUS           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    TIMES           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DIVIDE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    MOD             reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    AS              reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RPAREN          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    COMMA           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    EQUAL_TO        reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    NOT_EQUAL       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LESS_THAN       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    GREATER_THAN    reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RBRACKET        reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LBRACE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    CONJUNCTION     reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DISJUNCTION     reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RBRACE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)


state 219

    (24) closure_body -> LBRACE closure_block_content RBRACE .

    DOT             reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    PLUS            reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    MINUS           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    TIMES           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    DIVIDE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    MOD             reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    AS              reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    SEMICOLON       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RPAREN          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    COMMA           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    EQUAL_TO        reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    NOT_EQUAL       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LESS_THAN       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    GREATER_THAN    reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RBRACKET        reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LBRACE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    CONJUNCTION     reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    DISJUNCTION     reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RBRACE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)


state 220

    (26) closure_block_content -> program expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 26 (closure_block_content -> program expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40
    SEMICOLON       shift and go to state 33


state 221

    (22) closure_params -> IDENTIFIER COLON type COMMA closure_params .

    CLOSURE_PIPE    reduce using rule 22 (closure_params -> IDENTIFIER COLON type COMMA closure_params .)


state 222

    (72) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .

    PRINTLN         reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IF              reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IDENTIFIER      reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    WHILE           reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    ASYNC           reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FOR             reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RETURN          reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LPAREN          reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    NOT             reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    INTEGER         reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FLOAT           reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    STRING          reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CHAR            reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    BOOLEAN         reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    BIT_AND         reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LBRACKET        reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LET             reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CONST           reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    $end            reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FN              reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RBRACE          reduce using rule 72 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)


state 223

    (77) maybe_init -> ASIGNED_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 77 (maybe_init -> ASIGNED_TO expression .)
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 224

    (88) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 232
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 225

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 233


state 226

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (45) expression -> expression . AS type
    (95) expression -> expression . DOT INTEGER

    RPAREN          shift and go to state 234
    DOT             shift and go to state 34
    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MOD             shift and go to state 39
    AS              shift and go to state 40


state 227

    (59) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 235


state 228

    (60) statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 236


state 229

    (96) statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    IF              reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FOR             reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    NOT             reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    STRING          reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LET             reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CONST           reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    $end            reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FN              reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 96 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)


state 230

    (101) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 237


state 231

    (102) statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 238


state 232

    (88) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .

    PRINTLN         reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    IF              reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    IDENTIFIER      reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    WHILE           reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    ASYNC           reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FOR             reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    RETURN          reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LPAREN          reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    NOT             reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    INTEGER         reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FLOAT           reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    STRING          reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CHAR            reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    BOOLEAN         reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    BIT_AND         reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LBRACKET        reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LET             reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CONST           reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    $end            reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FN              reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    RBRACE          reduce using rule 88 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)


state 233

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .

    PRINTLN         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    IF              reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    ASYNC           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FOR             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LPAREN          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    NOT             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    INTEGER         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    STRING          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CHAR            reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LET             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CONST           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FN              reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)


state 234

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .

    SEMICOLON       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DOT             reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    PLUS            reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    MINUS           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    TIMES           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DIVIDE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    MOD             reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    AS              reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RPAREN          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    COMMA           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    EQUAL_TO        reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    NOT_EQUAL       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LESS_THAN       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    GREATER_THAN    reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RBRACKET        reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LBRACE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    CONJUNCTION     reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DISJUNCTION     reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RBRACE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)


state 235

    (59) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    program_opt                    shift and go to state 239
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 236

    (60) statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FOR             reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    NOT             reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    STRING          reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 60 (statement -> ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)


state 237

    (101) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (56) statement -> . IF condition LBRACE program_opt RBRACE
    (57) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (58) statement -> . WHILE condition LBRACE program_opt RBRACE
    (59) statement -> . ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (60) statement -> . ASYNC FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (71) statement -> . let_decl
    (87) statement -> . const_decl
    (96) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (101) statement -> . maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE
    (102) statement -> . maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE
    (103) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . NOT expression
    (37) expression -> . INTEGER
    (38) expression -> . FLOAT
    (39) expression -> . STRING
    (40) expression -> . CHAR
    (41) expression -> . BOOLEAN
    (42) expression -> . IDENTIFIER
    (43) expression -> . BIT_AND expression
    (44) expression -> . BIT_AND MUT IDENTIFIER
    (45) expression -> . expression AS type
    (81) expression -> . LBRACKET element_list RBRACKET
    (82) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (83) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (84) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (85) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (86) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (92) expression -> . LPAREN tuple_value_list RPAREN
    (95) expression -> . expression DOT INTEGER
    (104) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (72) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (88) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (97) maybe_pub -> . IDENTIFIER
    (98) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    INTEGER         shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 6
    CHAR            shift and go to state 20
    BOOLEAN         shift and go to state 21
    BIT_AND         shift and go to state 22
    LBRACKET        shift and go to state 23
    LET             shift and go to state 24
    CONST           shift and go to state 25

    maybe_pub                      shift and go to state 15
    program_opt                    shift and go to state 240
    program                        shift and go to state 136
    empty                          shift and go to state 137
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13

state 238

    (102) statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FOR             reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    NOT             reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    STRING          reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 102 (statement -> maybe_pub FN function_name LPAREN RPAREN LBRACE program_opt RBRACE .)


state 239

    (59) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 241


state 240

    (101) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 242


state 241

    (59) statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IF              reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FOR             reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    NOT             reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    STRING          reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LET             reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CONST           reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    $end            reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FN              reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 59 (statement -> ASYNC FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)


state 242

    (101) statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IF              reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FOR             reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    NOT             reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    STRING          reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    LET             reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    CONST           reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    $end            reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    FN              reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 101 (statement -> maybe_pub FN function_name LPAREN RPAREN ARROW type LBRACE program_opt RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 31 resolved as shift
WARNING: shift/reduce conflict for DOT in state 57 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 57 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 57 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 57 resolved as shift
WARNING: shift/reduce conflict for MOD in state 57 resolved as shift
WARNING: shift/reduce conflict for AS in state 57 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 99 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 125 resolved as shift
WARNING: shift/reduce conflict for DOT in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 162 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 162 resolved as shift
WARNING: shift/reduce conflict for MOD in state 162 resolved as shift
WARNING: shift/reduce conflict for AS in state 162 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 175 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 175 resolved as shift
