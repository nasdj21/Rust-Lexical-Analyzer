Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program statement
Rule 2     program -> statement
Rule 3     program_opt -> program
Rule 4     program_opt -> empty
Rule 5     empty -> <empty>
Rule 6     statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
Rule 7     statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON
Rule 8     statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
Rule 9     expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
Rule 10    expression -> expression DOT IDENTIFIER LPAREN expression RPAREN
Rule 11    expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
Rule 12    statement -> expression SEMICOLON
Rule 13    expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
Rule 14    arguments_opt -> argument_list
Rule 15    arguments_opt -> empty
Rule 16    argument_list -> argument_list COMMA expression
Rule 17    argument_list -> expression
Rule 18    closure_params -> <empty>
Rule 19    closure_params -> IDENTIFIER
Rule 20    closure_params -> IDENTIFIER COLON type
Rule 21    closure_params -> IDENTIFIER COMMA closure_params
Rule 22    closure_params -> IDENTIFIER COLON type COMMA closure_params
Rule 23    closure_body -> expression
Rule 24    closure_body -> LBRACE closure_block_content RBRACE
Rule 25    closure_block_content -> expression
Rule 26    closure_block_content -> program expression
Rule 27    closure_block_content -> program_opt
Rule 28    expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
Rule 29    expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
Rule 30    expression -> LPAREN expression RPAREN
Rule 31    expression -> expression PLUS expression
Rule 32    expression -> expression MINUS expression
Rule 33    expression -> expression TIMES expression
Rule 34    expression -> expression DIVIDE expression
Rule 35    expression -> expression MOD expression
Rule 36    expression -> expression RANGE expression
Rule 37    expression -> expression RANGE_INCLUSIVE expression
Rule 38    expression -> expression EQUAL_TO expression
Rule 39    expression -> expression NOT_EQUAL expression
Rule 40    expression -> expression LESS_THAN expression
Rule 41    expression -> expression GREATER_THAN expression
Rule 42    expression -> expression LESS_THAN_OR_EQUAL_TO expression
Rule 43    expression -> expression GREATER_THAN_OR_EQUAL_TO expression
Rule 44    expression -> expression CONJUNCTION expression
Rule 45    expression -> expression DISJUNCTION expression
Rule 46    expression -> NOT expression
Rule 47    expression -> MINUS expression
Rule 48    expression -> INTEGER
Rule 49    expression -> FLOAT
Rule 50    expression -> STRING
Rule 51    expression -> CHAR
Rule 52    expression -> BOOLEAN
Rule 53    expression -> IDENTIFIER
Rule 54    expression -> BIT_AND expression
Rule 55    expression -> BIT_AND MUT IDENTIFIER
Rule 56    expression -> expression AS type
Rule 57    statement -> IF expression LBRACE program_opt RBRACE
Rule 58    statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
Rule 59    statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON
Rule 60    statement -> WHILE expression LBRACE program_opt RBRACE
Rule 61    statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
Rule 62    statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
Rule 63    type -> TYPE_I32
Rule 64    type -> TYPE_U8
Rule 65    type -> TYPE_U16
Rule 66    type -> TYPE_U32
Rule 67    type -> TYPE_U64
Rule 68    type -> TYPE_F64
Rule 69    type -> TYPE_CHAR
Rule 70    type -> TYPE_STRING
Rule 71    type -> TYPE_STR
Rule 72    type -> TYPE_BOOL
Rule 73    type -> TYPE_TUPLE
Rule 74    type -> LBRACKET type RBRACKET
Rule 75    type -> LBRACKET type COMMA INTEGER RBRACKET
Rule 76    type -> BIT_AND type
Rule 77    type -> BIT_AND MUT type
Rule 78    statement -> let_decl
Rule 79    let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
Rule 80    maybe_mut -> MUT
Rule 81    maybe_mut -> empty
Rule 82    maybe_type -> COLON type
Rule 83    maybe_type -> empty
Rule 84    maybe_init -> ASIGNED_TO expression
Rule 85    maybe_init -> empty
Rule 86    element_list -> element_list COMMA expression
Rule 87    element_list -> expression
Rule 88    expression -> LBRACKET element_list RBRACKET
Rule 89    expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET
Rule 90    expression -> IDENTIFIER LBRACKET expression RBRACKET
Rule 91    expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
Rule 92    expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
Rule 93    expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET
Rule 94    statement -> const_decl
Rule 95    const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
Rule 96    type -> LPAREN tuple_type_list RPAREN
Rule 97    tuple_type_list -> type
Rule 98    tuple_type_list -> type COMMA tuple_type_list
Rule 99    expression -> LPAREN tuple_value_list RPAREN
Rule 100   tuple_value_list -> expression
Rule 101   tuple_value_list -> expression COMMA tuple_value_list
Rule 102   expression -> expression DOT INTEGER
Rule 103   statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
Rule 104   param_list_opt -> param_list
Rule 105   param_list_opt -> empty
Rule 106   param_list -> param_list COMMA param
Rule 107   param_list -> param
Rule 108   param -> IDENTIFIER COLON type
Rule 109   function_body -> program expression
Rule 110   function_body -> expression
Rule 111   function_body -> program_opt
Rule 112   maybe_pub -> IDENTIFIER
Rule 113   maybe_pub -> empty
Rule 114   function_name -> IDENTIFIER
Rule 115   function_name -> MAIN
Rule 116   statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
Rule 117   statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
Rule 118   statement -> RETURN expression SEMICOLON
Rule 119   expression -> IDENTIFIER LPAREN arguments_opt RPAREN

Terminals, with rules where they appear

ARROW                : 29 61 116
AS                   : 56
ASIGNED_TO           : 59 84 95
ASYNC                : 61 62
BIT_AND              : 54 55 76 77
BOOLEAN              : 52
CHAR                 : 51
CLOSURE_PIPE         : 28 28 29 29
COLON                : 20 22 82 95 108
COMMA                : 8 9 16 21 22 75 86 98 101 106
CONJUNCTION          : 44
CONST                : 95
DISJUNCTION          : 45
DIVIDE               : 34
DOT                  : 9 10 13 102
DOUBLE_COLON         : 11
ELSE                 : 58
EQUAL_TO             : 38
FLOAT                : 49
FN                   : 61 62 116 117
FOR                  : 103
GREATER_THAN         : 41
GREATER_THAN_OR_EQUAL_TO : 43
IDENTIFIER           : 9 10 11 11 13 19 20 21 22 53 55 59 79 90 91 92 93 95 103 108 112 114 119
IF                   : 57 58
IN                   : 103
INTEGER              : 48 75 89 91 91 92 92 102
LBRACE               : 24 57 58 58 60 61 62 103 116 117
LBRACKET             : 74 75 88 89 90 91 92 93
LESS_THAN            : 40
LESS_THAN_OR_EQUAL_TO : 42
LET                  : 79
LPAREN               : 6 7 8 9 10 11 13 30 61 62 96 99 116 117 119
MAIN                 : 115
MINUS                : 32 47
MOD                  : 35
MUT                  : 55 77 80
NOT                  : 6 7 8 46 93
NOT_EQUAL            : 39
PLUS                 : 31
PRINTLN              : 6 7 8
RANGE                : 36 91
RANGE_INCLUSIVE      : 37 92
RBRACE               : 24 57 58 58 60 61 62 103 116 117
RBRACKET             : 74 75 88 89 90 91 92 93
RETURN               : 118
RPAREN               : 6 7 8 9 10 11 13 30 61 62 96 99 116 117 119
SEMICOLON            : 6 7 8 12 59 79 89 95 118
STRING               : 6 8 50
TIMES                : 33
TYPE_BOOL            : 72
TYPE_CHAR            : 69
TYPE_F64             : 68
TYPE_I32             : 63
TYPE_STR             : 71
TYPE_STRING          : 70
TYPE_TUPLE           : 73
TYPE_U16             : 65
TYPE_U32             : 66
TYPE_U64             : 67
TYPE_U8              : 64
WHILE                : 60
error                : 

Nonterminals, with rules where they appear

argument_list        : 8 14 16
arguments_opt        : 13 119
closure_block_content : 24
closure_body         : 28 29
closure_params       : 21 22 28 29
const_decl           : 94
element_list         : 86 88 93
empty                : 4 15 81 83 85 105 113
expression           : 7 9 9 9 10 10 12 13 16 17 23 25 26 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 47 54 56 57 58 59 60 84 86 87 89 90 95 100 101 102 103 109 110 118
function_body        : 61 116
function_name        : 61 62 116 117
let_decl             : 78
maybe_init           : 79
maybe_mut            : 79
maybe_pub            : 116 117
maybe_type           : 79
param                : 106 107
param_list           : 104 106
param_list_opt       : 61 62 116 117
program              : 1 3 26 109 0
program_opt          : 27 57 58 58 60 62 103 111 117
statement            : 1 2
tuple_type_list      : 96 98
tuple_value_list     : 99 101
type                 : 20 22 29 56 61 74 75 76 77 82 95 97 98 108 116

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program statement
    (2) program -> . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    program                        shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 1

    (0) S' -> program .
    (1) program -> program . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    statement                      shift and go to state 28
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 2

    (2) program -> statement .

    PRINTLN         reduce using rule 2 (program -> statement .)
    IF              reduce using rule 2 (program -> statement .)
    IDENTIFIER      reduce using rule 2 (program -> statement .)
    WHILE           reduce using rule 2 (program -> statement .)
    ASYNC           reduce using rule 2 (program -> statement .)
    FOR             reduce using rule 2 (program -> statement .)
    RETURN          reduce using rule 2 (program -> statement .)
    CLOSURE_PIPE    reduce using rule 2 (program -> statement .)
    LPAREN          reduce using rule 2 (program -> statement .)
    NOT             reduce using rule 2 (program -> statement .)
    MINUS           reduce using rule 2 (program -> statement .)
    INTEGER         reduce using rule 2 (program -> statement .)
    FLOAT           reduce using rule 2 (program -> statement .)
    STRING          reduce using rule 2 (program -> statement .)
    CHAR            reduce using rule 2 (program -> statement .)
    BOOLEAN         reduce using rule 2 (program -> statement .)
    BIT_AND         reduce using rule 2 (program -> statement .)
    LBRACKET        reduce using rule 2 (program -> statement .)
    LET             reduce using rule 2 (program -> statement .)
    CONST           reduce using rule 2 (program -> statement .)
    $end            reduce using rule 2 (program -> statement .)
    FN              reduce using rule 2 (program -> statement .)
    RBRACE          reduce using rule 2 (program -> statement .)


state 3

    (6) statement -> PRINTLN . NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN . NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> PRINTLN . NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON

    NOT             shift and go to state 29


state 4

    (46) expression -> NOT . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 30

state 5

    (30) expression -> LPAREN . expression RPAREN
    (99) expression -> LPAREN . tuple_value_list RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (100) tuple_value_list -> . expression
    (101) tuple_value_list -> . expression COMMA tuple_value_list

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 32
    tuple_value_list               shift and go to state 33

state 6

    (50) expression -> STRING .

    SEMICOLON       reduce using rule 50 (expression -> STRING .)
    DOT             reduce using rule 50 (expression -> STRING .)
    PLUS            reduce using rule 50 (expression -> STRING .)
    MINUS           reduce using rule 50 (expression -> STRING .)
    TIMES           reduce using rule 50 (expression -> STRING .)
    DIVIDE          reduce using rule 50 (expression -> STRING .)
    MOD             reduce using rule 50 (expression -> STRING .)
    RANGE           reduce using rule 50 (expression -> STRING .)
    RANGE_INCLUSIVE reduce using rule 50 (expression -> STRING .)
    EQUAL_TO        reduce using rule 50 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 50 (expression -> STRING .)
    LESS_THAN       reduce using rule 50 (expression -> STRING .)
    GREATER_THAN    reduce using rule 50 (expression -> STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    CONJUNCTION     reduce using rule 50 (expression -> STRING .)
    DISJUNCTION     reduce using rule 50 (expression -> STRING .)
    AS              reduce using rule 50 (expression -> STRING .)
    RPAREN          reduce using rule 50 (expression -> STRING .)
    COMMA           reduce using rule 50 (expression -> STRING .)
    LBRACE          reduce using rule 50 (expression -> STRING .)
    RBRACKET        reduce using rule 50 (expression -> STRING .)
    RBRACE          reduce using rule 50 (expression -> STRING .)


state 7

    (12) statement -> expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 34
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 8

    (57) statement -> IF . expression LBRACE program_opt RBRACE
    (58) statement -> IF . expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 52

state 9

    (59) statement -> IDENTIFIER . ASIGNED_TO expression SEMICOLON
    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (53) expression -> IDENTIFIER .
    (90) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (91) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (119) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN
    (112) maybe_pub -> IDENTIFIER .

    ASIGNED_TO      shift and go to state 53
    DOUBLE_COLON    shift and go to state 54
    SEMICOLON       reduce using rule 53 (expression -> IDENTIFIER .)
    DOT             reduce using rule 53 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 53 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 53 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 53 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (expression -> IDENTIFIER .)
    MOD             reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE           reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 53 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    AS              reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 56
    NOT             shift and go to state 57
    LPAREN          shift and go to state 55
    FN              reduce using rule 112 (maybe_pub -> IDENTIFIER .)


state 10

    (60) statement -> WHILE . expression LBRACE program_opt RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 58

state 11

    (61) statement -> ASYNC . FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> ASYNC . FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 59


state 12

    (78) statement -> let_decl .

    PRINTLN         reduce using rule 78 (statement -> let_decl .)
    IF              reduce using rule 78 (statement -> let_decl .)
    IDENTIFIER      reduce using rule 78 (statement -> let_decl .)
    WHILE           reduce using rule 78 (statement -> let_decl .)
    ASYNC           reduce using rule 78 (statement -> let_decl .)
    FOR             reduce using rule 78 (statement -> let_decl .)
    RETURN          reduce using rule 78 (statement -> let_decl .)
    CLOSURE_PIPE    reduce using rule 78 (statement -> let_decl .)
    LPAREN          reduce using rule 78 (statement -> let_decl .)
    NOT             reduce using rule 78 (statement -> let_decl .)
    MINUS           reduce using rule 78 (statement -> let_decl .)
    INTEGER         reduce using rule 78 (statement -> let_decl .)
    FLOAT           reduce using rule 78 (statement -> let_decl .)
    STRING          reduce using rule 78 (statement -> let_decl .)
    CHAR            reduce using rule 78 (statement -> let_decl .)
    BOOLEAN         reduce using rule 78 (statement -> let_decl .)
    BIT_AND         reduce using rule 78 (statement -> let_decl .)
    LBRACKET        reduce using rule 78 (statement -> let_decl .)
    LET             reduce using rule 78 (statement -> let_decl .)
    CONST           reduce using rule 78 (statement -> let_decl .)
    $end            reduce using rule 78 (statement -> let_decl .)
    FN              reduce using rule 78 (statement -> let_decl .)
    RBRACE          reduce using rule 78 (statement -> let_decl .)


state 13

    (94) statement -> const_decl .

    PRINTLN         reduce using rule 94 (statement -> const_decl .)
    IF              reduce using rule 94 (statement -> const_decl .)
    IDENTIFIER      reduce using rule 94 (statement -> const_decl .)
    WHILE           reduce using rule 94 (statement -> const_decl .)
    ASYNC           reduce using rule 94 (statement -> const_decl .)
    FOR             reduce using rule 94 (statement -> const_decl .)
    RETURN          reduce using rule 94 (statement -> const_decl .)
    CLOSURE_PIPE    reduce using rule 94 (statement -> const_decl .)
    LPAREN          reduce using rule 94 (statement -> const_decl .)
    NOT             reduce using rule 94 (statement -> const_decl .)
    MINUS           reduce using rule 94 (statement -> const_decl .)
    INTEGER         reduce using rule 94 (statement -> const_decl .)
    FLOAT           reduce using rule 94 (statement -> const_decl .)
    STRING          reduce using rule 94 (statement -> const_decl .)
    CHAR            reduce using rule 94 (statement -> const_decl .)
    BOOLEAN         reduce using rule 94 (statement -> const_decl .)
    BIT_AND         reduce using rule 94 (statement -> const_decl .)
    LBRACKET        reduce using rule 94 (statement -> const_decl .)
    LET             reduce using rule 94 (statement -> const_decl .)
    CONST           reduce using rule 94 (statement -> const_decl .)
    $end            reduce using rule 94 (statement -> const_decl .)
    FN              reduce using rule 94 (statement -> const_decl .)
    RBRACE          reduce using rule 94 (statement -> const_decl .)


state 14

    (103) statement -> FOR . IDENTIFIER IN expression LBRACE program_opt RBRACE

    IDENTIFIER      shift and go to state 60


state 15

    (116) statement -> maybe_pub . FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> maybe_pub . FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 61


state 16

    (118) statement -> RETURN . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 62

state 17

    (28) expression -> CLOSURE_PIPE . closure_params CLOSURE_PIPE closure_body
    (29) expression -> CLOSURE_PIPE . closure_params CLOSURE_PIPE ARROW type closure_body
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 64

    closure_params                 shift and go to state 63

state 18

    (47) expression -> MINUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 65

state 19

    (48) expression -> INTEGER .

    SEMICOLON       reduce using rule 48 (expression -> INTEGER .)
    DOT             reduce using rule 48 (expression -> INTEGER .)
    PLUS            reduce using rule 48 (expression -> INTEGER .)
    MINUS           reduce using rule 48 (expression -> INTEGER .)
    TIMES           reduce using rule 48 (expression -> INTEGER .)
    DIVIDE          reduce using rule 48 (expression -> INTEGER .)
    MOD             reduce using rule 48 (expression -> INTEGER .)
    RANGE           reduce using rule 48 (expression -> INTEGER .)
    RANGE_INCLUSIVE reduce using rule 48 (expression -> INTEGER .)
    EQUAL_TO        reduce using rule 48 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN       reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN    reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    CONJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    DISJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    AS              reduce using rule 48 (expression -> INTEGER .)
    RPAREN          reduce using rule 48 (expression -> INTEGER .)
    COMMA           reduce using rule 48 (expression -> INTEGER .)
    LBRACE          reduce using rule 48 (expression -> INTEGER .)
    RBRACKET        reduce using rule 48 (expression -> INTEGER .)
    RBRACE          reduce using rule 48 (expression -> INTEGER .)


state 20

    (49) expression -> FLOAT .

    SEMICOLON       reduce using rule 49 (expression -> FLOAT .)
    DOT             reduce using rule 49 (expression -> FLOAT .)
    PLUS            reduce using rule 49 (expression -> FLOAT .)
    MINUS           reduce using rule 49 (expression -> FLOAT .)
    TIMES           reduce using rule 49 (expression -> FLOAT .)
    DIVIDE          reduce using rule 49 (expression -> FLOAT .)
    MOD             reduce using rule 49 (expression -> FLOAT .)
    RANGE           reduce using rule 49 (expression -> FLOAT .)
    RANGE_INCLUSIVE reduce using rule 49 (expression -> FLOAT .)
    EQUAL_TO        reduce using rule 49 (expression -> FLOAT .)
    NOT_EQUAL       reduce using rule 49 (expression -> FLOAT .)
    LESS_THAN       reduce using rule 49 (expression -> FLOAT .)
    GREATER_THAN    reduce using rule 49 (expression -> FLOAT .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 49 (expression -> FLOAT .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 49 (expression -> FLOAT .)
    CONJUNCTION     reduce using rule 49 (expression -> FLOAT .)
    DISJUNCTION     reduce using rule 49 (expression -> FLOAT .)
    AS              reduce using rule 49 (expression -> FLOAT .)
    RPAREN          reduce using rule 49 (expression -> FLOAT .)
    COMMA           reduce using rule 49 (expression -> FLOAT .)
    LBRACE          reduce using rule 49 (expression -> FLOAT .)
    RBRACKET        reduce using rule 49 (expression -> FLOAT .)
    RBRACE          reduce using rule 49 (expression -> FLOAT .)


state 21

    (51) expression -> CHAR .

    SEMICOLON       reduce using rule 51 (expression -> CHAR .)
    DOT             reduce using rule 51 (expression -> CHAR .)
    PLUS            reduce using rule 51 (expression -> CHAR .)
    MINUS           reduce using rule 51 (expression -> CHAR .)
    TIMES           reduce using rule 51 (expression -> CHAR .)
    DIVIDE          reduce using rule 51 (expression -> CHAR .)
    MOD             reduce using rule 51 (expression -> CHAR .)
    RANGE           reduce using rule 51 (expression -> CHAR .)
    RANGE_INCLUSIVE reduce using rule 51 (expression -> CHAR .)
    EQUAL_TO        reduce using rule 51 (expression -> CHAR .)
    NOT_EQUAL       reduce using rule 51 (expression -> CHAR .)
    LESS_THAN       reduce using rule 51 (expression -> CHAR .)
    GREATER_THAN    reduce using rule 51 (expression -> CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 51 (expression -> CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 51 (expression -> CHAR .)
    CONJUNCTION     reduce using rule 51 (expression -> CHAR .)
    DISJUNCTION     reduce using rule 51 (expression -> CHAR .)
    AS              reduce using rule 51 (expression -> CHAR .)
    RPAREN          reduce using rule 51 (expression -> CHAR .)
    COMMA           reduce using rule 51 (expression -> CHAR .)
    LBRACE          reduce using rule 51 (expression -> CHAR .)
    RBRACKET        reduce using rule 51 (expression -> CHAR .)
    RBRACE          reduce using rule 51 (expression -> CHAR .)


state 22

    (52) expression -> BOOLEAN .

    SEMICOLON       reduce using rule 52 (expression -> BOOLEAN .)
    DOT             reduce using rule 52 (expression -> BOOLEAN .)
    PLUS            reduce using rule 52 (expression -> BOOLEAN .)
    MINUS           reduce using rule 52 (expression -> BOOLEAN .)
    TIMES           reduce using rule 52 (expression -> BOOLEAN .)
    DIVIDE          reduce using rule 52 (expression -> BOOLEAN .)
    MOD             reduce using rule 52 (expression -> BOOLEAN .)
    RANGE           reduce using rule 52 (expression -> BOOLEAN .)
    RANGE_INCLUSIVE reduce using rule 52 (expression -> BOOLEAN .)
    EQUAL_TO        reduce using rule 52 (expression -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 52 (expression -> BOOLEAN .)
    LESS_THAN       reduce using rule 52 (expression -> BOOLEAN .)
    GREATER_THAN    reduce using rule 52 (expression -> BOOLEAN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 52 (expression -> BOOLEAN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 52 (expression -> BOOLEAN .)
    CONJUNCTION     reduce using rule 52 (expression -> BOOLEAN .)
    DISJUNCTION     reduce using rule 52 (expression -> BOOLEAN .)
    AS              reduce using rule 52 (expression -> BOOLEAN .)
    RPAREN          reduce using rule 52 (expression -> BOOLEAN .)
    COMMA           reduce using rule 52 (expression -> BOOLEAN .)
    LBRACE          reduce using rule 52 (expression -> BOOLEAN .)
    RBRACKET        reduce using rule 52 (expression -> BOOLEAN .)
    RBRACE          reduce using rule 52 (expression -> BOOLEAN .)


state 23

    (54) expression -> BIT_AND . expression
    (55) expression -> BIT_AND . MUT IDENTIFIER
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    MUT             shift and go to state 67
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 66

state 24

    (88) expression -> LBRACKET . element_list RBRACKET
    (89) expression -> LBRACKET . expression SEMICOLON INTEGER RBRACKET
    (86) element_list -> . element_list COMMA expression
    (87) element_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    element_list                   shift and go to state 68
    expression                     shift and go to state 69

state 25

    (79) let_decl -> LET . maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (80) maybe_mut -> . MUT
    (81) maybe_mut -> . empty
    (5) empty -> .

    MUT             shift and go to state 71
    IDENTIFIER      reduce using rule 5 (empty -> .)

    maybe_mut                      shift and go to state 70
    empty                          shift and go to state 72

state 26

    (95) const_decl -> CONST . IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON

    IDENTIFIER      shift and go to state 73


state 27

    (113) maybe_pub -> empty .

    FN              reduce using rule 113 (maybe_pub -> empty .)


state 28

    (1) program -> program statement .

    PRINTLN         reduce using rule 1 (program -> program statement .)
    IF              reduce using rule 1 (program -> program statement .)
    IDENTIFIER      reduce using rule 1 (program -> program statement .)
    WHILE           reduce using rule 1 (program -> program statement .)
    ASYNC           reduce using rule 1 (program -> program statement .)
    FOR             reduce using rule 1 (program -> program statement .)
    RETURN          reduce using rule 1 (program -> program statement .)
    CLOSURE_PIPE    reduce using rule 1 (program -> program statement .)
    LPAREN          reduce using rule 1 (program -> program statement .)
    NOT             reduce using rule 1 (program -> program statement .)
    MINUS           reduce using rule 1 (program -> program statement .)
    INTEGER         reduce using rule 1 (program -> program statement .)
    FLOAT           reduce using rule 1 (program -> program statement .)
    STRING          reduce using rule 1 (program -> program statement .)
    CHAR            reduce using rule 1 (program -> program statement .)
    BOOLEAN         reduce using rule 1 (program -> program statement .)
    BIT_AND         reduce using rule 1 (program -> program statement .)
    LBRACKET        reduce using rule 1 (program -> program statement .)
    LET             reduce using rule 1 (program -> program statement .)
    CONST           reduce using rule 1 (program -> program statement .)
    $end            reduce using rule 1 (program -> program statement .)
    FN              reduce using rule 1 (program -> program statement .)
    RBRACE          reduce using rule 1 (program -> program statement .)


state 29

    (6) statement -> PRINTLN NOT . LPAREN STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN NOT . LPAREN expression RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT . LPAREN STRING COMMA argument_list RPAREN SEMICOLON

    LPAREN          shift and go to state 74


state 30

    (46) expression -> NOT expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 46 (expression -> NOT expression .)
    DOT             reduce using rule 46 (expression -> NOT expression .)
    CONJUNCTION     reduce using rule 46 (expression -> NOT expression .)
    DISJUNCTION     reduce using rule 46 (expression -> NOT expression .)
    RPAREN          reduce using rule 46 (expression -> NOT expression .)
    COMMA           reduce using rule 46 (expression -> NOT expression .)
    LBRACE          reduce using rule 46 (expression -> NOT expression .)
    RBRACKET        reduce using rule 46 (expression -> NOT expression .)
    RBRACE          reduce using rule 46 (expression -> NOT expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 46 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! TIMES           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 46 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 46 (expression -> NOT expression .) ]
  ! RANGE           [ reduce using rule 46 (expression -> NOT expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 46 (expression -> NOT expression .) ]
  ! EQUAL_TO        [ reduce using rule 46 (expression -> NOT expression .) ]
  ! NOT_EQUAL       [ reduce using rule 46 (expression -> NOT expression .) ]
  ! LESS_THAN       [ reduce using rule 46 (expression -> NOT expression .) ]
  ! GREATER_THAN    [ reduce using rule 46 (expression -> NOT expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 46 (expression -> NOT expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 46 (expression -> NOT expression .) ]
  ! AS              [ reduce using rule 46 (expression -> NOT expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 31

    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (53) expression -> IDENTIFIER .
    (90) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (91) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (119) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN

    DOUBLE_COLON    shift and go to state 54
    DOT             reduce using rule 53 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 53 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 53 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 53 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (expression -> IDENTIFIER .)
    MOD             reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE           reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 53 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    AS              reduce using rule 53 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 53 (expression -> IDENTIFIER .)
    COMMA           reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACE          reduce using rule 53 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 53 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 56
    NOT             shift and go to state 57
    LPAREN          shift and go to state 55


state 32

    (30) expression -> LPAREN expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER
    (100) tuple_value_list -> expression .
    (101) tuple_value_list -> expression . COMMA tuple_value_list

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 75
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    COMMA           shift and go to state 76

  ! RPAREN          [ reduce using rule 100 (tuple_value_list -> expression .) ]


state 33

    (99) expression -> LPAREN tuple_value_list . RPAREN

    RPAREN          shift and go to state 77


state 34

    (12) statement -> expression SEMICOLON .

    PRINTLN         reduce using rule 12 (statement -> expression SEMICOLON .)
    IF              reduce using rule 12 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 12 (statement -> expression SEMICOLON .)
    ASYNC           reduce using rule 12 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 12 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 12 (statement -> expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 12 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 12 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 12 (statement -> expression SEMICOLON .)
    MINUS           reduce using rule 12 (statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 12 (statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 12 (statement -> expression SEMICOLON .)
    STRING          reduce using rule 12 (statement -> expression SEMICOLON .)
    CHAR            reduce using rule 12 (statement -> expression SEMICOLON .)
    BOOLEAN         reduce using rule 12 (statement -> expression SEMICOLON .)
    BIT_AND         reduce using rule 12 (statement -> expression SEMICOLON .)
    LBRACKET        reduce using rule 12 (statement -> expression SEMICOLON .)
    LET             reduce using rule 12 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 12 (statement -> expression SEMICOLON .)
    $end            reduce using rule 12 (statement -> expression SEMICOLON .)
    FN              reduce using rule 12 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 12 (statement -> expression SEMICOLON .)


state 35

    (9) expression -> expression DOT . IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression DOT . IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression DOT . IDENTIFIER LPAREN arguments_opt RPAREN
    (102) expression -> expression DOT . INTEGER

    IDENTIFIER      shift and go to state 78
    INTEGER         shift and go to state 79


state 36

    (31) expression -> expression PLUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 80

state 37

    (32) expression -> expression MINUS . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 81

state 38

    (33) expression -> expression TIMES . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 82

state 39

    (34) expression -> expression DIVIDE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 83

state 40

    (35) expression -> expression MOD . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 84

state 41

    (36) expression -> expression RANGE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 85

state 42

    (37) expression -> expression RANGE_INCLUSIVE . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 86

state 43

    (38) expression -> expression EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 87

state 44

    (39) expression -> expression NOT_EQUAL . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 88

state 45

    (40) expression -> expression LESS_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 89

state 46

    (41) expression -> expression GREATER_THAN . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 90

state 47

    (42) expression -> expression LESS_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 91

state 48

    (43) expression -> expression GREATER_THAN_OR_EQUAL_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 92

state 49

    (44) expression -> expression CONJUNCTION . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 93

state 50

    (45) expression -> expression DISJUNCTION . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 94

state 51

    (56) expression -> expression AS . type
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 95

state 52

    (57) statement -> IF expression . LBRACE program_opt RBRACE
    (58) statement -> IF expression . LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    LBRACE          shift and go to state 110
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 53

    (59) statement -> IDENTIFIER ASIGNED_TO . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 111

state 54

    (11) expression -> IDENTIFIER DOUBLE_COLON . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 112


state 55

    (119) expression -> IDENTIFIER LPAREN . arguments_opt RPAREN
    (14) arguments_opt -> . argument_list
    (15) arguments_opt -> . empty
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (5) empty -> .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    arguments_opt                  shift and go to state 113
    argument_list                  shift and go to state 114
    empty                          shift and go to state 115
    expression                     shift and go to state 116

state 56

    (90) expression -> IDENTIFIER LBRACKET . expression RBRACKET
    (91) expression -> IDENTIFIER LBRACKET . INTEGER RANGE INTEGER RBRACKET
    (92) expression -> IDENTIFIER LBRACKET . INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    INTEGER         shift and go to state 118
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 117

state 57

    (93) expression -> IDENTIFIER NOT . LBRACKET element_list RBRACKET

    LBRACKET        shift and go to state 119


state 58

    (60) statement -> WHILE expression . LBRACE program_opt RBRACE
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    LBRACE          shift and go to state 120
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 59

    (61) statement -> ASYNC FN . function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> ASYNC FN . function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (114) function_name -> . IDENTIFIER
    (115) function_name -> . MAIN

    IDENTIFIER      shift and go to state 122
    MAIN            shift and go to state 123

    function_name                  shift and go to state 121

state 60

    (103) statement -> FOR IDENTIFIER . IN expression LBRACE program_opt RBRACE

    IN              shift and go to state 124


state 61

    (116) statement -> maybe_pub FN . function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> maybe_pub FN . function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (114) function_name -> . IDENTIFIER
    (115) function_name -> . MAIN

    IDENTIFIER      shift and go to state 122
    MAIN            shift and go to state 123

    function_name                  shift and go to state 125

state 62

    (118) statement -> RETURN expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 126
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 63

    (28) expression -> CLOSURE_PIPE closure_params . CLOSURE_PIPE closure_body
    (29) expression -> CLOSURE_PIPE closure_params . CLOSURE_PIPE ARROW type closure_body

    CLOSURE_PIPE    shift and go to state 127


state 64

    (19) closure_params -> IDENTIFIER .
    (20) closure_params -> IDENTIFIER . COLON type
    (21) closure_params -> IDENTIFIER . COMMA closure_params
    (22) closure_params -> IDENTIFIER . COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 19 (closure_params -> IDENTIFIER .)
    COLON           shift and go to state 128
    COMMA           shift and go to state 129


state 65

    (47) expression -> MINUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 47 (expression -> MINUS expression .)
    DOT             reduce using rule 47 (expression -> MINUS expression .)
    PLUS            reduce using rule 47 (expression -> MINUS expression .)
    MINUS           reduce using rule 47 (expression -> MINUS expression .)
    TIMES           reduce using rule 47 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 47 (expression -> MINUS expression .)
    MOD             reduce using rule 47 (expression -> MINUS expression .)
    RANGE           reduce using rule 47 (expression -> MINUS expression .)
    RANGE_INCLUSIVE reduce using rule 47 (expression -> MINUS expression .)
    EQUAL_TO        reduce using rule 47 (expression -> MINUS expression .)
    NOT_EQUAL       reduce using rule 47 (expression -> MINUS expression .)
    LESS_THAN       reduce using rule 47 (expression -> MINUS expression .)
    GREATER_THAN    reduce using rule 47 (expression -> MINUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 47 (expression -> MINUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 47 (expression -> MINUS expression .)
    CONJUNCTION     reduce using rule 47 (expression -> MINUS expression .)
    DISJUNCTION     reduce using rule 47 (expression -> MINUS expression .)
    AS              reduce using rule 47 (expression -> MINUS expression .)
    RPAREN          reduce using rule 47 (expression -> MINUS expression .)
    COMMA           reduce using rule 47 (expression -> MINUS expression .)
    LBRACE          reduce using rule 47 (expression -> MINUS expression .)
    RBRACKET        reduce using rule 47 (expression -> MINUS expression .)
    RBRACE          reduce using rule 47 (expression -> MINUS expression .)

  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]
  ! AS              [ shift and go to state 51 ]


state 66

    (54) expression -> BIT_AND expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for CONJUNCTION resolved as shift
  ! shift/reduce conflict for DISJUNCTION resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    SEMICOLON       reduce using rule 54 (expression -> BIT_AND expression .)
    RPAREN          reduce using rule 54 (expression -> BIT_AND expression .)
    COMMA           reduce using rule 54 (expression -> BIT_AND expression .)
    LBRACE          reduce using rule 54 (expression -> BIT_AND expression .)
    RBRACKET        reduce using rule 54 (expression -> BIT_AND expression .)
    RBRACE          reduce using rule 54 (expression -> BIT_AND expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! DOT             [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! PLUS            [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! TIMES           [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! MOD             [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! RANGE           [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! EQUAL_TO        [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! LESS_THAN       [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! GREATER_THAN    [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! CONJUNCTION     [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! DISJUNCTION     [ reduce using rule 54 (expression -> BIT_AND expression .) ]
  ! AS              [ reduce using rule 54 (expression -> BIT_AND expression .) ]


state 67

    (55) expression -> BIT_AND MUT . IDENTIFIER

    IDENTIFIER      shift and go to state 130


state 68

    (88) expression -> LBRACKET element_list . RBRACKET
    (86) element_list -> element_list . COMMA expression

    RBRACKET        shift and go to state 131
    COMMA           shift and go to state 132


state 69

    (89) expression -> LBRACKET expression . SEMICOLON INTEGER RBRACKET
    (87) element_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 133
    RBRACKET        reduce using rule 87 (element_list -> expression .)
    COMMA           reduce using rule 87 (element_list -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 70

    (79) let_decl -> LET maybe_mut . IDENTIFIER maybe_type maybe_init SEMICOLON

    IDENTIFIER      shift and go to state 134


state 71

    (80) maybe_mut -> MUT .

    IDENTIFIER      reduce using rule 80 (maybe_mut -> MUT .)


state 72

    (81) maybe_mut -> empty .

    IDENTIFIER      reduce using rule 81 (maybe_mut -> empty .)


state 73

    (95) const_decl -> CONST IDENTIFIER . COLON type ASIGNED_TO expression SEMICOLON

    COLON           shift and go to state 135


state 74

    (6) statement -> PRINTLN NOT LPAREN . STRING RPAREN SEMICOLON
    (7) statement -> PRINTLN NOT LPAREN . expression RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT LPAREN . STRING COMMA argument_list RPAREN SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    STRING          shift and go to state 136
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 137

state 75

    (30) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RANGE           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    EQUAL_TO        reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    CONJUNCTION     reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    DISJUNCTION     reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    AS              reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 30 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 30 (expression -> LPAREN expression RPAREN .)


state 76

    (101) tuple_value_list -> expression COMMA . tuple_value_list
    (100) tuple_value_list -> . expression
    (101) tuple_value_list -> . expression COMMA tuple_value_list
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 138
    tuple_value_list               shift and go to state 139

state 77

    (99) expression -> LPAREN tuple_value_list RPAREN .

    SEMICOLON       reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    DOT             reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    PLUS            reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    MINUS           reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    TIMES           reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    DIVIDE          reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    MOD             reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    RANGE           reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    RANGE_INCLUSIVE reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    EQUAL_TO        reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    NOT_EQUAL       reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    LESS_THAN       reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    GREATER_THAN    reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    CONJUNCTION     reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    DISJUNCTION     reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    AS              reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    RPAREN          reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    COMMA           reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    LBRACE          reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    RBRACKET        reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)
    RBRACE          reduce using rule 99 (expression -> LPAREN tuple_value_list RPAREN .)


state 78

    (9) expression -> expression DOT IDENTIFIER . LPAREN expression COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER . LPAREN expression RPAREN
    (13) expression -> expression DOT IDENTIFIER . LPAREN arguments_opt RPAREN

    LPAREN          shift and go to state 140


state 79

    (102) expression -> expression DOT INTEGER .

    SEMICOLON       reduce using rule 102 (expression -> expression DOT INTEGER .)
    DOT             reduce using rule 102 (expression -> expression DOT INTEGER .)
    PLUS            reduce using rule 102 (expression -> expression DOT INTEGER .)
    MINUS           reduce using rule 102 (expression -> expression DOT INTEGER .)
    TIMES           reduce using rule 102 (expression -> expression DOT INTEGER .)
    DIVIDE          reduce using rule 102 (expression -> expression DOT INTEGER .)
    MOD             reduce using rule 102 (expression -> expression DOT INTEGER .)
    RANGE           reduce using rule 102 (expression -> expression DOT INTEGER .)
    RANGE_INCLUSIVE reduce using rule 102 (expression -> expression DOT INTEGER .)
    EQUAL_TO        reduce using rule 102 (expression -> expression DOT INTEGER .)
    NOT_EQUAL       reduce using rule 102 (expression -> expression DOT INTEGER .)
    LESS_THAN       reduce using rule 102 (expression -> expression DOT INTEGER .)
    GREATER_THAN    reduce using rule 102 (expression -> expression DOT INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 102 (expression -> expression DOT INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 102 (expression -> expression DOT INTEGER .)
    CONJUNCTION     reduce using rule 102 (expression -> expression DOT INTEGER .)
    DISJUNCTION     reduce using rule 102 (expression -> expression DOT INTEGER .)
    AS              reduce using rule 102 (expression -> expression DOT INTEGER .)
    RPAREN          reduce using rule 102 (expression -> expression DOT INTEGER .)
    COMMA           reduce using rule 102 (expression -> expression DOT INTEGER .)
    LBRACE          reduce using rule 102 (expression -> expression DOT INTEGER .)
    RBRACKET        reduce using rule 102 (expression -> expression DOT INTEGER .)
    RBRACE          reduce using rule 102 (expression -> expression DOT INTEGER .)


state 80

    (31) expression -> expression PLUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 31 (expression -> expression PLUS expression .)
    DOT             reduce using rule 31 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 31 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 31 (expression -> expression PLUS expression .)
    RANGE           reduce using rule 31 (expression -> expression PLUS expression .)
    RANGE_INCLUSIVE reduce using rule 31 (expression -> expression PLUS expression .)
    EQUAL_TO        reduce using rule 31 (expression -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 31 (expression -> expression PLUS expression .)
    LESS_THAN       reduce using rule 31 (expression -> expression PLUS expression .)
    GREATER_THAN    reduce using rule 31 (expression -> expression PLUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 31 (expression -> expression PLUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 31 (expression -> expression PLUS expression .)
    CONJUNCTION     reduce using rule 31 (expression -> expression PLUS expression .)
    DISJUNCTION     reduce using rule 31 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 31 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 31 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 31 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 31 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 31 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! TIMES           [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! AS              [ reduce using rule 31 (expression -> expression PLUS expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 81

    (32) expression -> expression MINUS expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 32 (expression -> expression MINUS expression .)
    DOT             reduce using rule 32 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 32 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 32 (expression -> expression MINUS expression .)
    RANGE           reduce using rule 32 (expression -> expression MINUS expression .)
    RANGE_INCLUSIVE reduce using rule 32 (expression -> expression MINUS expression .)
    EQUAL_TO        reduce using rule 32 (expression -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 32 (expression -> expression MINUS expression .)
    LESS_THAN       reduce using rule 32 (expression -> expression MINUS expression .)
    GREATER_THAN    reduce using rule 32 (expression -> expression MINUS expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 32 (expression -> expression MINUS expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 32 (expression -> expression MINUS expression .)
    CONJUNCTION     reduce using rule 32 (expression -> expression MINUS expression .)
    DISJUNCTION     reduce using rule 32 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 32 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 32 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 32 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 32 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 32 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! TIMES           [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! AS              [ reduce using rule 32 (expression -> expression MINUS expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 82

    (33) expression -> expression TIMES expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 33 (expression -> expression TIMES expression .)
    DOT             reduce using rule 33 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 33 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 33 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 33 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 33 (expression -> expression TIMES expression .)
    MOD             reduce using rule 33 (expression -> expression TIMES expression .)
    RANGE           reduce using rule 33 (expression -> expression TIMES expression .)
    RANGE_INCLUSIVE reduce using rule 33 (expression -> expression TIMES expression .)
    EQUAL_TO        reduce using rule 33 (expression -> expression TIMES expression .)
    NOT_EQUAL       reduce using rule 33 (expression -> expression TIMES expression .)
    LESS_THAN       reduce using rule 33 (expression -> expression TIMES expression .)
    GREATER_THAN    reduce using rule 33 (expression -> expression TIMES expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 33 (expression -> expression TIMES expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 33 (expression -> expression TIMES expression .)
    CONJUNCTION     reduce using rule 33 (expression -> expression TIMES expression .)
    DISJUNCTION     reduce using rule 33 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 33 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 33 (expression -> expression TIMES expression .)
    LBRACE          reduce using rule 33 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 33 (expression -> expression TIMES expression .)
    RBRACE          reduce using rule 33 (expression -> expression TIMES expression .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 33 (expression -> expression TIMES expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 83

    (34) expression -> expression DIVIDE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 34 (expression -> expression DIVIDE expression .)
    DOT             reduce using rule 34 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 34 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 34 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 34 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    MOD             reduce using rule 34 (expression -> expression DIVIDE expression .)
    RANGE           reduce using rule 34 (expression -> expression DIVIDE expression .)
    RANGE_INCLUSIVE reduce using rule 34 (expression -> expression DIVIDE expression .)
    EQUAL_TO        reduce using rule 34 (expression -> expression DIVIDE expression .)
    NOT_EQUAL       reduce using rule 34 (expression -> expression DIVIDE expression .)
    LESS_THAN       reduce using rule 34 (expression -> expression DIVIDE expression .)
    GREATER_THAN    reduce using rule 34 (expression -> expression DIVIDE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 34 (expression -> expression DIVIDE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 34 (expression -> expression DIVIDE expression .)
    CONJUNCTION     reduce using rule 34 (expression -> expression DIVIDE expression .)
    DISJUNCTION     reduce using rule 34 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 34 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 34 (expression -> expression DIVIDE expression .)
    LBRACE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 34 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 34 (expression -> expression DIVIDE expression .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 34 (expression -> expression DIVIDE expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 84

    (35) expression -> expression MOD expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 35 (expression -> expression MOD expression .)
    DOT             reduce using rule 35 (expression -> expression MOD expression .)
    PLUS            reduce using rule 35 (expression -> expression MOD expression .)
    MINUS           reduce using rule 35 (expression -> expression MOD expression .)
    TIMES           reduce using rule 35 (expression -> expression MOD expression .)
    DIVIDE          reduce using rule 35 (expression -> expression MOD expression .)
    MOD             reduce using rule 35 (expression -> expression MOD expression .)
    RANGE           reduce using rule 35 (expression -> expression MOD expression .)
    RANGE_INCLUSIVE reduce using rule 35 (expression -> expression MOD expression .)
    EQUAL_TO        reduce using rule 35 (expression -> expression MOD expression .)
    NOT_EQUAL       reduce using rule 35 (expression -> expression MOD expression .)
    LESS_THAN       reduce using rule 35 (expression -> expression MOD expression .)
    GREATER_THAN    reduce using rule 35 (expression -> expression MOD expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 35 (expression -> expression MOD expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 35 (expression -> expression MOD expression .)
    CONJUNCTION     reduce using rule 35 (expression -> expression MOD expression .)
    DISJUNCTION     reduce using rule 35 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 35 (expression -> expression MOD expression .)
    COMMA           reduce using rule 35 (expression -> expression MOD expression .)
    LBRACE          reduce using rule 35 (expression -> expression MOD expression .)
    RBRACKET        reduce using rule 35 (expression -> expression MOD expression .)
    RBRACE          reduce using rule 35 (expression -> expression MOD expression .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 35 (expression -> expression MOD expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! PLUS            [ shift and go to state 36 ]
  ! MINUS           [ shift and go to state 37 ]
  ! TIMES           [ shift and go to state 38 ]
  ! DIVIDE          [ shift and go to state 39 ]
  ! MOD             [ shift and go to state 40 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 85

    (36) expression -> expression RANGE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 36 (expression -> expression RANGE expression .)
    DOT             reduce using rule 36 (expression -> expression RANGE expression .)
    RANGE           reduce using rule 36 (expression -> expression RANGE expression .)
    RANGE_INCLUSIVE reduce using rule 36 (expression -> expression RANGE expression .)
    EQUAL_TO        reduce using rule 36 (expression -> expression RANGE expression .)
    NOT_EQUAL       reduce using rule 36 (expression -> expression RANGE expression .)
    LESS_THAN       reduce using rule 36 (expression -> expression RANGE expression .)
    GREATER_THAN    reduce using rule 36 (expression -> expression RANGE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 36 (expression -> expression RANGE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 36 (expression -> expression RANGE expression .)
    CONJUNCTION     reduce using rule 36 (expression -> expression RANGE expression .)
    DISJUNCTION     reduce using rule 36 (expression -> expression RANGE expression .)
    RPAREN          reduce using rule 36 (expression -> expression RANGE expression .)
    COMMA           reduce using rule 36 (expression -> expression RANGE expression .)
    LBRACE          reduce using rule 36 (expression -> expression RANGE expression .)
    RBRACKET        reduce using rule 36 (expression -> expression RANGE expression .)
    RBRACE          reduce using rule 36 (expression -> expression RANGE expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! MINUS           [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! TIMES           [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! DIVIDE          [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! MOD             [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! AS              [ reduce using rule 36 (expression -> expression RANGE expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 86

    (37) expression -> expression RANGE_INCLUSIVE expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    DOT             reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RANGE           reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RANGE_INCLUSIVE reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    EQUAL_TO        reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    NOT_EQUAL       reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    LESS_THAN       reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    GREATER_THAN    reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    CONJUNCTION     reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    DISJUNCTION     reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RPAREN          reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    COMMA           reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    LBRACE          reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACKET        reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    RBRACE          reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MINUS           [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! TIMES           [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! MOD             [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! AS              [ reduce using rule 37 (expression -> expression RANGE_INCLUSIVE expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! RANGE           [ shift and go to state 41 ]
  ! RANGE_INCLUSIVE [ shift and go to state 42 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 87

    (38) expression -> expression EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    DOT             reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LESS_THAN       reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RPAREN          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    COMMA           reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    LBRACE          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RBRACKET        reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    RBRACE          reduce using rule 38 (expression -> expression EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 38 (expression -> expression EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 88

    (39) expression -> expression NOT_EQUAL expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    DOT             reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    EQUAL_TO        reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    NOT_EQUAL       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LESS_THAN       reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    GREATER_THAN    reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    CONJUNCTION     reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    DISJUNCTION     reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    COMMA           reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    LBRACE          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RBRACKET        reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    RBRACE          reduce using rule 39 (expression -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! TIMES           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! MOD             [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! RANGE           [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! AS              [ reduce using rule 39 (expression -> expression NOT_EQUAL expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 89

    (40) expression -> expression LESS_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    DOT             reduce using rule 40 (expression -> expression LESS_THAN expression .)
    EQUAL_TO        reduce using rule 40 (expression -> expression LESS_THAN expression .)
    NOT_EQUAL       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LESS_THAN       reduce using rule 40 (expression -> expression LESS_THAN expression .)
    GREATER_THAN    reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> expression LESS_THAN expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 40 (expression -> expression LESS_THAN expression .)
    CONJUNCTION     reduce using rule 40 (expression -> expression LESS_THAN expression .)
    DISJUNCTION     reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RPAREN          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    COMMA           reduce using rule 40 (expression -> expression LESS_THAN expression .)
    LBRACE          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RBRACKET        reduce using rule 40 (expression -> expression LESS_THAN expression .)
    RBRACE          reduce using rule 40 (expression -> expression LESS_THAN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! TIMES           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! MOD             [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! RANGE           [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! AS              [ reduce using rule 40 (expression -> expression LESS_THAN expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 90

    (41) expression -> expression GREATER_THAN expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    DOT             reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    EQUAL_TO        reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    NOT_EQUAL       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LESS_THAN       reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    GREATER_THAN    reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    CONJUNCTION     reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    DISJUNCTION     reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RPAREN          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    COMMA           reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    LBRACE          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RBRACKET        reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    RBRACE          reduce using rule 41 (expression -> expression GREATER_THAN expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! TIMES           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! MOD             [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! RANGE           [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! AS              [ reduce using rule 41 (expression -> expression GREATER_THAN expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 91

    (42) expression -> expression LESS_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DOT             reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LESS_THAN       reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    COMMA           reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    LBRACE          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RBRACKET        reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    RBRACE          reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 42 (expression -> expression LESS_THAN_OR_EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 92

    (43) expression -> expression GREATER_THAN_OR_EQUAL_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DOT             reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    EQUAL_TO        reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    NOT_EQUAL       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LESS_THAN       reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN    reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    CONJUNCTION     reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    DISJUNCTION     reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RPAREN          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    COMMA           reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    LBRACE          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RBRACKET        reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    RBRACE          reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! TIMES           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! MOD             [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE           [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! AS              [ reduce using rule 43 (expression -> expression GREATER_THAN_OR_EQUAL_TO expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! EQUAL_TO        [ shift and go to state 43 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]
  ! LESS_THAN       [ shift and go to state 45 ]
  ! GREATER_THAN    [ shift and go to state 46 ]
  ! LESS_THAN_OR_EQUAL_TO [ shift and go to state 47 ]
  ! GREATER_THAN_OR_EQUAL_TO [ shift and go to state 48 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 93

    (44) expression -> expression CONJUNCTION expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    DOT             reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    CONJUNCTION     reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    DISJUNCTION     reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    RPAREN          reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    COMMA           reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    LBRACE          reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    RBRACKET        reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    RBRACE          reduce using rule 44 (expression -> expression CONJUNCTION expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! TIMES           [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! MOD             [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! RANGE           [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! EQUAL_TO        [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! LESS_THAN       [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! GREATER_THAN    [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! AS              [ reduce using rule 44 (expression -> expression CONJUNCTION expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! CONJUNCTION     [ shift and go to state 49 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 94

    (45) expression -> expression DISJUNCTION expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    DOT             reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    DISJUNCTION     reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    RPAREN          reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    COMMA           reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    LBRACE          reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    RBRACKET        reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    RBRACE          reduce using rule 45 (expression -> expression DISJUNCTION expression .)
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! MINUS           [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! TIMES           [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! DIVIDE          [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! MOD             [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! RANGE           [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! EQUAL_TO        [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! NOT_EQUAL       [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! LESS_THAN       [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! GREATER_THAN    [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! CONJUNCTION     [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! AS              [ reduce using rule 45 (expression -> expression DISJUNCTION expression .) ]
  ! DOT             [ shift and go to state 35 ]
  ! DISJUNCTION     [ shift and go to state 50 ]


state 95

    (56) expression -> expression AS type .

    SEMICOLON       reduce using rule 56 (expression -> expression AS type .)
    DOT             reduce using rule 56 (expression -> expression AS type .)
    PLUS            reduce using rule 56 (expression -> expression AS type .)
    MINUS           reduce using rule 56 (expression -> expression AS type .)
    TIMES           reduce using rule 56 (expression -> expression AS type .)
    DIVIDE          reduce using rule 56 (expression -> expression AS type .)
    MOD             reduce using rule 56 (expression -> expression AS type .)
    RANGE           reduce using rule 56 (expression -> expression AS type .)
    RANGE_INCLUSIVE reduce using rule 56 (expression -> expression AS type .)
    EQUAL_TO        reduce using rule 56 (expression -> expression AS type .)
    NOT_EQUAL       reduce using rule 56 (expression -> expression AS type .)
    LESS_THAN       reduce using rule 56 (expression -> expression AS type .)
    GREATER_THAN    reduce using rule 56 (expression -> expression AS type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 56 (expression -> expression AS type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 56 (expression -> expression AS type .)
    CONJUNCTION     reduce using rule 56 (expression -> expression AS type .)
    DISJUNCTION     reduce using rule 56 (expression -> expression AS type .)
    AS              reduce using rule 56 (expression -> expression AS type .)
    RPAREN          reduce using rule 56 (expression -> expression AS type .)
    COMMA           reduce using rule 56 (expression -> expression AS type .)
    LBRACE          reduce using rule 56 (expression -> expression AS type .)
    RBRACKET        reduce using rule 56 (expression -> expression AS type .)
    RBRACE          reduce using rule 56 (expression -> expression AS type .)


state 96

    (63) type -> TYPE_I32 .

    SEMICOLON       reduce using rule 63 (type -> TYPE_I32 .)
    DOT             reduce using rule 63 (type -> TYPE_I32 .)
    PLUS            reduce using rule 63 (type -> TYPE_I32 .)
    MINUS           reduce using rule 63 (type -> TYPE_I32 .)
    TIMES           reduce using rule 63 (type -> TYPE_I32 .)
    DIVIDE          reduce using rule 63 (type -> TYPE_I32 .)
    MOD             reduce using rule 63 (type -> TYPE_I32 .)
    RANGE           reduce using rule 63 (type -> TYPE_I32 .)
    RANGE_INCLUSIVE reduce using rule 63 (type -> TYPE_I32 .)
    EQUAL_TO        reduce using rule 63 (type -> TYPE_I32 .)
    NOT_EQUAL       reduce using rule 63 (type -> TYPE_I32 .)
    LESS_THAN       reduce using rule 63 (type -> TYPE_I32 .)
    GREATER_THAN    reduce using rule 63 (type -> TYPE_I32 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 63 (type -> TYPE_I32 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 63 (type -> TYPE_I32 .)
    CONJUNCTION     reduce using rule 63 (type -> TYPE_I32 .)
    DISJUNCTION     reduce using rule 63 (type -> TYPE_I32 .)
    AS              reduce using rule 63 (type -> TYPE_I32 .)
    RPAREN          reduce using rule 63 (type -> TYPE_I32 .)
    COMMA           reduce using rule 63 (type -> TYPE_I32 .)
    LBRACE          reduce using rule 63 (type -> TYPE_I32 .)
    RBRACKET        reduce using rule 63 (type -> TYPE_I32 .)
    RBRACE          reduce using rule 63 (type -> TYPE_I32 .)
    CLOSURE_PIPE    reduce using rule 63 (type -> TYPE_I32 .)
    ASIGNED_TO      reduce using rule 63 (type -> TYPE_I32 .)
    IDENTIFIER      reduce using rule 63 (type -> TYPE_I32 .)
    LPAREN          reduce using rule 63 (type -> TYPE_I32 .)
    NOT             reduce using rule 63 (type -> TYPE_I32 .)
    INTEGER         reduce using rule 63 (type -> TYPE_I32 .)
    FLOAT           reduce using rule 63 (type -> TYPE_I32 .)
    STRING          reduce using rule 63 (type -> TYPE_I32 .)
    CHAR            reduce using rule 63 (type -> TYPE_I32 .)
    BOOLEAN         reduce using rule 63 (type -> TYPE_I32 .)
    BIT_AND         reduce using rule 63 (type -> TYPE_I32 .)
    LBRACKET        reduce using rule 63 (type -> TYPE_I32 .)


state 97

    (64) type -> TYPE_U8 .

    SEMICOLON       reduce using rule 64 (type -> TYPE_U8 .)
    DOT             reduce using rule 64 (type -> TYPE_U8 .)
    PLUS            reduce using rule 64 (type -> TYPE_U8 .)
    MINUS           reduce using rule 64 (type -> TYPE_U8 .)
    TIMES           reduce using rule 64 (type -> TYPE_U8 .)
    DIVIDE          reduce using rule 64 (type -> TYPE_U8 .)
    MOD             reduce using rule 64 (type -> TYPE_U8 .)
    RANGE           reduce using rule 64 (type -> TYPE_U8 .)
    RANGE_INCLUSIVE reduce using rule 64 (type -> TYPE_U8 .)
    EQUAL_TO        reduce using rule 64 (type -> TYPE_U8 .)
    NOT_EQUAL       reduce using rule 64 (type -> TYPE_U8 .)
    LESS_THAN       reduce using rule 64 (type -> TYPE_U8 .)
    GREATER_THAN    reduce using rule 64 (type -> TYPE_U8 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 64 (type -> TYPE_U8 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 64 (type -> TYPE_U8 .)
    CONJUNCTION     reduce using rule 64 (type -> TYPE_U8 .)
    DISJUNCTION     reduce using rule 64 (type -> TYPE_U8 .)
    AS              reduce using rule 64 (type -> TYPE_U8 .)
    RPAREN          reduce using rule 64 (type -> TYPE_U8 .)
    COMMA           reduce using rule 64 (type -> TYPE_U8 .)
    LBRACE          reduce using rule 64 (type -> TYPE_U8 .)
    RBRACKET        reduce using rule 64 (type -> TYPE_U8 .)
    RBRACE          reduce using rule 64 (type -> TYPE_U8 .)
    CLOSURE_PIPE    reduce using rule 64 (type -> TYPE_U8 .)
    ASIGNED_TO      reduce using rule 64 (type -> TYPE_U8 .)
    IDENTIFIER      reduce using rule 64 (type -> TYPE_U8 .)
    LPAREN          reduce using rule 64 (type -> TYPE_U8 .)
    NOT             reduce using rule 64 (type -> TYPE_U8 .)
    INTEGER         reduce using rule 64 (type -> TYPE_U8 .)
    FLOAT           reduce using rule 64 (type -> TYPE_U8 .)
    STRING          reduce using rule 64 (type -> TYPE_U8 .)
    CHAR            reduce using rule 64 (type -> TYPE_U8 .)
    BOOLEAN         reduce using rule 64 (type -> TYPE_U8 .)
    BIT_AND         reduce using rule 64 (type -> TYPE_U8 .)
    LBRACKET        reduce using rule 64 (type -> TYPE_U8 .)


state 98

    (65) type -> TYPE_U16 .

    SEMICOLON       reduce using rule 65 (type -> TYPE_U16 .)
    DOT             reduce using rule 65 (type -> TYPE_U16 .)
    PLUS            reduce using rule 65 (type -> TYPE_U16 .)
    MINUS           reduce using rule 65 (type -> TYPE_U16 .)
    TIMES           reduce using rule 65 (type -> TYPE_U16 .)
    DIVIDE          reduce using rule 65 (type -> TYPE_U16 .)
    MOD             reduce using rule 65 (type -> TYPE_U16 .)
    RANGE           reduce using rule 65 (type -> TYPE_U16 .)
    RANGE_INCLUSIVE reduce using rule 65 (type -> TYPE_U16 .)
    EQUAL_TO        reduce using rule 65 (type -> TYPE_U16 .)
    NOT_EQUAL       reduce using rule 65 (type -> TYPE_U16 .)
    LESS_THAN       reduce using rule 65 (type -> TYPE_U16 .)
    GREATER_THAN    reduce using rule 65 (type -> TYPE_U16 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 65 (type -> TYPE_U16 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 65 (type -> TYPE_U16 .)
    CONJUNCTION     reduce using rule 65 (type -> TYPE_U16 .)
    DISJUNCTION     reduce using rule 65 (type -> TYPE_U16 .)
    AS              reduce using rule 65 (type -> TYPE_U16 .)
    RPAREN          reduce using rule 65 (type -> TYPE_U16 .)
    COMMA           reduce using rule 65 (type -> TYPE_U16 .)
    LBRACE          reduce using rule 65 (type -> TYPE_U16 .)
    RBRACKET        reduce using rule 65 (type -> TYPE_U16 .)
    RBRACE          reduce using rule 65 (type -> TYPE_U16 .)
    CLOSURE_PIPE    reduce using rule 65 (type -> TYPE_U16 .)
    ASIGNED_TO      reduce using rule 65 (type -> TYPE_U16 .)
    IDENTIFIER      reduce using rule 65 (type -> TYPE_U16 .)
    LPAREN          reduce using rule 65 (type -> TYPE_U16 .)
    NOT             reduce using rule 65 (type -> TYPE_U16 .)
    INTEGER         reduce using rule 65 (type -> TYPE_U16 .)
    FLOAT           reduce using rule 65 (type -> TYPE_U16 .)
    STRING          reduce using rule 65 (type -> TYPE_U16 .)
    CHAR            reduce using rule 65 (type -> TYPE_U16 .)
    BOOLEAN         reduce using rule 65 (type -> TYPE_U16 .)
    BIT_AND         reduce using rule 65 (type -> TYPE_U16 .)
    LBRACKET        reduce using rule 65 (type -> TYPE_U16 .)


state 99

    (66) type -> TYPE_U32 .

    SEMICOLON       reduce using rule 66 (type -> TYPE_U32 .)
    DOT             reduce using rule 66 (type -> TYPE_U32 .)
    PLUS            reduce using rule 66 (type -> TYPE_U32 .)
    MINUS           reduce using rule 66 (type -> TYPE_U32 .)
    TIMES           reduce using rule 66 (type -> TYPE_U32 .)
    DIVIDE          reduce using rule 66 (type -> TYPE_U32 .)
    MOD             reduce using rule 66 (type -> TYPE_U32 .)
    RANGE           reduce using rule 66 (type -> TYPE_U32 .)
    RANGE_INCLUSIVE reduce using rule 66 (type -> TYPE_U32 .)
    EQUAL_TO        reduce using rule 66 (type -> TYPE_U32 .)
    NOT_EQUAL       reduce using rule 66 (type -> TYPE_U32 .)
    LESS_THAN       reduce using rule 66 (type -> TYPE_U32 .)
    GREATER_THAN    reduce using rule 66 (type -> TYPE_U32 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 66 (type -> TYPE_U32 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 66 (type -> TYPE_U32 .)
    CONJUNCTION     reduce using rule 66 (type -> TYPE_U32 .)
    DISJUNCTION     reduce using rule 66 (type -> TYPE_U32 .)
    AS              reduce using rule 66 (type -> TYPE_U32 .)
    RPAREN          reduce using rule 66 (type -> TYPE_U32 .)
    COMMA           reduce using rule 66 (type -> TYPE_U32 .)
    LBRACE          reduce using rule 66 (type -> TYPE_U32 .)
    RBRACKET        reduce using rule 66 (type -> TYPE_U32 .)
    RBRACE          reduce using rule 66 (type -> TYPE_U32 .)
    CLOSURE_PIPE    reduce using rule 66 (type -> TYPE_U32 .)
    ASIGNED_TO      reduce using rule 66 (type -> TYPE_U32 .)
    IDENTIFIER      reduce using rule 66 (type -> TYPE_U32 .)
    LPAREN          reduce using rule 66 (type -> TYPE_U32 .)
    NOT             reduce using rule 66 (type -> TYPE_U32 .)
    INTEGER         reduce using rule 66 (type -> TYPE_U32 .)
    FLOAT           reduce using rule 66 (type -> TYPE_U32 .)
    STRING          reduce using rule 66 (type -> TYPE_U32 .)
    CHAR            reduce using rule 66 (type -> TYPE_U32 .)
    BOOLEAN         reduce using rule 66 (type -> TYPE_U32 .)
    BIT_AND         reduce using rule 66 (type -> TYPE_U32 .)
    LBRACKET        reduce using rule 66 (type -> TYPE_U32 .)


state 100

    (67) type -> TYPE_U64 .

    SEMICOLON       reduce using rule 67 (type -> TYPE_U64 .)
    DOT             reduce using rule 67 (type -> TYPE_U64 .)
    PLUS            reduce using rule 67 (type -> TYPE_U64 .)
    MINUS           reduce using rule 67 (type -> TYPE_U64 .)
    TIMES           reduce using rule 67 (type -> TYPE_U64 .)
    DIVIDE          reduce using rule 67 (type -> TYPE_U64 .)
    MOD             reduce using rule 67 (type -> TYPE_U64 .)
    RANGE           reduce using rule 67 (type -> TYPE_U64 .)
    RANGE_INCLUSIVE reduce using rule 67 (type -> TYPE_U64 .)
    EQUAL_TO        reduce using rule 67 (type -> TYPE_U64 .)
    NOT_EQUAL       reduce using rule 67 (type -> TYPE_U64 .)
    LESS_THAN       reduce using rule 67 (type -> TYPE_U64 .)
    GREATER_THAN    reduce using rule 67 (type -> TYPE_U64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 67 (type -> TYPE_U64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 67 (type -> TYPE_U64 .)
    CONJUNCTION     reduce using rule 67 (type -> TYPE_U64 .)
    DISJUNCTION     reduce using rule 67 (type -> TYPE_U64 .)
    AS              reduce using rule 67 (type -> TYPE_U64 .)
    RPAREN          reduce using rule 67 (type -> TYPE_U64 .)
    COMMA           reduce using rule 67 (type -> TYPE_U64 .)
    LBRACE          reduce using rule 67 (type -> TYPE_U64 .)
    RBRACKET        reduce using rule 67 (type -> TYPE_U64 .)
    RBRACE          reduce using rule 67 (type -> TYPE_U64 .)
    CLOSURE_PIPE    reduce using rule 67 (type -> TYPE_U64 .)
    ASIGNED_TO      reduce using rule 67 (type -> TYPE_U64 .)
    IDENTIFIER      reduce using rule 67 (type -> TYPE_U64 .)
    LPAREN          reduce using rule 67 (type -> TYPE_U64 .)
    NOT             reduce using rule 67 (type -> TYPE_U64 .)
    INTEGER         reduce using rule 67 (type -> TYPE_U64 .)
    FLOAT           reduce using rule 67 (type -> TYPE_U64 .)
    STRING          reduce using rule 67 (type -> TYPE_U64 .)
    CHAR            reduce using rule 67 (type -> TYPE_U64 .)
    BOOLEAN         reduce using rule 67 (type -> TYPE_U64 .)
    BIT_AND         reduce using rule 67 (type -> TYPE_U64 .)
    LBRACKET        reduce using rule 67 (type -> TYPE_U64 .)


state 101

    (68) type -> TYPE_F64 .

    SEMICOLON       reduce using rule 68 (type -> TYPE_F64 .)
    DOT             reduce using rule 68 (type -> TYPE_F64 .)
    PLUS            reduce using rule 68 (type -> TYPE_F64 .)
    MINUS           reduce using rule 68 (type -> TYPE_F64 .)
    TIMES           reduce using rule 68 (type -> TYPE_F64 .)
    DIVIDE          reduce using rule 68 (type -> TYPE_F64 .)
    MOD             reduce using rule 68 (type -> TYPE_F64 .)
    RANGE           reduce using rule 68 (type -> TYPE_F64 .)
    RANGE_INCLUSIVE reduce using rule 68 (type -> TYPE_F64 .)
    EQUAL_TO        reduce using rule 68 (type -> TYPE_F64 .)
    NOT_EQUAL       reduce using rule 68 (type -> TYPE_F64 .)
    LESS_THAN       reduce using rule 68 (type -> TYPE_F64 .)
    GREATER_THAN    reduce using rule 68 (type -> TYPE_F64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 68 (type -> TYPE_F64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 68 (type -> TYPE_F64 .)
    CONJUNCTION     reduce using rule 68 (type -> TYPE_F64 .)
    DISJUNCTION     reduce using rule 68 (type -> TYPE_F64 .)
    AS              reduce using rule 68 (type -> TYPE_F64 .)
    RPAREN          reduce using rule 68 (type -> TYPE_F64 .)
    COMMA           reduce using rule 68 (type -> TYPE_F64 .)
    LBRACE          reduce using rule 68 (type -> TYPE_F64 .)
    RBRACKET        reduce using rule 68 (type -> TYPE_F64 .)
    RBRACE          reduce using rule 68 (type -> TYPE_F64 .)
    CLOSURE_PIPE    reduce using rule 68 (type -> TYPE_F64 .)
    ASIGNED_TO      reduce using rule 68 (type -> TYPE_F64 .)
    IDENTIFIER      reduce using rule 68 (type -> TYPE_F64 .)
    LPAREN          reduce using rule 68 (type -> TYPE_F64 .)
    NOT             reduce using rule 68 (type -> TYPE_F64 .)
    INTEGER         reduce using rule 68 (type -> TYPE_F64 .)
    FLOAT           reduce using rule 68 (type -> TYPE_F64 .)
    STRING          reduce using rule 68 (type -> TYPE_F64 .)
    CHAR            reduce using rule 68 (type -> TYPE_F64 .)
    BOOLEAN         reduce using rule 68 (type -> TYPE_F64 .)
    BIT_AND         reduce using rule 68 (type -> TYPE_F64 .)
    LBRACKET        reduce using rule 68 (type -> TYPE_F64 .)


state 102

    (69) type -> TYPE_CHAR .

    SEMICOLON       reduce using rule 69 (type -> TYPE_CHAR .)
    DOT             reduce using rule 69 (type -> TYPE_CHAR .)
    PLUS            reduce using rule 69 (type -> TYPE_CHAR .)
    MINUS           reduce using rule 69 (type -> TYPE_CHAR .)
    TIMES           reduce using rule 69 (type -> TYPE_CHAR .)
    DIVIDE          reduce using rule 69 (type -> TYPE_CHAR .)
    MOD             reduce using rule 69 (type -> TYPE_CHAR .)
    RANGE           reduce using rule 69 (type -> TYPE_CHAR .)
    RANGE_INCLUSIVE reduce using rule 69 (type -> TYPE_CHAR .)
    EQUAL_TO        reduce using rule 69 (type -> TYPE_CHAR .)
    NOT_EQUAL       reduce using rule 69 (type -> TYPE_CHAR .)
    LESS_THAN       reduce using rule 69 (type -> TYPE_CHAR .)
    GREATER_THAN    reduce using rule 69 (type -> TYPE_CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 69 (type -> TYPE_CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 69 (type -> TYPE_CHAR .)
    CONJUNCTION     reduce using rule 69 (type -> TYPE_CHAR .)
    DISJUNCTION     reduce using rule 69 (type -> TYPE_CHAR .)
    AS              reduce using rule 69 (type -> TYPE_CHAR .)
    RPAREN          reduce using rule 69 (type -> TYPE_CHAR .)
    COMMA           reduce using rule 69 (type -> TYPE_CHAR .)
    LBRACE          reduce using rule 69 (type -> TYPE_CHAR .)
    RBRACKET        reduce using rule 69 (type -> TYPE_CHAR .)
    RBRACE          reduce using rule 69 (type -> TYPE_CHAR .)
    CLOSURE_PIPE    reduce using rule 69 (type -> TYPE_CHAR .)
    ASIGNED_TO      reduce using rule 69 (type -> TYPE_CHAR .)
    IDENTIFIER      reduce using rule 69 (type -> TYPE_CHAR .)
    LPAREN          reduce using rule 69 (type -> TYPE_CHAR .)
    NOT             reduce using rule 69 (type -> TYPE_CHAR .)
    INTEGER         reduce using rule 69 (type -> TYPE_CHAR .)
    FLOAT           reduce using rule 69 (type -> TYPE_CHAR .)
    STRING          reduce using rule 69 (type -> TYPE_CHAR .)
    CHAR            reduce using rule 69 (type -> TYPE_CHAR .)
    BOOLEAN         reduce using rule 69 (type -> TYPE_CHAR .)
    BIT_AND         reduce using rule 69 (type -> TYPE_CHAR .)
    LBRACKET        reduce using rule 69 (type -> TYPE_CHAR .)


state 103

    (70) type -> TYPE_STRING .

    SEMICOLON       reduce using rule 70 (type -> TYPE_STRING .)
    DOT             reduce using rule 70 (type -> TYPE_STRING .)
    PLUS            reduce using rule 70 (type -> TYPE_STRING .)
    MINUS           reduce using rule 70 (type -> TYPE_STRING .)
    TIMES           reduce using rule 70 (type -> TYPE_STRING .)
    DIVIDE          reduce using rule 70 (type -> TYPE_STRING .)
    MOD             reduce using rule 70 (type -> TYPE_STRING .)
    RANGE           reduce using rule 70 (type -> TYPE_STRING .)
    RANGE_INCLUSIVE reduce using rule 70 (type -> TYPE_STRING .)
    EQUAL_TO        reduce using rule 70 (type -> TYPE_STRING .)
    NOT_EQUAL       reduce using rule 70 (type -> TYPE_STRING .)
    LESS_THAN       reduce using rule 70 (type -> TYPE_STRING .)
    GREATER_THAN    reduce using rule 70 (type -> TYPE_STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 70 (type -> TYPE_STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 70 (type -> TYPE_STRING .)
    CONJUNCTION     reduce using rule 70 (type -> TYPE_STRING .)
    DISJUNCTION     reduce using rule 70 (type -> TYPE_STRING .)
    AS              reduce using rule 70 (type -> TYPE_STRING .)
    RPAREN          reduce using rule 70 (type -> TYPE_STRING .)
    COMMA           reduce using rule 70 (type -> TYPE_STRING .)
    LBRACE          reduce using rule 70 (type -> TYPE_STRING .)
    RBRACKET        reduce using rule 70 (type -> TYPE_STRING .)
    RBRACE          reduce using rule 70 (type -> TYPE_STRING .)
    CLOSURE_PIPE    reduce using rule 70 (type -> TYPE_STRING .)
    ASIGNED_TO      reduce using rule 70 (type -> TYPE_STRING .)
    IDENTIFIER      reduce using rule 70 (type -> TYPE_STRING .)
    LPAREN          reduce using rule 70 (type -> TYPE_STRING .)
    NOT             reduce using rule 70 (type -> TYPE_STRING .)
    INTEGER         reduce using rule 70 (type -> TYPE_STRING .)
    FLOAT           reduce using rule 70 (type -> TYPE_STRING .)
    STRING          reduce using rule 70 (type -> TYPE_STRING .)
    CHAR            reduce using rule 70 (type -> TYPE_STRING .)
    BOOLEAN         reduce using rule 70 (type -> TYPE_STRING .)
    BIT_AND         reduce using rule 70 (type -> TYPE_STRING .)
    LBRACKET        reduce using rule 70 (type -> TYPE_STRING .)


state 104

    (71) type -> TYPE_STR .

    SEMICOLON       reduce using rule 71 (type -> TYPE_STR .)
    DOT             reduce using rule 71 (type -> TYPE_STR .)
    PLUS            reduce using rule 71 (type -> TYPE_STR .)
    MINUS           reduce using rule 71 (type -> TYPE_STR .)
    TIMES           reduce using rule 71 (type -> TYPE_STR .)
    DIVIDE          reduce using rule 71 (type -> TYPE_STR .)
    MOD             reduce using rule 71 (type -> TYPE_STR .)
    RANGE           reduce using rule 71 (type -> TYPE_STR .)
    RANGE_INCLUSIVE reduce using rule 71 (type -> TYPE_STR .)
    EQUAL_TO        reduce using rule 71 (type -> TYPE_STR .)
    NOT_EQUAL       reduce using rule 71 (type -> TYPE_STR .)
    LESS_THAN       reduce using rule 71 (type -> TYPE_STR .)
    GREATER_THAN    reduce using rule 71 (type -> TYPE_STR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 71 (type -> TYPE_STR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 71 (type -> TYPE_STR .)
    CONJUNCTION     reduce using rule 71 (type -> TYPE_STR .)
    DISJUNCTION     reduce using rule 71 (type -> TYPE_STR .)
    AS              reduce using rule 71 (type -> TYPE_STR .)
    RPAREN          reduce using rule 71 (type -> TYPE_STR .)
    COMMA           reduce using rule 71 (type -> TYPE_STR .)
    LBRACE          reduce using rule 71 (type -> TYPE_STR .)
    RBRACKET        reduce using rule 71 (type -> TYPE_STR .)
    RBRACE          reduce using rule 71 (type -> TYPE_STR .)
    CLOSURE_PIPE    reduce using rule 71 (type -> TYPE_STR .)
    ASIGNED_TO      reduce using rule 71 (type -> TYPE_STR .)
    IDENTIFIER      reduce using rule 71 (type -> TYPE_STR .)
    LPAREN          reduce using rule 71 (type -> TYPE_STR .)
    NOT             reduce using rule 71 (type -> TYPE_STR .)
    INTEGER         reduce using rule 71 (type -> TYPE_STR .)
    FLOAT           reduce using rule 71 (type -> TYPE_STR .)
    STRING          reduce using rule 71 (type -> TYPE_STR .)
    CHAR            reduce using rule 71 (type -> TYPE_STR .)
    BOOLEAN         reduce using rule 71 (type -> TYPE_STR .)
    BIT_AND         reduce using rule 71 (type -> TYPE_STR .)
    LBRACKET        reduce using rule 71 (type -> TYPE_STR .)


state 105

    (72) type -> TYPE_BOOL .

    SEMICOLON       reduce using rule 72 (type -> TYPE_BOOL .)
    DOT             reduce using rule 72 (type -> TYPE_BOOL .)
    PLUS            reduce using rule 72 (type -> TYPE_BOOL .)
    MINUS           reduce using rule 72 (type -> TYPE_BOOL .)
    TIMES           reduce using rule 72 (type -> TYPE_BOOL .)
    DIVIDE          reduce using rule 72 (type -> TYPE_BOOL .)
    MOD             reduce using rule 72 (type -> TYPE_BOOL .)
    RANGE           reduce using rule 72 (type -> TYPE_BOOL .)
    RANGE_INCLUSIVE reduce using rule 72 (type -> TYPE_BOOL .)
    EQUAL_TO        reduce using rule 72 (type -> TYPE_BOOL .)
    NOT_EQUAL       reduce using rule 72 (type -> TYPE_BOOL .)
    LESS_THAN       reduce using rule 72 (type -> TYPE_BOOL .)
    GREATER_THAN    reduce using rule 72 (type -> TYPE_BOOL .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 72 (type -> TYPE_BOOL .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 72 (type -> TYPE_BOOL .)
    CONJUNCTION     reduce using rule 72 (type -> TYPE_BOOL .)
    DISJUNCTION     reduce using rule 72 (type -> TYPE_BOOL .)
    AS              reduce using rule 72 (type -> TYPE_BOOL .)
    RPAREN          reduce using rule 72 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 72 (type -> TYPE_BOOL .)
    LBRACE          reduce using rule 72 (type -> TYPE_BOOL .)
    RBRACKET        reduce using rule 72 (type -> TYPE_BOOL .)
    RBRACE          reduce using rule 72 (type -> TYPE_BOOL .)
    CLOSURE_PIPE    reduce using rule 72 (type -> TYPE_BOOL .)
    ASIGNED_TO      reduce using rule 72 (type -> TYPE_BOOL .)
    IDENTIFIER      reduce using rule 72 (type -> TYPE_BOOL .)
    LPAREN          reduce using rule 72 (type -> TYPE_BOOL .)
    NOT             reduce using rule 72 (type -> TYPE_BOOL .)
    INTEGER         reduce using rule 72 (type -> TYPE_BOOL .)
    FLOAT           reduce using rule 72 (type -> TYPE_BOOL .)
    STRING          reduce using rule 72 (type -> TYPE_BOOL .)
    CHAR            reduce using rule 72 (type -> TYPE_BOOL .)
    BOOLEAN         reduce using rule 72 (type -> TYPE_BOOL .)
    BIT_AND         reduce using rule 72 (type -> TYPE_BOOL .)
    LBRACKET        reduce using rule 72 (type -> TYPE_BOOL .)


state 106

    (73) type -> TYPE_TUPLE .

    SEMICOLON       reduce using rule 73 (type -> TYPE_TUPLE .)
    DOT             reduce using rule 73 (type -> TYPE_TUPLE .)
    PLUS            reduce using rule 73 (type -> TYPE_TUPLE .)
    MINUS           reduce using rule 73 (type -> TYPE_TUPLE .)
    TIMES           reduce using rule 73 (type -> TYPE_TUPLE .)
    DIVIDE          reduce using rule 73 (type -> TYPE_TUPLE .)
    MOD             reduce using rule 73 (type -> TYPE_TUPLE .)
    RANGE           reduce using rule 73 (type -> TYPE_TUPLE .)
    RANGE_INCLUSIVE reduce using rule 73 (type -> TYPE_TUPLE .)
    EQUAL_TO        reduce using rule 73 (type -> TYPE_TUPLE .)
    NOT_EQUAL       reduce using rule 73 (type -> TYPE_TUPLE .)
    LESS_THAN       reduce using rule 73 (type -> TYPE_TUPLE .)
    GREATER_THAN    reduce using rule 73 (type -> TYPE_TUPLE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 73 (type -> TYPE_TUPLE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 73 (type -> TYPE_TUPLE .)
    CONJUNCTION     reduce using rule 73 (type -> TYPE_TUPLE .)
    DISJUNCTION     reduce using rule 73 (type -> TYPE_TUPLE .)
    AS              reduce using rule 73 (type -> TYPE_TUPLE .)
    RPAREN          reduce using rule 73 (type -> TYPE_TUPLE .)
    COMMA           reduce using rule 73 (type -> TYPE_TUPLE .)
    LBRACE          reduce using rule 73 (type -> TYPE_TUPLE .)
    RBRACKET        reduce using rule 73 (type -> TYPE_TUPLE .)
    RBRACE          reduce using rule 73 (type -> TYPE_TUPLE .)
    CLOSURE_PIPE    reduce using rule 73 (type -> TYPE_TUPLE .)
    ASIGNED_TO      reduce using rule 73 (type -> TYPE_TUPLE .)
    IDENTIFIER      reduce using rule 73 (type -> TYPE_TUPLE .)
    LPAREN          reduce using rule 73 (type -> TYPE_TUPLE .)
    NOT             reduce using rule 73 (type -> TYPE_TUPLE .)
    INTEGER         reduce using rule 73 (type -> TYPE_TUPLE .)
    FLOAT           reduce using rule 73 (type -> TYPE_TUPLE .)
    STRING          reduce using rule 73 (type -> TYPE_TUPLE .)
    CHAR            reduce using rule 73 (type -> TYPE_TUPLE .)
    BOOLEAN         reduce using rule 73 (type -> TYPE_TUPLE .)
    BIT_AND         reduce using rule 73 (type -> TYPE_TUPLE .)
    LBRACKET        reduce using rule 73 (type -> TYPE_TUPLE .)


state 107

    (74) type -> LBRACKET . type RBRACKET
    (75) type -> LBRACKET . type COMMA INTEGER RBRACKET
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 141

state 108

    (76) type -> BIT_AND . type
    (77) type -> BIT_AND . MUT type
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    MUT             shift and go to state 143
    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 142

state 109

    (96) type -> LPAREN . tuple_type_list RPAREN
    (97) tuple_type_list -> . type
    (98) tuple_type_list -> . type COMMA tuple_type_list
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    tuple_type_list                shift and go to state 144
    type                           shift and go to state 145

state 110

    (57) statement -> IF expression LBRACE . program_opt RBRACE
    (58) statement -> IF expression LBRACE . program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    expression                     shift and go to state 7
    program_opt                    shift and go to state 146
    program                        shift and go to state 147
    empty                          shift and go to state 148
    statement                      shift and go to state 2
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 111

    (59) statement -> IDENTIFIER ASIGNED_TO expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 149
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 112

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 150


state 113

    (119) expression -> IDENTIFIER LPAREN arguments_opt . RPAREN

    RPAREN          shift and go to state 151


state 114

    (14) arguments_opt -> argument_list .
    (16) argument_list -> argument_list . COMMA expression

    RPAREN          reduce using rule 14 (arguments_opt -> argument_list .)
    COMMA           shift and go to state 152


state 115

    (15) arguments_opt -> empty .

    RPAREN          reduce using rule 15 (arguments_opt -> empty .)


state 116

    (17) argument_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    COMMA           reduce using rule 17 (argument_list -> expression .)
    RPAREN          reduce using rule 17 (argument_list -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 117

    (90) expression -> IDENTIFIER LBRACKET expression . RBRACKET
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    RBRACKET        shift and go to state 153
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 118

    (91) expression -> IDENTIFIER LBRACKET INTEGER . RANGE INTEGER RBRACKET
    (92) expression -> IDENTIFIER LBRACKET INTEGER . RANGE_INCLUSIVE INTEGER RBRACKET
    (48) expression -> INTEGER .

  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
    RANGE           shift and go to state 154
    RANGE_INCLUSIVE shift and go to state 155
    RBRACKET        reduce using rule 48 (expression -> INTEGER .)
    DOT             reduce using rule 48 (expression -> INTEGER .)
    PLUS            reduce using rule 48 (expression -> INTEGER .)
    MINUS           reduce using rule 48 (expression -> INTEGER .)
    TIMES           reduce using rule 48 (expression -> INTEGER .)
    DIVIDE          reduce using rule 48 (expression -> INTEGER .)
    MOD             reduce using rule 48 (expression -> INTEGER .)
    EQUAL_TO        reduce using rule 48 (expression -> INTEGER .)
    NOT_EQUAL       reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN       reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN    reduce using rule 48 (expression -> INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 48 (expression -> INTEGER .)
    CONJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    DISJUNCTION     reduce using rule 48 (expression -> INTEGER .)
    AS              reduce using rule 48 (expression -> INTEGER .)

  ! RANGE           [ reduce using rule 48 (expression -> INTEGER .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 48 (expression -> INTEGER .) ]


state 119

    (93) expression -> IDENTIFIER NOT LBRACKET . element_list RBRACKET
    (86) element_list -> . element_list COMMA expression
    (87) element_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    element_list                   shift and go to state 156
    expression                     shift and go to state 157

state 120

    (60) statement -> WHILE expression LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    expression                     shift and go to state 7
    program_opt                    shift and go to state 158
    program                        shift and go to state 147
    empty                          shift and go to state 148
    statement                      shift and go to state 2
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 121

    (61) statement -> ASYNC FN function_name . LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> ASYNC FN function_name . LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 159


state 122

    (114) function_name -> IDENTIFIER .

    LPAREN          reduce using rule 114 (function_name -> IDENTIFIER .)


state 123

    (115) function_name -> MAIN .

    LPAREN          reduce using rule 115 (function_name -> MAIN .)


state 124

    (103) statement -> FOR IDENTIFIER IN . expression LBRACE program_opt RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 160

state 125

    (116) statement -> maybe_pub FN function_name . LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> maybe_pub FN function_name . LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 161


state 126

    (118) statement -> RETURN expression SEMICOLON .

    PRINTLN         reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    ASYNC           reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    BOOLEAN         reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    BIT_AND         reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    LBRACKET        reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    LET             reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    CONST           reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    FN              reduce using rule 118 (statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 118 (statement -> RETURN expression SEMICOLON .)


state 127

    (28) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE . closure_body
    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE . ARROW type closure_body
    (23) closure_body -> . expression
    (24) closure_body -> . LBRACE closure_block_content RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    ARROW           shift and go to state 163
    LBRACE          shift and go to state 165
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    closure_body                   shift and go to state 162
    expression                     shift and go to state 164

state 128

    (20) closure_params -> IDENTIFIER COLON . type
    (22) closure_params -> IDENTIFIER COLON . type COMMA closure_params
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 166

state 129

    (21) closure_params -> IDENTIFIER COMMA . closure_params
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 64

    closure_params                 shift and go to state 167

state 130

    (55) expression -> BIT_AND MUT IDENTIFIER .

    SEMICOLON       reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    DOT             reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    PLUS            reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    MINUS           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    TIMES           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    DIVIDE          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    MOD             reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RANGE           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    EQUAL_TO        reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    NOT_EQUAL       reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN       reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN    reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    CONJUNCTION     reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    DISJUNCTION     reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    AS              reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RPAREN          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    COMMA           reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    LBRACE          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RBRACKET        reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)
    RBRACE          reduce using rule 55 (expression -> BIT_AND MUT IDENTIFIER .)


state 131

    (88) expression -> LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    DOT             reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    PLUS            reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    MINUS           reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    TIMES           reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    DIVIDE          reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    MOD             reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    RANGE           reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    EQUAL_TO        reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    NOT_EQUAL       reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    LESS_THAN       reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    GREATER_THAN    reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    CONJUNCTION     reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    DISJUNCTION     reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    AS              reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    LBRACE          reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 88 (expression -> LBRACKET element_list RBRACKET .)


state 132

    (86) element_list -> element_list COMMA . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 168

state 133

    (89) expression -> LBRACKET expression SEMICOLON . INTEGER RBRACKET

    INTEGER         shift and go to state 169


state 134

    (79) let_decl -> LET maybe_mut IDENTIFIER . maybe_type maybe_init SEMICOLON
    (82) maybe_type -> . COLON type
    (83) maybe_type -> . empty
    (5) empty -> .

    COLON           shift and go to state 171
    ASIGNED_TO      reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_type                     shift and go to state 170
    empty                          shift and go to state 172

state 135

    (95) const_decl -> CONST IDENTIFIER COLON . type ASIGNED_TO expression SEMICOLON
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 173

state 136

    (6) statement -> PRINTLN NOT LPAREN STRING . RPAREN SEMICOLON
    (8) statement -> PRINTLN NOT LPAREN STRING . COMMA argument_list RPAREN SEMICOLON
    (50) expression -> STRING .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 174
    COMMA           shift and go to state 175
    DOT             reduce using rule 50 (expression -> STRING .)
    PLUS            reduce using rule 50 (expression -> STRING .)
    MINUS           reduce using rule 50 (expression -> STRING .)
    TIMES           reduce using rule 50 (expression -> STRING .)
    DIVIDE          reduce using rule 50 (expression -> STRING .)
    MOD             reduce using rule 50 (expression -> STRING .)
    RANGE           reduce using rule 50 (expression -> STRING .)
    RANGE_INCLUSIVE reduce using rule 50 (expression -> STRING .)
    EQUAL_TO        reduce using rule 50 (expression -> STRING .)
    NOT_EQUAL       reduce using rule 50 (expression -> STRING .)
    LESS_THAN       reduce using rule 50 (expression -> STRING .)
    GREATER_THAN    reduce using rule 50 (expression -> STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 50 (expression -> STRING .)
    CONJUNCTION     reduce using rule 50 (expression -> STRING .)
    DISJUNCTION     reduce using rule 50 (expression -> STRING .)
    AS              reduce using rule 50 (expression -> STRING .)

  ! RPAREN          [ reduce using rule 50 (expression -> STRING .) ]


state 137

    (7) statement -> PRINTLN NOT LPAREN expression . RPAREN SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    RPAREN          shift and go to state 176
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 138

    (100) tuple_value_list -> expression .
    (101) tuple_value_list -> expression . COMMA tuple_value_list
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    RPAREN          reduce using rule 100 (tuple_value_list -> expression .)
    COMMA           shift and go to state 76
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 139

    (101) tuple_value_list -> expression COMMA tuple_value_list .

    RPAREN          reduce using rule 101 (tuple_value_list -> expression COMMA tuple_value_list .)


state 140

    (9) expression -> expression DOT IDENTIFIER LPAREN . expression COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER LPAREN . expression RPAREN
    (13) expression -> expression DOT IDENTIFIER LPAREN . arguments_opt RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (14) arguments_opt -> . argument_list
    (15) arguments_opt -> . empty
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (5) empty -> .

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    RPAREN          reduce using rule 5 (empty -> .)

    expression                     shift and go to state 177
    arguments_opt                  shift and go to state 178
    argument_list                  shift and go to state 114
    empty                          shift and go to state 115

state 141

    (74) type -> LBRACKET type . RBRACKET
    (75) type -> LBRACKET type . COMMA INTEGER RBRACKET

    RBRACKET        shift and go to state 179
    COMMA           shift and go to state 180


state 142

    (76) type -> BIT_AND type .

    SEMICOLON       reduce using rule 76 (type -> BIT_AND type .)
    DOT             reduce using rule 76 (type -> BIT_AND type .)
    PLUS            reduce using rule 76 (type -> BIT_AND type .)
    MINUS           reduce using rule 76 (type -> BIT_AND type .)
    TIMES           reduce using rule 76 (type -> BIT_AND type .)
    DIVIDE          reduce using rule 76 (type -> BIT_AND type .)
    MOD             reduce using rule 76 (type -> BIT_AND type .)
    RANGE           reduce using rule 76 (type -> BIT_AND type .)
    RANGE_INCLUSIVE reduce using rule 76 (type -> BIT_AND type .)
    EQUAL_TO        reduce using rule 76 (type -> BIT_AND type .)
    NOT_EQUAL       reduce using rule 76 (type -> BIT_AND type .)
    LESS_THAN       reduce using rule 76 (type -> BIT_AND type .)
    GREATER_THAN    reduce using rule 76 (type -> BIT_AND type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 76 (type -> BIT_AND type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 76 (type -> BIT_AND type .)
    CONJUNCTION     reduce using rule 76 (type -> BIT_AND type .)
    DISJUNCTION     reduce using rule 76 (type -> BIT_AND type .)
    AS              reduce using rule 76 (type -> BIT_AND type .)
    RPAREN          reduce using rule 76 (type -> BIT_AND type .)
    COMMA           reduce using rule 76 (type -> BIT_AND type .)
    LBRACE          reduce using rule 76 (type -> BIT_AND type .)
    RBRACKET        reduce using rule 76 (type -> BIT_AND type .)
    RBRACE          reduce using rule 76 (type -> BIT_AND type .)
    CLOSURE_PIPE    reduce using rule 76 (type -> BIT_AND type .)
    ASIGNED_TO      reduce using rule 76 (type -> BIT_AND type .)
    IDENTIFIER      reduce using rule 76 (type -> BIT_AND type .)
    LPAREN          reduce using rule 76 (type -> BIT_AND type .)
    NOT             reduce using rule 76 (type -> BIT_AND type .)
    INTEGER         reduce using rule 76 (type -> BIT_AND type .)
    FLOAT           reduce using rule 76 (type -> BIT_AND type .)
    STRING          reduce using rule 76 (type -> BIT_AND type .)
    CHAR            reduce using rule 76 (type -> BIT_AND type .)
    BOOLEAN         reduce using rule 76 (type -> BIT_AND type .)
    BIT_AND         reduce using rule 76 (type -> BIT_AND type .)
    LBRACKET        reduce using rule 76 (type -> BIT_AND type .)


state 143

    (77) type -> BIT_AND MUT . type
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 181

state 144

    (96) type -> LPAREN tuple_type_list . RPAREN

    RPAREN          shift and go to state 182


state 145

    (97) tuple_type_list -> type .
    (98) tuple_type_list -> type . COMMA tuple_type_list

    RPAREN          reduce using rule 97 (tuple_type_list -> type .)
    COMMA           shift and go to state 183


state 146

    (57) statement -> IF expression LBRACE program_opt . RBRACE
    (58) statement -> IF expression LBRACE program_opt . RBRACE ELSE LBRACE program_opt RBRACE

    RBRACE          shift and go to state 184


state 147

    (3) program_opt -> program .
    (1) program -> program . statement
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    statement                      shift and go to state 28
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 148

    (4) program_opt -> empty .
    (113) maybe_pub -> empty .

    RBRACE          reduce using rule 4 (program_opt -> empty .)
    FN              reduce using rule 113 (maybe_pub -> empty .)


state 149

    (59) statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .

    PRINTLN         reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    IF              reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    IDENTIFIER      reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    WHILE           reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    ASYNC           reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FOR             reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    RETURN          reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LPAREN          reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    NOT             reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    MINUS           reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    INTEGER         reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FLOAT           reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    STRING          reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CHAR            reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    BOOLEAN         reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    BIT_AND         reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LBRACKET        reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    LET             reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    CONST           reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    $end            reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    FN              reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)
    RBRACE          reduce using rule 59 (statement -> IDENTIFIER ASIGNED_TO expression SEMICOLON .)


state 150

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN . RPAREN

    RPAREN          shift and go to state 185


state 151

    (119) expression -> IDENTIFIER LPAREN arguments_opt RPAREN .

    SEMICOLON       reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DOT             reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    PLUS            reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    MINUS           reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    TIMES           reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DIVIDE          reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    MOD             reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE           reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE_INCLUSIVE reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    EQUAL_TO        reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    NOT_EQUAL       reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN       reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN    reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    CONJUNCTION     reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    DISJUNCTION     reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    AS              reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RPAREN          reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    COMMA           reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    LBRACE          reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACKET        reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACE          reduce using rule 119 (expression -> IDENTIFIER LPAREN arguments_opt RPAREN .)


state 152

    (16) argument_list -> argument_list COMMA . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 186

state 153

    (90) expression -> IDENTIFIER LBRACKET expression RBRACKET .

    SEMICOLON       reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DOT             reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MOD             reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE           reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    EQUAL_TO        reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_THAN       reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_THAN    reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    CONJUNCTION     reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DISJUNCTION     reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    AS              reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 90 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)


state 154

    (91) expression -> IDENTIFIER LBRACKET INTEGER RANGE . INTEGER RBRACKET

    INTEGER         shift and go to state 187


state 155

    (92) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE . INTEGER RBRACKET

    INTEGER         shift and go to state 188


state 156

    (93) expression -> IDENTIFIER NOT LBRACKET element_list . RBRACKET
    (86) element_list -> element_list . COMMA expression

    RBRACKET        shift and go to state 189
    COMMA           shift and go to state 132


state 157

    (87) element_list -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    RBRACKET        reduce using rule 87 (element_list -> expression .)
    COMMA           reduce using rule 87 (element_list -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 158

    (60) statement -> WHILE expression LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 190


state 159

    (61) statement -> ASYNC FN function_name LPAREN . param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> ASYNC FN function_name LPAREN . param_list_opt RPAREN LBRACE program_opt RBRACE
    (104) param_list_opt -> . param_list
    (105) param_list_opt -> . empty
    (106) param_list -> . param_list COMMA param
    (107) param_list -> . param
    (5) empty -> .
    (108) param -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 195

    param_list_opt                 shift and go to state 191
    param_list                     shift and go to state 192
    empty                          shift and go to state 193
    param                          shift and go to state 194

state 160

    (103) statement -> FOR IDENTIFIER IN expression . LBRACE program_opt RBRACE
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    LBRACE          shift and go to state 196
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 161

    (116) statement -> maybe_pub FN function_name LPAREN . param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> maybe_pub FN function_name LPAREN . param_list_opt RPAREN LBRACE program_opt RBRACE
    (104) param_list_opt -> . param_list
    (105) param_list_opt -> . empty
    (106) param_list -> . param_list COMMA param
    (107) param_list -> . param
    (5) empty -> .
    (108) param -> . IDENTIFIER COLON type

    RPAREN          reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 195

    param_list_opt                 shift and go to state 197
    param_list                     shift and go to state 192
    empty                          shift and go to state 193
    param                          shift and go to state 194

state 162

    (28) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .

    SEMICOLON       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DOT             reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    PLUS            reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    MINUS           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    TIMES           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DIVIDE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    MOD             reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RANGE           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RANGE_INCLUSIVE reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    EQUAL_TO        reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    NOT_EQUAL       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LESS_THAN       reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    GREATER_THAN    reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    CONJUNCTION     reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    DISJUNCTION     reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    AS              reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RPAREN          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    COMMA           reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    LBRACE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RBRACKET        reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)
    RBRACE          reduce using rule 28 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body .)


state 163

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW . type closure_body
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 198

state 164

    (23) closure_body -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for RANGE resolved as shift
  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for EQUAL_TO resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO resolved as shift
  ! shift/reduce conflict for CONJUNCTION resolved as shift
  ! shift/reduce conflict for DISJUNCTION resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    SEMICOLON       reduce using rule 23 (closure_body -> expression .)
    RPAREN          reduce using rule 23 (closure_body -> expression .)
    COMMA           reduce using rule 23 (closure_body -> expression .)
    LBRACE          reduce using rule 23 (closure_body -> expression .)
    RBRACKET        reduce using rule 23 (closure_body -> expression .)
    RBRACE          reduce using rule 23 (closure_body -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! DOT             [ reduce using rule 23 (closure_body -> expression .) ]
  ! PLUS            [ reduce using rule 23 (closure_body -> expression .) ]
  ! MINUS           [ reduce using rule 23 (closure_body -> expression .) ]
  ! TIMES           [ reduce using rule 23 (closure_body -> expression .) ]
  ! DIVIDE          [ reduce using rule 23 (closure_body -> expression .) ]
  ! MOD             [ reduce using rule 23 (closure_body -> expression .) ]
  ! RANGE           [ reduce using rule 23 (closure_body -> expression .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 23 (closure_body -> expression .) ]
  ! EQUAL_TO        [ reduce using rule 23 (closure_body -> expression .) ]
  ! NOT_EQUAL       [ reduce using rule 23 (closure_body -> expression .) ]
  ! LESS_THAN       [ reduce using rule 23 (closure_body -> expression .) ]
  ! GREATER_THAN    [ reduce using rule 23 (closure_body -> expression .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 23 (closure_body -> expression .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 23 (closure_body -> expression .) ]
  ! CONJUNCTION     [ reduce using rule 23 (closure_body -> expression .) ]
  ! DISJUNCTION     [ reduce using rule 23 (closure_body -> expression .) ]
  ! AS              [ reduce using rule 23 (closure_body -> expression .) ]


state 165

    (24) closure_body -> LBRACE . closure_block_content RBRACE
    (25) closure_block_content -> . expression
    (26) closure_block_content -> . program expression
    (27) closure_block_content -> . program_opt
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (1) program -> . program statement
    (2) program -> . statement
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (5) empty -> .
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    IDENTIFIER      shift and go to state 203
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    LET             shift and go to state 25
    CONST           shift and go to state 26

    closure_block_content          shift and go to state 199
    expression                     shift and go to state 200
    program                        shift and go to state 201
    program_opt                    shift and go to state 202
    statement                      shift and go to state 2
    empty                          shift and go to state 148
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 166

    (20) closure_params -> IDENTIFIER COLON type .
    (22) closure_params -> IDENTIFIER COLON type . COMMA closure_params

    CLOSURE_PIPE    reduce using rule 20 (closure_params -> IDENTIFIER COLON type .)
    COMMA           shift and go to state 204


state 167

    (21) closure_params -> IDENTIFIER COMMA closure_params .

    CLOSURE_PIPE    reduce using rule 21 (closure_params -> IDENTIFIER COMMA closure_params .)


state 168

    (86) element_list -> element_list COMMA expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    RBRACKET        reduce using rule 86 (element_list -> element_list COMMA expression .)
    COMMA           reduce using rule 86 (element_list -> element_list COMMA expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 169

    (89) expression -> LBRACKET expression SEMICOLON INTEGER . RBRACKET

    RBRACKET        shift and go to state 205


state 170

    (79) let_decl -> LET maybe_mut IDENTIFIER maybe_type . maybe_init SEMICOLON
    (84) maybe_init -> . ASIGNED_TO expression
    (85) maybe_init -> . empty
    (5) empty -> .

    ASIGNED_TO      shift and go to state 207
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_init                     shift and go to state 206
    empty                          shift and go to state 208

state 171

    (82) maybe_type -> COLON . type
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 209

state 172

    (83) maybe_type -> empty .

    ASIGNED_TO      reduce using rule 83 (maybe_type -> empty .)
    SEMICOLON       reduce using rule 83 (maybe_type -> empty .)


state 173

    (95) const_decl -> CONST IDENTIFIER COLON type . ASIGNED_TO expression SEMICOLON

    ASIGNED_TO      shift and go to state 210


state 174

    (6) statement -> PRINTLN NOT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 211


state 175

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA . argument_list RPAREN SEMICOLON
    (16) argument_list -> . argument_list COMMA expression
    (17) argument_list -> . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    argument_list                  shift and go to state 212
    expression                     shift and go to state 116

state 176

    (7) statement -> PRINTLN NOT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 213


state 177

    (9) expression -> expression DOT IDENTIFIER LPAREN expression . COMMA expression RPAREN
    (10) expression -> expression DOT IDENTIFIER LPAREN expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER
    (17) argument_list -> expression .

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for RPAREN resolved as shift
    COMMA           shift and go to state 214
    RPAREN          shift and go to state 215
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51

  ! COMMA           [ reduce using rule 17 (argument_list -> expression .) ]
  ! RPAREN          [ reduce using rule 17 (argument_list -> expression .) ]


state 178

    (13) expression -> expression DOT IDENTIFIER LPAREN arguments_opt . RPAREN

    RPAREN          shift and go to state 216


state 179

    (74) type -> LBRACKET type RBRACKET .

    SEMICOLON       reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    DOT             reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    PLUS            reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    MINUS           reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    TIMES           reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    DIVIDE          reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    MOD             reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    RANGE           reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    EQUAL_TO        reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    NOT_EQUAL       reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    LESS_THAN       reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    GREATER_THAN    reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    CONJUNCTION     reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    DISJUNCTION     reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    AS              reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    COMMA           reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    LBRACE          reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    RBRACE          reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    CLOSURE_PIPE    reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    ASIGNED_TO      reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    IDENTIFIER      reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    LPAREN          reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    NOT             reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    INTEGER         reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    FLOAT           reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    STRING          reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    CHAR            reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    BOOLEAN         reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    BIT_AND         reduce using rule 74 (type -> LBRACKET type RBRACKET .)
    LBRACKET        reduce using rule 74 (type -> LBRACKET type RBRACKET .)


state 180

    (75) type -> LBRACKET type COMMA . INTEGER RBRACKET

    INTEGER         shift and go to state 217


state 181

    (77) type -> BIT_AND MUT type .

    SEMICOLON       reduce using rule 77 (type -> BIT_AND MUT type .)
    DOT             reduce using rule 77 (type -> BIT_AND MUT type .)
    PLUS            reduce using rule 77 (type -> BIT_AND MUT type .)
    MINUS           reduce using rule 77 (type -> BIT_AND MUT type .)
    TIMES           reduce using rule 77 (type -> BIT_AND MUT type .)
    DIVIDE          reduce using rule 77 (type -> BIT_AND MUT type .)
    MOD             reduce using rule 77 (type -> BIT_AND MUT type .)
    RANGE           reduce using rule 77 (type -> BIT_AND MUT type .)
    RANGE_INCLUSIVE reduce using rule 77 (type -> BIT_AND MUT type .)
    EQUAL_TO        reduce using rule 77 (type -> BIT_AND MUT type .)
    NOT_EQUAL       reduce using rule 77 (type -> BIT_AND MUT type .)
    LESS_THAN       reduce using rule 77 (type -> BIT_AND MUT type .)
    GREATER_THAN    reduce using rule 77 (type -> BIT_AND MUT type .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 77 (type -> BIT_AND MUT type .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 77 (type -> BIT_AND MUT type .)
    CONJUNCTION     reduce using rule 77 (type -> BIT_AND MUT type .)
    DISJUNCTION     reduce using rule 77 (type -> BIT_AND MUT type .)
    AS              reduce using rule 77 (type -> BIT_AND MUT type .)
    RPAREN          reduce using rule 77 (type -> BIT_AND MUT type .)
    COMMA           reduce using rule 77 (type -> BIT_AND MUT type .)
    LBRACE          reduce using rule 77 (type -> BIT_AND MUT type .)
    RBRACKET        reduce using rule 77 (type -> BIT_AND MUT type .)
    RBRACE          reduce using rule 77 (type -> BIT_AND MUT type .)
    CLOSURE_PIPE    reduce using rule 77 (type -> BIT_AND MUT type .)
    ASIGNED_TO      reduce using rule 77 (type -> BIT_AND MUT type .)
    IDENTIFIER      reduce using rule 77 (type -> BIT_AND MUT type .)
    LPAREN          reduce using rule 77 (type -> BIT_AND MUT type .)
    NOT             reduce using rule 77 (type -> BIT_AND MUT type .)
    INTEGER         reduce using rule 77 (type -> BIT_AND MUT type .)
    FLOAT           reduce using rule 77 (type -> BIT_AND MUT type .)
    STRING          reduce using rule 77 (type -> BIT_AND MUT type .)
    CHAR            reduce using rule 77 (type -> BIT_AND MUT type .)
    BOOLEAN         reduce using rule 77 (type -> BIT_AND MUT type .)
    BIT_AND         reduce using rule 77 (type -> BIT_AND MUT type .)
    LBRACKET        reduce using rule 77 (type -> BIT_AND MUT type .)


state 182

    (96) type -> LPAREN tuple_type_list RPAREN .

    SEMICOLON       reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    DOT             reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    PLUS            reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    MINUS           reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    TIMES           reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    DIVIDE          reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    MOD             reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    RANGE           reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    RANGE_INCLUSIVE reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    EQUAL_TO        reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    NOT_EQUAL       reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    LESS_THAN       reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    GREATER_THAN    reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    CONJUNCTION     reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    DISJUNCTION     reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    AS              reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    RPAREN          reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    COMMA           reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    LBRACE          reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    RBRACKET        reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    RBRACE          reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    CLOSURE_PIPE    reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    ASIGNED_TO      reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    IDENTIFIER      reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    LPAREN          reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    NOT             reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    INTEGER         reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    FLOAT           reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    STRING          reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    CHAR            reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    BOOLEAN         reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    BIT_AND         reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)
    LBRACKET        reduce using rule 96 (type -> LPAREN tuple_type_list RPAREN .)


state 183

    (98) tuple_type_list -> type COMMA . tuple_type_list
    (97) tuple_type_list -> . type
    (98) tuple_type_list -> . type COMMA tuple_type_list
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 145
    tuple_type_list                shift and go to state 218

state 184

    (57) statement -> IF expression LBRACE program_opt RBRACE .
    (58) statement -> IF expression LBRACE program_opt RBRACE . ELSE LBRACE program_opt RBRACE

    PRINTLN         reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    IF              reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    FOR             reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    NOT             reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    STRING          reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    LET             reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    CONST           reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    $end            reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    FN              reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 57 (statement -> IF expression LBRACE program_opt RBRACE .)
    ELSE            shift and go to state 219


state 185

    (11) expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MOD             reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RANGE           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RANGE_INCLUSIVE reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    EQUAL_TO        reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN       reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN    reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    CONJUNCTION     reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DISJUNCTION     reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    AS              reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 11 (expression -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)


state 186

    (16) argument_list -> argument_list COMMA expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    COMMA           reduce using rule 16 (argument_list -> argument_list COMMA expression .)
    RPAREN          reduce using rule 16 (argument_list -> argument_list COMMA expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 187

    (91) expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER . RBRACKET

    RBRACKET        shift and go to state 220


state 188

    (92) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER . RBRACKET

    RBRACKET        shift and go to state 221


state 189

    (93) expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DOT             reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    PLUS            reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    MINUS           reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    TIMES           reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DIVIDE          reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    MOD             reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RANGE           reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    EQUAL_TO        reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    NOT_EQUAL       reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LESS_THAN       reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    GREATER_THAN    reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    CONJUNCTION     reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    DISJUNCTION     reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    AS              reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    LBRACE          reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 93 (expression -> IDENTIFIER NOT LBRACKET element_list RBRACKET .)


state 190

    (60) statement -> WHILE expression LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    IF              reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    FOR             reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    NOT             reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    STRING          reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    LET             reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    CONST           reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    $end            reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    FN              reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 60 (statement -> WHILE expression LBRACE program_opt RBRACE .)


state 191

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt . RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> ASYNC FN function_name LPAREN param_list_opt . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 222


state 192

    (104) param_list_opt -> param_list .
    (106) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 104 (param_list_opt -> param_list .)
    COMMA           shift and go to state 223


state 193

    (105) param_list_opt -> empty .

    RPAREN          reduce using rule 105 (param_list_opt -> empty .)


state 194

    (107) param_list -> param .

    COMMA           reduce using rule 107 (param_list -> param .)
    RPAREN          reduce using rule 107 (param_list -> param .)


state 195

    (108) param -> IDENTIFIER . COLON type

    COLON           shift and go to state 224


state 196

    (103) statement -> FOR IDENTIFIER IN expression LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    expression                     shift and go to state 7
    program_opt                    shift and go to state 225
    program                        shift and go to state 147
    empty                          shift and go to state 148
    statement                      shift and go to state 2
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 197

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt . RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> maybe_pub FN function_name LPAREN param_list_opt . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 226


state 198

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type . closure_body
    (23) closure_body -> . expression
    (24) closure_body -> . LBRACE closure_block_content RBRACE
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    LBRACE          shift and go to state 165
    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    closure_body                   shift and go to state 227
    expression                     shift and go to state 164

state 199

    (24) closure_body -> LBRACE closure_block_content . RBRACE

    RBRACE          shift and go to state 228


state 200

    (25) closure_block_content -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 25 (closure_block_content -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    SEMICOLON       shift and go to state 34


state 201

    (26) closure_block_content -> program . expression
    (1) program -> program . statement
    (3) program_opt -> program .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    IDENTIFIER      shift and go to state 203
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    expression                     shift and go to state 229
    statement                      shift and go to state 28
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 202

    (27) closure_block_content -> program_opt .

    RBRACE          reduce using rule 27 (closure_block_content -> program_opt .)


state 203

    (11) expression -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (53) expression -> IDENTIFIER .
    (90) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (91) expression -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> IDENTIFIER . NOT LBRACKET element_list RBRACKET
    (119) expression -> IDENTIFIER . LPAREN arguments_opt RPAREN
    (59) statement -> IDENTIFIER . ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> IDENTIFIER .

    DOUBLE_COLON    shift and go to state 54
    DOT             reduce using rule 53 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 53 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 53 (expression -> IDENTIFIER .)
    TIMES           reduce using rule 53 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 53 (expression -> IDENTIFIER .)
    MOD             reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE           reduce using rule 53 (expression -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 53 (expression -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 53 (expression -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN       reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 53 (expression -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 53 (expression -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 53 (expression -> IDENTIFIER .)
    AS              reduce using rule 53 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 53 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 53 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 56
    NOT             shift and go to state 57
    LPAREN          shift and go to state 55
    ASIGNED_TO      shift and go to state 53
    FN              reduce using rule 112 (maybe_pub -> IDENTIFIER .)


state 204

    (22) closure_params -> IDENTIFIER COLON type COMMA . closure_params
    (18) closure_params -> .
    (19) closure_params -> . IDENTIFIER
    (20) closure_params -> . IDENTIFIER COLON type
    (21) closure_params -> . IDENTIFIER COMMA closure_params
    (22) closure_params -> . IDENTIFIER COLON type COMMA closure_params

    CLOSURE_PIPE    reduce using rule 18 (closure_params -> .)
    IDENTIFIER      shift and go to state 64

    closure_params                 shift and go to state 230

state 205

    (89) expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .

    SEMICOLON       reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DOT             reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    PLUS            reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    MINUS           reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    TIMES           reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DIVIDE          reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    MOD             reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RANGE           reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    AS              reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RPAREN          reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    COMMA           reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    LBRACE          reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RBRACKET        reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)
    RBRACE          reduce using rule 89 (expression -> LBRACKET expression SEMICOLON INTEGER RBRACKET .)


state 206

    (79) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init . SEMICOLON

    SEMICOLON       shift and go to state 231


state 207

    (84) maybe_init -> ASIGNED_TO . expression
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 232

state 208

    (85) maybe_init -> empty .

    SEMICOLON       reduce using rule 85 (maybe_init -> empty .)


state 209

    (82) maybe_type -> COLON type .

    ASIGNED_TO      reduce using rule 82 (maybe_type -> COLON type .)
    SEMICOLON       reduce using rule 82 (maybe_type -> COLON type .)


state 210

    (95) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO . expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 233

state 211

    (6) statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .

    PRINTLN         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    ASYNC           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LPAREN          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    NOT             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    MINUS           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    INTEGER         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FLOAT           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    STRING          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CHAR            reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LET             reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CONST           reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    $end            reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FN              reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RBRACE          reduce using rule 6 (statement -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)


state 212

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list . RPAREN SEMICOLON
    (16) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 234
    COMMA           shift and go to state 152


state 213

    (7) statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .

    PRINTLN         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    ASYNC           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    MINUS           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    INTEGER         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FLOAT           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CHAR            reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    LET             reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    CONST           reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    FN              reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> PRINTLN NOT LPAREN expression RPAREN SEMICOLON .)


state 214

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA . expression RPAREN
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN

    IDENTIFIER      shift and go to state 31
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24

    expression                     shift and go to state 235

state 215

    (10) expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DOT             reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    PLUS            reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    MINUS           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    TIMES           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    MOD             reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RANGE           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    EQUAL_TO        reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LESS_THAN       reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    GREATER_THAN    reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    CONJUNCTION     reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    DISJUNCTION     reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    AS              reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RPAREN          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    COMMA           reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    LBRACE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)
    RBRACE          reduce using rule 10 (expression -> expression DOT IDENTIFIER LPAREN expression RPAREN .)


state 216

    (13) expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .

    SEMICOLON       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DOT             reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    PLUS            reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    MINUS           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    TIMES           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DIVIDE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    MOD             reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RANGE_INCLUSIVE reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    EQUAL_TO        reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    NOT_EQUAL       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN       reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN    reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    CONJUNCTION     reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    DISJUNCTION     reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    AS              reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RPAREN          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    COMMA           reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    LBRACE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACKET        reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)
    RBRACE          reduce using rule 13 (expression -> expression DOT IDENTIFIER LPAREN arguments_opt RPAREN .)


state 217

    (75) type -> LBRACKET type COMMA INTEGER . RBRACKET

    RBRACKET        shift and go to state 236


state 218

    (98) tuple_type_list -> type COMMA tuple_type_list .

    RPAREN          reduce using rule 98 (tuple_type_list -> type COMMA tuple_type_list .)


state 219

    (58) statement -> IF expression LBRACE program_opt RBRACE ELSE . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 237


state 220

    (91) expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .

    SEMICOLON       reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DOT             reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    PLUS            reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MINUS           reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    TIMES           reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MOD             reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RANGE           reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    AS              reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RPAREN          reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    COMMA           reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LBRACE          reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACE          reduce using rule 91 (expression -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)


state 221

    (92) expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .

    SEMICOLON       reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DOT             reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    PLUS            reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MINUS           reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    TIMES           reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MOD             reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RANGE           reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    AS              reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RPAREN          reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    COMMA           reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LBRACE          reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACE          reduce using rule 92 (expression -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)


state 222

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN . ARROW type LBRACE function_body RBRACE
    (62) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN . LBRACE program_opt RBRACE

    ARROW           shift and go to state 238
    LBRACE          shift and go to state 239


state 223

    (106) param_list -> param_list COMMA . param
    (108) param -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 195

    param                          shift and go to state 240

state 224

    (108) param -> IDENTIFIER COLON . type
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 241

state 225

    (103) statement -> FOR IDENTIFIER IN expression LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 242


state 226

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN . ARROW type LBRACE function_body RBRACE
    (117) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN . LBRACE program_opt RBRACE

    ARROW           shift and go to state 243
    LBRACE          shift and go to state 244


state 227

    (29) expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .

    SEMICOLON       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DOT             reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    PLUS            reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    MINUS           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    TIMES           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DIVIDE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    MOD             reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RANGE           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RANGE_INCLUSIVE reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    EQUAL_TO        reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    NOT_EQUAL       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LESS_THAN       reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    GREATER_THAN    reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    CONJUNCTION     reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    DISJUNCTION     reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    AS              reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RPAREN          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    COMMA           reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    LBRACE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RBRACKET        reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)
    RBRACE          reduce using rule 29 (expression -> CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body .)


state 228

    (24) closure_body -> LBRACE closure_block_content RBRACE .

    DOT             reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    PLUS            reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    MINUS           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    TIMES           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    DIVIDE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    MOD             reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RANGE           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RANGE_INCLUSIVE reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    EQUAL_TO        reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    NOT_EQUAL       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LESS_THAN       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    GREATER_THAN    reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    CONJUNCTION     reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    DISJUNCTION     reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    AS              reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    SEMICOLON       reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RPAREN          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    COMMA           reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    LBRACE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RBRACKET        reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)
    RBRACE          reduce using rule 24 (closure_body -> LBRACE closure_block_content RBRACE .)


state 229

    (26) closure_block_content -> program expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 26 (closure_block_content -> program expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    SEMICOLON       shift and go to state 34


state 230

    (22) closure_params -> IDENTIFIER COLON type COMMA closure_params .

    CLOSURE_PIPE    reduce using rule 22 (closure_params -> IDENTIFIER COLON type COMMA closure_params .)


state 231

    (79) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .

    PRINTLN         reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IF              reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IDENTIFIER      reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    WHILE           reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    ASYNC           reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FOR             reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RETURN          reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LPAREN          reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    NOT             reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    MINUS           reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    INTEGER         reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FLOAT           reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    STRING          reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CHAR            reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    BOOLEAN         reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    BIT_AND         reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LBRACKET        reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LET             reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CONST           reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    $end            reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FN              reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RBRACE          reduce using rule 79 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)


state 232

    (84) maybe_init -> ASIGNED_TO expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       reduce using rule 84 (maybe_init -> ASIGNED_TO expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 233

    (95) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression . SEMICOLON
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    SEMICOLON       shift and go to state 245
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 234

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 246


state 235

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression . RPAREN
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER

    RPAREN          shift and go to state 247
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51


state 236

    (75) type -> LBRACKET type COMMA INTEGER RBRACKET .

    SEMICOLON       reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    DOT             reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    PLUS            reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    MINUS           reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    TIMES           reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    DIVIDE          reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    MOD             reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RANGE           reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    EQUAL_TO        reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    AS              reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RPAREN          reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    COMMA           reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LBRACE          reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RBRACKET        reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    RBRACE          reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    CLOSURE_PIPE    reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    ASIGNED_TO      reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    IDENTIFIER      reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LPAREN          reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    NOT             reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    INTEGER         reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    FLOAT           reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    STRING          reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    CHAR            reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    BOOLEAN         reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    BIT_AND         reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)
    LBRACKET        reduce using rule 75 (type -> LBRACKET type COMMA INTEGER RBRACKET .)


state 237

    (58) statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    expression                     shift and go to state 7
    program_opt                    shift and go to state 248
    program                        shift and go to state 147
    empty                          shift and go to state 148
    statement                      shift and go to state 2
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 238

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW . type LBRACE function_body RBRACE
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 249

state 239

    (62) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    program_opt                    shift and go to state 250
    program                        shift and go to state 147
    empty                          shift and go to state 148
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 240

    (106) param_list -> param_list COMMA param .

    COMMA           reduce using rule 106 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 106 (param_list -> param_list COMMA param .)


state 241

    (108) param -> IDENTIFIER COLON type .

    COMMA           reduce using rule 108 (param -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 108 (param -> IDENTIFIER COLON type .)


state 242

    (103) statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    IF              reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FOR             reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    NOT             reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    STRING          reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    LET             reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    CONST           reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    $end            reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    FN              reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 103 (statement -> FOR IDENTIFIER IN expression LBRACE program_opt RBRACE .)


state 243

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW . type LBRACE function_body RBRACE
    (63) type -> . TYPE_I32
    (64) type -> . TYPE_U8
    (65) type -> . TYPE_U16
    (66) type -> . TYPE_U32
    (67) type -> . TYPE_U64
    (68) type -> . TYPE_F64
    (69) type -> . TYPE_CHAR
    (70) type -> . TYPE_STRING
    (71) type -> . TYPE_STR
    (72) type -> . TYPE_BOOL
    (73) type -> . TYPE_TUPLE
    (74) type -> . LBRACKET type RBRACKET
    (75) type -> . LBRACKET type COMMA INTEGER RBRACKET
    (76) type -> . BIT_AND type
    (77) type -> . BIT_AND MUT type
    (96) type -> . LPAREN tuple_type_list RPAREN

    TYPE_I32        shift and go to state 96
    TYPE_U8         shift and go to state 97
    TYPE_U16        shift and go to state 98
    TYPE_U32        shift and go to state 99
    TYPE_U64        shift and go to state 100
    TYPE_F64        shift and go to state 101
    TYPE_CHAR       shift and go to state 102
    TYPE_STRING     shift and go to state 103
    TYPE_STR        shift and go to state 104
    TYPE_BOOL       shift and go to state 105
    TYPE_TUPLE      shift and go to state 106
    LBRACKET        shift and go to state 107
    BIT_AND         shift and go to state 108
    LPAREN          shift and go to state 109

    type                           shift and go to state 251

state 244

    (117) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program statement
    (2) program -> . statement
    (5) empty -> .
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    LET             shift and go to state 25
    CONST           shift and go to state 26

    maybe_pub                      shift and go to state 15
    program_opt                    shift and go to state 252
    program                        shift and go to state 147
    empty                          shift and go to state 148
    statement                      shift and go to state 2
    expression                     shift and go to state 7
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13

state 245

    (95) const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .

    PRINTLN         reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    IF              reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    IDENTIFIER      reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    WHILE           reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    ASYNC           reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FOR             reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    RETURN          reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LPAREN          reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    NOT             reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    MINUS           reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    INTEGER         reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FLOAT           reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    STRING          reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CHAR            reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    BOOLEAN         reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    BIT_AND         reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LBRACKET        reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    LET             reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    CONST           reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    $end            reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    FN              reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)
    RBRACE          reduce using rule 95 (const_decl -> CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON .)


state 246

    (8) statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .

    PRINTLN         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    IF              reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    ASYNC           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FOR             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    RETURN          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CLOSURE_PIPE    reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LPAREN          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    NOT             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    MINUS           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    INTEGER         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FLOAT           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    STRING          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CHAR            reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    BIT_AND         reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LBRACKET        reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    LET             reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    CONST           reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    $end            reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    FN              reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 8 (statement -> PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON .)


state 247

    (9) expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .

    SEMICOLON       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DOT             reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    PLUS            reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    MINUS           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    TIMES           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DIVIDE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    MOD             reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RANGE           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RANGE_INCLUSIVE reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    EQUAL_TO        reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    NOT_EQUAL       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LESS_THAN       reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    GREATER_THAN    reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    CONJUNCTION     reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    DISJUNCTION     reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    AS              reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RPAREN          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    COMMA           reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    LBRACE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RBRACKET        reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)
    RBRACE          reduce using rule 9 (expression -> expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN .)


state 248

    (58) statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 253


state 249

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type . LBRACE function_body RBRACE

    LBRACE          shift and go to state 254


state 250

    (62) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 255


state 251

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type . LBRACE function_body RBRACE

    LBRACE          shift and go to state 256


state 252

    (117) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 257


state 253

    (58) statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    IF              reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    FOR             reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    NOT             reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    STRING          reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    LET             reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    CONST           reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    $end            reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    FN              reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 58 (statement -> IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE .)


state 254

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE . function_body RBRACE
    (109) function_body -> . program expression
    (110) function_body -> . expression
    (111) function_body -> . program_opt
    (1) program -> . program statement
    (2) program -> . statement
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (5) empty -> .
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    IDENTIFIER      shift and go to state 203
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    LET             shift and go to state 25
    CONST           shift and go to state 26

    function_body                  shift and go to state 258
    program                        shift and go to state 259
    expression                     shift and go to state 260
    program_opt                    shift and go to state 261
    statement                      shift and go to state 2
    empty                          shift and go to state 148
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15

state 255

    (62) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    FOR             reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    NOT             reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    STRING          reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 62 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)


state 256

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE . function_body RBRACE
    (109) function_body -> . program expression
    (110) function_body -> . expression
    (111) function_body -> . program_opt
    (1) program -> . program statement
    (2) program -> . statement
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (5) empty -> .
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty

    IDENTIFIER      shift and go to state 203
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    LET             shift and go to state 25
    CONST           shift and go to state 26

    maybe_pub                      shift and go to state 15
    function_body                  shift and go to state 262
    program                        shift and go to state 259
    expression                     shift and go to state 260
    program_opt                    shift and go to state 261
    statement                      shift and go to state 2
    empty                          shift and go to state 148
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13

state 257

    (117) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    WHILE           reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    ASYNC           reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    FOR             reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    CLOSURE_PIPE    reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    LPAREN          reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    NOT             reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    MINUS           reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    INTEGER         reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    FLOAT           reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    STRING          reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    CHAR            reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    BOOLEAN         reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    BIT_AND         reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    LBRACKET        reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 117 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE .)


state 258

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body . RBRACE

    RBRACE          shift and go to state 263


state 259

    (109) function_body -> program . expression
    (1) program -> program . statement
    (3) program_opt -> program .
    (9) expression -> . expression DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> . expression DOT IDENTIFIER LPAREN expression RPAREN
    (11) expression -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (13) expression -> . expression DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (28) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE closure_body
    (29) expression -> . CLOSURE_PIPE closure_params CLOSURE_PIPE ARROW type closure_body
    (30) expression -> . LPAREN expression RPAREN
    (31) expression -> . expression PLUS expression
    (32) expression -> . expression MINUS expression
    (33) expression -> . expression TIMES expression
    (34) expression -> . expression DIVIDE expression
    (35) expression -> . expression MOD expression
    (36) expression -> . expression RANGE expression
    (37) expression -> . expression RANGE_INCLUSIVE expression
    (38) expression -> . expression EQUAL_TO expression
    (39) expression -> . expression NOT_EQUAL expression
    (40) expression -> . expression LESS_THAN expression
    (41) expression -> . expression GREATER_THAN expression
    (42) expression -> . expression LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> . expression GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> . expression CONJUNCTION expression
    (45) expression -> . expression DISJUNCTION expression
    (46) expression -> . NOT expression
    (47) expression -> . MINUS expression
    (48) expression -> . INTEGER
    (49) expression -> . FLOAT
    (50) expression -> . STRING
    (51) expression -> . CHAR
    (52) expression -> . BOOLEAN
    (53) expression -> . IDENTIFIER
    (54) expression -> . BIT_AND expression
    (55) expression -> . BIT_AND MUT IDENTIFIER
    (56) expression -> . expression AS type
    (88) expression -> . LBRACKET element_list RBRACKET
    (89) expression -> . LBRACKET expression SEMICOLON INTEGER RBRACKET
    (90) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (91) expression -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (92) expression -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (93) expression -> . IDENTIFIER NOT LBRACKET element_list RBRACKET
    (99) expression -> . LPAREN tuple_value_list RPAREN
    (102) expression -> . expression DOT INTEGER
    (119) expression -> . IDENTIFIER LPAREN arguments_opt RPAREN
    (6) statement -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) statement -> . PRINTLN NOT LPAREN expression RPAREN SEMICOLON
    (8) statement -> . PRINTLN NOT LPAREN STRING COMMA argument_list RPAREN SEMICOLON
    (12) statement -> . expression SEMICOLON
    (57) statement -> . IF expression LBRACE program_opt RBRACE
    (58) statement -> . IF expression LBRACE program_opt RBRACE ELSE LBRACE program_opt RBRACE
    (59) statement -> . IDENTIFIER ASIGNED_TO expression SEMICOLON
    (60) statement -> . WHILE expression LBRACE program_opt RBRACE
    (61) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (62) statement -> . ASYNC FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (78) statement -> . let_decl
    (94) statement -> . const_decl
    (103) statement -> . FOR IDENTIFIER IN expression LBRACE program_opt RBRACE
    (116) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE
    (117) statement -> . maybe_pub FN function_name LPAREN param_list_opt RPAREN LBRACE program_opt RBRACE
    (118) statement -> . RETURN expression SEMICOLON
    (79) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (95) const_decl -> . CONST IDENTIFIER COLON type ASIGNED_TO expression SEMICOLON
    (112) maybe_pub -> . IDENTIFIER
    (113) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    IDENTIFIER      shift and go to state 203
    CLOSURE_PIPE    shift and go to state 17
    LPAREN          shift and go to state 5
    NOT             shift and go to state 4
    MINUS           shift and go to state 18
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 6
    CHAR            shift and go to state 21
    BOOLEAN         shift and go to state 22
    BIT_AND         shift and go to state 23
    LBRACKET        shift and go to state 24
    PRINTLN         shift and go to state 3
    IF              shift and go to state 8
    WHILE           shift and go to state 10
    ASYNC           shift and go to state 11
    FOR             shift and go to state 14
    RETURN          shift and go to state 16
    LET             shift and go to state 25
    CONST           shift and go to state 26
    FN              reduce using rule 5 (empty -> .)

    expression                     shift and go to state 264
    statement                      shift and go to state 28
    let_decl                       shift and go to state 12
    const_decl                     shift and go to state 13
    maybe_pub                      shift and go to state 15
    empty                          shift and go to state 27

state 260

    (110) function_body -> expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 110 (function_body -> expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    SEMICOLON       shift and go to state 34


state 261

    (111) function_body -> program_opt .

    RBRACE          reduce using rule 111 (function_body -> program_opt .)


state 262

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body . RBRACE

    RBRACE          shift and go to state 265


state 263

    (61) statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .

    PRINTLN         reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    IF              reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    IDENTIFIER      reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    WHILE           reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    ASYNC           reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    FOR             reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    RETURN          reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    CLOSURE_PIPE    reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    LPAREN          reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    NOT             reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    MINUS           reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    INTEGER         reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    FLOAT           reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    STRING          reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    CHAR            reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    BOOLEAN         reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    BIT_AND         reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    LBRACKET        reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    LET             reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    CONST           reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    $end            reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    FN              reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    RBRACE          reduce using rule 61 (statement -> ASYNC FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)


state 264

    (109) function_body -> program expression .
    (9) expression -> expression . DOT IDENTIFIER LPAREN expression COMMA expression RPAREN
    (10) expression -> expression . DOT IDENTIFIER LPAREN expression RPAREN
    (13) expression -> expression . DOT IDENTIFIER LPAREN arguments_opt RPAREN
    (31) expression -> expression . PLUS expression
    (32) expression -> expression . MINUS expression
    (33) expression -> expression . TIMES expression
    (34) expression -> expression . DIVIDE expression
    (35) expression -> expression . MOD expression
    (36) expression -> expression . RANGE expression
    (37) expression -> expression . RANGE_INCLUSIVE expression
    (38) expression -> expression . EQUAL_TO expression
    (39) expression -> expression . NOT_EQUAL expression
    (40) expression -> expression . LESS_THAN expression
    (41) expression -> expression . GREATER_THAN expression
    (42) expression -> expression . LESS_THAN_OR_EQUAL_TO expression
    (43) expression -> expression . GREATER_THAN_OR_EQUAL_TO expression
    (44) expression -> expression . CONJUNCTION expression
    (45) expression -> expression . DISJUNCTION expression
    (56) expression -> expression . AS type
    (102) expression -> expression . DOT INTEGER
    (12) statement -> expression . SEMICOLON

    RBRACE          reduce using rule 109 (function_body -> program expression .)
    DOT             shift and go to state 35
    PLUS            shift and go to state 36
    MINUS           shift and go to state 37
    TIMES           shift and go to state 38
    DIVIDE          shift and go to state 39
    MOD             shift and go to state 40
    RANGE           shift and go to state 41
    RANGE_INCLUSIVE shift and go to state 42
    EQUAL_TO        shift and go to state 43
    NOT_EQUAL       shift and go to state 44
    LESS_THAN       shift and go to state 45
    GREATER_THAN    shift and go to state 46
    LESS_THAN_OR_EQUAL_TO shift and go to state 47
    GREATER_THAN_OR_EQUAL_TO shift and go to state 48
    CONJUNCTION     shift and go to state 49
    DISJUNCTION     shift and go to state 50
    AS              shift and go to state 51
    SEMICOLON       shift and go to state 34


state 265

    (116) statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .

    PRINTLN         reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    IF              reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    IDENTIFIER      reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    WHILE           reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    ASYNC           reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    FOR             reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    RETURN          reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    CLOSURE_PIPE    reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    LPAREN          reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    NOT             reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    MINUS           reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    INTEGER         reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    FLOAT           reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    STRING          reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    CHAR            reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    BOOLEAN         reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    BIT_AND         reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    LBRACKET        reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    LET             reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    CONST           reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    $end            reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    FN              reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)
    RBRACE          reduce using rule 116 (statement -> maybe_pub FN function_name LPAREN param_list_opt RPAREN ARROW type LBRACE function_body RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 32 resolved as shift
WARNING: shift/reduce conflict for DOT in state 66 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 66 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 66 resolved as shift
WARNING: shift/reduce conflict for MOD in state 66 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 66 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 66 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 66 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 66 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 66 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 66 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_OR_EQUAL_TO in state 66 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO in state 66 resolved as shift
WARNING: shift/reduce conflict for CONJUNCTION in state 66 resolved as shift
WARNING: shift/reduce conflict for DISJUNCTION in state 66 resolved as shift
WARNING: shift/reduce conflict for AS in state 66 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 118 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 118 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 136 resolved as shift
WARNING: shift/reduce conflict for DOT in state 164 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 164 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 164 resolved as shift
WARNING: shift/reduce conflict for MOD in state 164 resolved as shift
WARNING: shift/reduce conflict for RANGE in state 164 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 164 resolved as shift
WARNING: shift/reduce conflict for EQUAL_TO in state 164 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 164 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 164 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 164 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_OR_EQUAL_TO in state 164 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_OR_EQUAL_TO in state 164 resolved as shift
WARNING: shift/reduce conflict for CONJUNCTION in state 164 resolved as shift
WARNING: shift/reduce conflict for DISJUNCTION in state 164 resolved as shift
WARNING: shift/reduce conflict for AS in state 164 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 177 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 177 resolved as shift
