Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BIT_NOT
    BIT_OR
    BIT_XOR
    BREAK
    CONTINUE
    DIVIDE_EQUAL
    ELSE
    ENUM
    FOR
    IN
    LOOP
    MATCH
    MINUS_EQUAL
    MOD_EQUAL
    PIPE
    PLUS_EQUAL
    SHIFT_LEFT
    SHIFT_RIGHT
    THEN
    TIMES_EQUAL
    WHERE
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> program sentencia
Rule 2     program -> sentencia
Rule 3     program_opt -> program
Rule 4     program_opt -> empty
Rule 5     empty -> <empty>
Rule 6     sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
Rule 7     sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
Rule 8     expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
Rule 9     expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
Rule 10    argumentos_opt -> lista_argumentos
Rule 11    argumentos_opt -> empty
Rule 12    lista_argumentos -> lista_argumentos COMMA expresion
Rule 13    lista_argumentos -> expresion
Rule 14    expresion -> LPAREN expresion RPAREN
Rule 15    expresion -> expresion PLUS expresion
Rule 16    expresion -> expresion MINUS expresion
Rule 17    expresion -> expresion TIMES expresion
Rule 18    expresion -> expresion DIVIDE expresion
Rule 19    expresion -> expresion MOD expresion
Rule 20    expresion -> NOT expresion
Rule 21    expresion -> INTEGER
Rule 22    expresion -> FLOAT
Rule 23    expresion -> STRING
Rule 24    expresion -> CHAR
Rule 25    expresion -> BOOLEAN
Rule 26    expresion -> IDENTIFIER
Rule 27    expresion -> BIT_AND expresion
Rule 28    expresion -> BIT_AND MUT IDENTIFIER
Rule 29    expresion -> expresion AS tipo
Rule 30    condicion -> expresion EQUAL_TO expresion
Rule 31    condicion -> expresion NOT_EQUAL expresion
Rule 32    condicion -> expresion LESS_THAN expresion
Rule 33    condicion -> expresion GREATER_THAN expresion
Rule 34    condicion -> expresion LESS_THAN_OR_EQUAL_TO expresion
Rule 35    condicion -> expresion GREATER_THAN_OR_EQUAL_TO expresion
Rule 36    condicion -> condicion CONJUNCTION condicion
Rule 37    condicion -> condicion DISJUNCTION condicion
Rule 38    condicion -> NOT condicion
Rule 39    condicion -> LPAREN condicion RPAREN
Rule 40    sentencia -> IF condicion LBRACE program_opt RBRACE
Rule 41    tipo -> TYPE_I32
Rule 42    tipo -> TYPE_U64
Rule 43    tipo -> TYPE_F64
Rule 44    tipo -> TYPE_CHAR
Rule 45    tipo -> TYPE_STRING
Rule 46    tipo -> TYPE_BOOL
Rule 47    tipo -> TYPE_TUPLE
Rule 48    tipo -> LBRACKET tipo RBRACKET
Rule 49    tipo -> BIT_AND tipo
Rule 50    tipo -> BIT_AND MUT tipo
Rule 51    sentencia -> let_decl
Rule 52    let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
Rule 53    maybe_mut -> MUT
Rule 54    maybe_mut -> empty
Rule 55    maybe_type -> COLON tipo
Rule 56    maybe_type -> empty
Rule 57    maybe_init -> ASIGNED_TO expresion
Rule 58    maybe_init -> empty
Rule 59    lista_elementos -> lista_elementos COMMA expresion
Rule 60    lista_elementos -> expresion
Rule 61    expresion -> LBRACKET lista_elementos RBRACKET
Rule 62    expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET
Rule 63    expresion -> IDENTIFIER LBRACKET expresion RBRACKET
Rule 64    expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
Rule 65    expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
Rule 66    expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
Rule 67    sentencia -> const_decl
Rule 68    const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
Rule 69    tipo -> LPAREN lista_tipos_tupla RPAREN
Rule 70    lista_tipos_tupla -> tipo
Rule 71    lista_tipos_tupla -> tipo COMMA lista_tipos_tupla
Rule 72    expresion -> LPAREN lista_valores_tupla RPAREN
Rule 73    lista_valores_tupla -> expresion
Rule 74    lista_valores_tupla -> expresion COMMA lista_valores_tupla
Rule 75    expresion -> IDENTIFIER DOT INTEGER
Rule 76    maybe_pub -> IDENTIFIER
Rule 77    maybe_pub -> empty
Rule 78    nombre_fn -> IDENTIFIER
Rule 79    nombre_fn -> MAIN
Rule 80    sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
Rule 81    sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
Rule 82    sentencia -> RETURN expresion SEMICOLON

Terminals, with rules where they appear

ARROW                : 
AS                   : 29
ASIGNED_TO           : 57 68
BIT_AND              : 27 28 49 50
BIT_NOT              : 
BIT_OR               : 
BIT_XOR              : 
BOOLEAN              : 25
BREAK                : 
CHAR                 : 24
COLON                : 55 68
COMMA                : 12 59 71 74
CONJUNCTION          : 36
CONST                : 68
CONTINUE             : 
DISJUNCTION          : 37
DIVIDE               : 18
DIVIDE_EQUAL         : 
DOT                  : 9 75
DOUBLE_COLON         : 8
ELSE                 : 
ENUM                 : 
EQUAL_TO             : 30
FLOAT                : 22
FN                   : 80 81
FOR                  : 
GREATER_THAN         : 33 80
GREATER_THAN_OR_EQUAL_TO : 35
IDENTIFIER           : 8 8 9 26 28 52 63 64 65 66 68 75 76 78
IF                   : 40
IN                   : 
INTEGER              : 21 62 64 64 65 65 75
LBRACE               : 40 80 81
LBRACKET             : 48 61 62 63 64 65 66
LESS_THAN            : 32
LESS_THAN_OR_EQUAL_TO : 34
LET                  : 52
LOOP                 : 
LPAREN               : 6 7 8 9 14 39 69 72 80 81
MAIN                 : 79
MATCH                : 
MINUS                : 16 80
MINUS_EQUAL          : 
MOD                  : 19
MOD_EQUAL            : 
MUT                  : 28 50 53
NOT                  : 6 7 20 38 66
NOT_EQUAL            : 31
PIPE                 : 
PLUS                 : 15
PLUS_EQUAL           : 
PRINTLN              : 6 7
RANGE                : 64
RANGE_INCLUSIVE      : 65
RBRACE               : 40 80 81
RBRACKET             : 48 61 62 63 64 65 66
RETURN               : 82
RPAREN               : 6 7 8 9 14 39 69 72 80 81
SEMICOLON            : 6 7 52 62 68 82
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
STRING               : 6 23
THEN                 : 
TIMES                : 17
TIMES_EQUAL          : 
TYPE_BOOL            : 46
TYPE_CHAR            : 44
TYPE_F64             : 43
TYPE_I32             : 41
TYPE_STRING          : 45
TYPE_TUPLE           : 47
TYPE_U64             : 42
WHERE                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argumentos_opt       : 9
condicion            : 36 36 37 37 38 39 40
const_decl           : 67
empty                : 4 11 54 56 58 77
expresion            : 7 9 12 13 14 15 15 16 16 17 17 18 18 19 19 20 27 29 30 30 31 31 32 32 33 33 34 34 35 35 57 59 60 62 63 68 73 74 82
let_decl             : 51
lista_argumentos     : 10 12
lista_elementos      : 59 61 66
lista_tipos_tupla    : 69 71
lista_valores_tupla  : 72 74
maybe_init           : 52
maybe_mut            : 52
maybe_pub            : 80 81
maybe_type           : 52
nombre_fn            : 80 81
program              : 1 3 0
program_opt          : 40 80 81
sentencia            : 1 2
tipo                 : 29 48 49 50 55 68 70 71 80

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program sentencia
    (2) program -> . sentencia
    (6) sentencia -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> . PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
    (40) sentencia -> . IF condicion LBRACE program_opt RBRACE
    (51) sentencia -> . let_decl
    (67) sentencia -> . const_decl
    (80) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (82) sentencia -> . RETURN expresion SEMICOLON
    (52) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (68) const_decl -> . CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
    (76) maybe_pub -> . IDENTIFIER
    (77) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 8
    LET             shift and go to state 9
    CONST           shift and go to state 11
    IDENTIFIER      shift and go to state 10
    FN              reduce using rule 5 (empty -> .)

    program                        shift and go to state 1
    sentencia                      shift and go to state 2
    let_decl                       shift and go to state 5
    const_decl                     shift and go to state 6
    maybe_pub                      shift and go to state 7
    empty                          shift and go to state 12

state 1

    (0) S' -> program .
    (1) program -> program . sentencia
    (6) sentencia -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> . PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
    (40) sentencia -> . IF condicion LBRACE program_opt RBRACE
    (51) sentencia -> . let_decl
    (67) sentencia -> . const_decl
    (80) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (82) sentencia -> . RETURN expresion SEMICOLON
    (52) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (68) const_decl -> . CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
    (76) maybe_pub -> . IDENTIFIER
    (77) maybe_pub -> . empty
    (5) empty -> .

    PRINTLN         shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 8
    LET             shift and go to state 9
    CONST           shift and go to state 11
    IDENTIFIER      shift and go to state 10
    FN              reduce using rule 5 (empty -> .)

    sentencia                      shift and go to state 13
    let_decl                       shift and go to state 5
    const_decl                     shift and go to state 6
    maybe_pub                      shift and go to state 7
    empty                          shift and go to state 12

state 2

    (2) program -> sentencia .

    PRINTLN         reduce using rule 2 (program -> sentencia .)
    IF              reduce using rule 2 (program -> sentencia .)
    RETURN          reduce using rule 2 (program -> sentencia .)
    LET             reduce using rule 2 (program -> sentencia .)
    CONST           reduce using rule 2 (program -> sentencia .)
    IDENTIFIER      reduce using rule 2 (program -> sentencia .)
    $end            reduce using rule 2 (program -> sentencia .)
    FN              reduce using rule 2 (program -> sentencia .)
    RBRACE          reduce using rule 2 (program -> sentencia .)


state 3

    (6) sentencia -> PRINTLN . NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> PRINTLN . NOT LPAREN expresion RPAREN SEMICOLON

    NOT             shift and go to state 14


state 4

    (40) sentencia -> IF . condicion LBRACE program_opt RBRACE
    (30) condicion -> . expresion EQUAL_TO expresion
    (31) condicion -> . expresion NOT_EQUAL expresion
    (32) condicion -> . expresion LESS_THAN expresion
    (33) condicion -> . expresion GREATER_THAN expresion
    (34) condicion -> . expresion LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> . expresion GREATER_THAN_OR_EQUAL_TO expresion
    (36) condicion -> . condicion CONJUNCTION condicion
    (37) condicion -> . condicion DISJUNCTION condicion
    (38) condicion -> . NOT condicion
    (39) condicion -> . LPAREN condicion RPAREN
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    NOT             shift and go to state 17
    LPAREN          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    condicion                      shift and go to state 15
    expresion                      shift and go to state 16

state 5

    (51) sentencia -> let_decl .

    PRINTLN         reduce using rule 51 (sentencia -> let_decl .)
    IF              reduce using rule 51 (sentencia -> let_decl .)
    RETURN          reduce using rule 51 (sentencia -> let_decl .)
    LET             reduce using rule 51 (sentencia -> let_decl .)
    CONST           reduce using rule 51 (sentencia -> let_decl .)
    IDENTIFIER      reduce using rule 51 (sentencia -> let_decl .)
    $end            reduce using rule 51 (sentencia -> let_decl .)
    FN              reduce using rule 51 (sentencia -> let_decl .)
    RBRACE          reduce using rule 51 (sentencia -> let_decl .)


state 6

    (67) sentencia -> const_decl .

    PRINTLN         reduce using rule 67 (sentencia -> const_decl .)
    IF              reduce using rule 67 (sentencia -> const_decl .)
    RETURN          reduce using rule 67 (sentencia -> const_decl .)
    LET             reduce using rule 67 (sentencia -> const_decl .)
    CONST           reduce using rule 67 (sentencia -> const_decl .)
    IDENTIFIER      reduce using rule 67 (sentencia -> const_decl .)
    $end            reduce using rule 67 (sentencia -> const_decl .)
    FN              reduce using rule 67 (sentencia -> const_decl .)
    RBRACE          reduce using rule 67 (sentencia -> const_decl .)


state 7

    (80) sentencia -> maybe_pub . FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> maybe_pub . FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE

    FN              shift and go to state 27


state 8

    (82) sentencia -> RETURN . expresion SEMICOLON
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 28

state 9

    (52) let_decl -> LET . maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (53) maybe_mut -> . MUT
    (54) maybe_mut -> . empty
    (5) empty -> .

    MUT             shift and go to state 32
    IDENTIFIER      reduce using rule 5 (empty -> .)

    maybe_mut                      shift and go to state 31
    empty                          shift and go to state 33

state 10

    (76) maybe_pub -> IDENTIFIER .

    FN              reduce using rule 76 (maybe_pub -> IDENTIFIER .)


state 11

    (68) const_decl -> CONST . IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON

    IDENTIFIER      shift and go to state 34


state 12

    (77) maybe_pub -> empty .

    FN              reduce using rule 77 (maybe_pub -> empty .)


state 13

    (1) program -> program sentencia .

    PRINTLN         reduce using rule 1 (program -> program sentencia .)
    IF              reduce using rule 1 (program -> program sentencia .)
    RETURN          reduce using rule 1 (program -> program sentencia .)
    LET             reduce using rule 1 (program -> program sentencia .)
    CONST           reduce using rule 1 (program -> program sentencia .)
    IDENTIFIER      reduce using rule 1 (program -> program sentencia .)
    $end            reduce using rule 1 (program -> program sentencia .)
    FN              reduce using rule 1 (program -> program sentencia .)
    RBRACE          reduce using rule 1 (program -> program sentencia .)


state 14

    (6) sentencia -> PRINTLN NOT . LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> PRINTLN NOT . LPAREN expresion RPAREN SEMICOLON

    LPAREN          shift and go to state 35


state 15

    (40) sentencia -> IF condicion . LBRACE program_opt RBRACE
    (36) condicion -> condicion . CONJUNCTION condicion
    (37) condicion -> condicion . DISJUNCTION condicion

    LBRACE          shift and go to state 36
    CONJUNCTION     shift and go to state 37
    DISJUNCTION     shift and go to state 38


state 16

    (30) condicion -> expresion . EQUAL_TO expresion
    (31) condicion -> expresion . NOT_EQUAL expresion
    (32) condicion -> expresion . LESS_THAN expresion
    (33) condicion -> expresion . GREATER_THAN expresion
    (34) condicion -> expresion . LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> expresion . GREATER_THAN_OR_EQUAL_TO expresion
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    EQUAL_TO        shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    LESS_THAN       shift and go to state 41
    GREATER_THAN    shift and go to state 42
    LESS_THAN_OR_EQUAL_TO shift and go to state 43
    GREATER_THAN_OR_EQUAL_TO shift and go to state 44
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 17

    (38) condicion -> NOT . condicion
    (20) expresion -> NOT . expresion
    (30) condicion -> . expresion EQUAL_TO expresion
    (31) condicion -> . expresion NOT_EQUAL expresion
    (32) condicion -> . expresion LESS_THAN expresion
    (33) condicion -> . expresion GREATER_THAN expresion
    (34) condicion -> . expresion LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> . expresion GREATER_THAN_OR_EQUAL_TO expresion
    (36) condicion -> . condicion CONJUNCTION condicion
    (37) condicion -> . condicion DISJUNCTION condicion
    (38) condicion -> . NOT condicion
    (39) condicion -> . LPAREN condicion RPAREN
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    NOT             shift and go to state 17
    LPAREN          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    condicion                      shift and go to state 52
    expresion                      shift and go to state 53

state 18

    (39) condicion -> LPAREN . condicion RPAREN
    (14) expresion -> LPAREN . expresion RPAREN
    (72) expresion -> LPAREN . lista_valores_tupla RPAREN
    (30) condicion -> . expresion EQUAL_TO expresion
    (31) condicion -> . expresion NOT_EQUAL expresion
    (32) condicion -> . expresion LESS_THAN expresion
    (33) condicion -> . expresion GREATER_THAN expresion
    (34) condicion -> . expresion LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> . expresion GREATER_THAN_OR_EQUAL_TO expresion
    (36) condicion -> . condicion CONJUNCTION condicion
    (37) condicion -> . condicion DISJUNCTION condicion
    (38) condicion -> . NOT condicion
    (39) condicion -> . LPAREN condicion RPAREN
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER
    (73) lista_valores_tupla -> . expresion
    (74) lista_valores_tupla -> . expresion COMMA lista_valores_tupla

    NOT             shift and go to state 17
    LPAREN          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    condicion                      shift and go to state 54
    expresion                      shift and go to state 55
    lista_valores_tupla            shift and go to state 56

state 19

    (8) expresion -> IDENTIFIER . DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (26) expresion -> IDENTIFIER .
    (63) expresion -> IDENTIFIER . LBRACKET expresion RBRACKET
    (64) expresion -> IDENTIFIER . LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> IDENTIFIER . LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> IDENTIFIER . NOT LBRACKET lista_elementos RBRACKET
    (75) expresion -> IDENTIFIER . DOT INTEGER

  ! shift/reduce conflict for DOT resolved as shift
    DOUBLE_COLON    shift and go to state 57
    EQUAL_TO        reduce using rule 26 (expresion -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 26 (expresion -> IDENTIFIER .)
    LESS_THAN       reduce using rule 26 (expresion -> IDENTIFIER .)
    GREATER_THAN    reduce using rule 26 (expresion -> IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 26 (expresion -> IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 26 (expresion -> IDENTIFIER .)
    PLUS            reduce using rule 26 (expresion -> IDENTIFIER .)
    MINUS           reduce using rule 26 (expresion -> IDENTIFIER .)
    TIMES           reduce using rule 26 (expresion -> IDENTIFIER .)
    DIVIDE          reduce using rule 26 (expresion -> IDENTIFIER .)
    MOD             reduce using rule 26 (expresion -> IDENTIFIER .)
    AS              reduce using rule 26 (expresion -> IDENTIFIER .)
    SEMICOLON       reduce using rule 26 (expresion -> IDENTIFIER .)
    RPAREN          reduce using rule 26 (expresion -> IDENTIFIER .)
    COMMA           reduce using rule 26 (expresion -> IDENTIFIER .)
    RBRACKET        reduce using rule 26 (expresion -> IDENTIFIER .)
    LBRACE          reduce using rule 26 (expresion -> IDENTIFIER .)
    CONJUNCTION     reduce using rule 26 (expresion -> IDENTIFIER .)
    DISJUNCTION     reduce using rule 26 (expresion -> IDENTIFIER .)
    LBRACKET        shift and go to state 58
    NOT             shift and go to state 59
    DOT             shift and go to state 60

  ! DOT             [ reduce using rule 26 (expresion -> IDENTIFIER .) ]


state 20

    (21) expresion -> INTEGER .

    EQUAL_TO        reduce using rule 21 (expresion -> INTEGER .)
    NOT_EQUAL       reduce using rule 21 (expresion -> INTEGER .)
    LESS_THAN       reduce using rule 21 (expresion -> INTEGER .)
    GREATER_THAN    reduce using rule 21 (expresion -> INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 21 (expresion -> INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 21 (expresion -> INTEGER .)
    DOT             reduce using rule 21 (expresion -> INTEGER .)
    PLUS            reduce using rule 21 (expresion -> INTEGER .)
    MINUS           reduce using rule 21 (expresion -> INTEGER .)
    TIMES           reduce using rule 21 (expresion -> INTEGER .)
    DIVIDE          reduce using rule 21 (expresion -> INTEGER .)
    MOD             reduce using rule 21 (expresion -> INTEGER .)
    AS              reduce using rule 21 (expresion -> INTEGER .)
    SEMICOLON       reduce using rule 21 (expresion -> INTEGER .)
    RPAREN          reduce using rule 21 (expresion -> INTEGER .)
    COMMA           reduce using rule 21 (expresion -> INTEGER .)
    RBRACKET        reduce using rule 21 (expresion -> INTEGER .)
    LBRACE          reduce using rule 21 (expresion -> INTEGER .)
    CONJUNCTION     reduce using rule 21 (expresion -> INTEGER .)
    DISJUNCTION     reduce using rule 21 (expresion -> INTEGER .)


state 21

    (22) expresion -> FLOAT .

    EQUAL_TO        reduce using rule 22 (expresion -> FLOAT .)
    NOT_EQUAL       reduce using rule 22 (expresion -> FLOAT .)
    LESS_THAN       reduce using rule 22 (expresion -> FLOAT .)
    GREATER_THAN    reduce using rule 22 (expresion -> FLOAT .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 22 (expresion -> FLOAT .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 22 (expresion -> FLOAT .)
    DOT             reduce using rule 22 (expresion -> FLOAT .)
    PLUS            reduce using rule 22 (expresion -> FLOAT .)
    MINUS           reduce using rule 22 (expresion -> FLOAT .)
    TIMES           reduce using rule 22 (expresion -> FLOAT .)
    DIVIDE          reduce using rule 22 (expresion -> FLOAT .)
    MOD             reduce using rule 22 (expresion -> FLOAT .)
    AS              reduce using rule 22 (expresion -> FLOAT .)
    SEMICOLON       reduce using rule 22 (expresion -> FLOAT .)
    RPAREN          reduce using rule 22 (expresion -> FLOAT .)
    COMMA           reduce using rule 22 (expresion -> FLOAT .)
    RBRACKET        reduce using rule 22 (expresion -> FLOAT .)
    LBRACE          reduce using rule 22 (expresion -> FLOAT .)
    CONJUNCTION     reduce using rule 22 (expresion -> FLOAT .)
    DISJUNCTION     reduce using rule 22 (expresion -> FLOAT .)


state 22

    (23) expresion -> STRING .

    EQUAL_TO        reduce using rule 23 (expresion -> STRING .)
    NOT_EQUAL       reduce using rule 23 (expresion -> STRING .)
    LESS_THAN       reduce using rule 23 (expresion -> STRING .)
    GREATER_THAN    reduce using rule 23 (expresion -> STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 23 (expresion -> STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 23 (expresion -> STRING .)
    DOT             reduce using rule 23 (expresion -> STRING .)
    PLUS            reduce using rule 23 (expresion -> STRING .)
    MINUS           reduce using rule 23 (expresion -> STRING .)
    TIMES           reduce using rule 23 (expresion -> STRING .)
    DIVIDE          reduce using rule 23 (expresion -> STRING .)
    MOD             reduce using rule 23 (expresion -> STRING .)
    AS              reduce using rule 23 (expresion -> STRING .)
    SEMICOLON       reduce using rule 23 (expresion -> STRING .)
    RPAREN          reduce using rule 23 (expresion -> STRING .)
    COMMA           reduce using rule 23 (expresion -> STRING .)
    RBRACKET        reduce using rule 23 (expresion -> STRING .)
    LBRACE          reduce using rule 23 (expresion -> STRING .)
    CONJUNCTION     reduce using rule 23 (expresion -> STRING .)
    DISJUNCTION     reduce using rule 23 (expresion -> STRING .)


state 23

    (24) expresion -> CHAR .

    EQUAL_TO        reduce using rule 24 (expresion -> CHAR .)
    NOT_EQUAL       reduce using rule 24 (expresion -> CHAR .)
    LESS_THAN       reduce using rule 24 (expresion -> CHAR .)
    GREATER_THAN    reduce using rule 24 (expresion -> CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 24 (expresion -> CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 24 (expresion -> CHAR .)
    DOT             reduce using rule 24 (expresion -> CHAR .)
    PLUS            reduce using rule 24 (expresion -> CHAR .)
    MINUS           reduce using rule 24 (expresion -> CHAR .)
    TIMES           reduce using rule 24 (expresion -> CHAR .)
    DIVIDE          reduce using rule 24 (expresion -> CHAR .)
    MOD             reduce using rule 24 (expresion -> CHAR .)
    AS              reduce using rule 24 (expresion -> CHAR .)
    SEMICOLON       reduce using rule 24 (expresion -> CHAR .)
    RPAREN          reduce using rule 24 (expresion -> CHAR .)
    COMMA           reduce using rule 24 (expresion -> CHAR .)
    RBRACKET        reduce using rule 24 (expresion -> CHAR .)
    LBRACE          reduce using rule 24 (expresion -> CHAR .)
    CONJUNCTION     reduce using rule 24 (expresion -> CHAR .)
    DISJUNCTION     reduce using rule 24 (expresion -> CHAR .)


state 24

    (25) expresion -> BOOLEAN .

    EQUAL_TO        reduce using rule 25 (expresion -> BOOLEAN .)
    NOT_EQUAL       reduce using rule 25 (expresion -> BOOLEAN .)
    LESS_THAN       reduce using rule 25 (expresion -> BOOLEAN .)
    GREATER_THAN    reduce using rule 25 (expresion -> BOOLEAN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 25 (expresion -> BOOLEAN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 25 (expresion -> BOOLEAN .)
    DOT             reduce using rule 25 (expresion -> BOOLEAN .)
    PLUS            reduce using rule 25 (expresion -> BOOLEAN .)
    MINUS           reduce using rule 25 (expresion -> BOOLEAN .)
    TIMES           reduce using rule 25 (expresion -> BOOLEAN .)
    DIVIDE          reduce using rule 25 (expresion -> BOOLEAN .)
    MOD             reduce using rule 25 (expresion -> BOOLEAN .)
    AS              reduce using rule 25 (expresion -> BOOLEAN .)
    SEMICOLON       reduce using rule 25 (expresion -> BOOLEAN .)
    RPAREN          reduce using rule 25 (expresion -> BOOLEAN .)
    COMMA           reduce using rule 25 (expresion -> BOOLEAN .)
    RBRACKET        reduce using rule 25 (expresion -> BOOLEAN .)
    LBRACE          reduce using rule 25 (expresion -> BOOLEAN .)
    CONJUNCTION     reduce using rule 25 (expresion -> BOOLEAN .)
    DISJUNCTION     reduce using rule 25 (expresion -> BOOLEAN .)


state 25

    (27) expresion -> BIT_AND . expresion
    (28) expresion -> BIT_AND . MUT IDENTIFIER
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    MUT             shift and go to state 62
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 61

state 26

    (61) expresion -> LBRACKET . lista_elementos RBRACKET
    (62) expresion -> LBRACKET . expresion SEMICOLON INTEGER RBRACKET
    (59) lista_elementos -> . lista_elementos COMMA expresion
    (60) lista_elementos -> . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    lista_elementos                shift and go to state 63
    expresion                      shift and go to state 64

state 27

    (80) sentencia -> maybe_pub FN . nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> maybe_pub FN . nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (78) nombre_fn -> . IDENTIFIER
    (79) nombre_fn -> . MAIN

    IDENTIFIER      shift and go to state 66
    MAIN            shift and go to state 67

    nombre_fn                      shift and go to state 65

state 28

    (82) sentencia -> RETURN expresion . SEMICOLON
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    SEMICOLON       shift and go to state 68
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 29

    (14) expresion -> LPAREN . expresion RPAREN
    (72) expresion -> LPAREN . lista_valores_tupla RPAREN
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER
    (73) lista_valores_tupla -> . expresion
    (74) lista_valores_tupla -> . expresion COMMA lista_valores_tupla

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 69
    lista_valores_tupla            shift and go to state 56

state 30

    (20) expresion -> NOT . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 70

state 31

    (52) let_decl -> LET maybe_mut . IDENTIFIER maybe_type maybe_init SEMICOLON

    IDENTIFIER      shift and go to state 71


state 32

    (53) maybe_mut -> MUT .

    IDENTIFIER      reduce using rule 53 (maybe_mut -> MUT .)


state 33

    (54) maybe_mut -> empty .

    IDENTIFIER      reduce using rule 54 (maybe_mut -> empty .)


state 34

    (68) const_decl -> CONST IDENTIFIER . COLON tipo ASIGNED_TO expresion SEMICOLON

    COLON           shift and go to state 72


state 35

    (6) sentencia -> PRINTLN NOT LPAREN . STRING RPAREN SEMICOLON
    (7) sentencia -> PRINTLN NOT LPAREN . expresion RPAREN SEMICOLON
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    STRING          shift and go to state 73
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 74

state 36

    (40) sentencia -> IF condicion LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program sentencia
    (2) program -> . sentencia
    (5) empty -> .
    (6) sentencia -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> . PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
    (40) sentencia -> . IF condicion LBRACE program_opt RBRACE
    (51) sentencia -> . let_decl
    (67) sentencia -> . const_decl
    (80) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (82) sentencia -> . RETURN expresion SEMICOLON
    (52) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (68) const_decl -> . CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
    (76) maybe_pub -> . IDENTIFIER
    (77) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 8
    LET             shift and go to state 9
    CONST           shift and go to state 11
    IDENTIFIER      shift and go to state 10

    program_opt                    shift and go to state 75
    program                        shift and go to state 76
    empty                          shift and go to state 77
    sentencia                      shift and go to state 2
    let_decl                       shift and go to state 5
    const_decl                     shift and go to state 6
    maybe_pub                      shift and go to state 7

state 37

    (36) condicion -> condicion CONJUNCTION . condicion
    (30) condicion -> . expresion EQUAL_TO expresion
    (31) condicion -> . expresion NOT_EQUAL expresion
    (32) condicion -> . expresion LESS_THAN expresion
    (33) condicion -> . expresion GREATER_THAN expresion
    (34) condicion -> . expresion LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> . expresion GREATER_THAN_OR_EQUAL_TO expresion
    (36) condicion -> . condicion CONJUNCTION condicion
    (37) condicion -> . condicion DISJUNCTION condicion
    (38) condicion -> . NOT condicion
    (39) condicion -> . LPAREN condicion RPAREN
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    NOT             shift and go to state 17
    LPAREN          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    condicion                      shift and go to state 78
    expresion                      shift and go to state 16

state 38

    (37) condicion -> condicion DISJUNCTION . condicion
    (30) condicion -> . expresion EQUAL_TO expresion
    (31) condicion -> . expresion NOT_EQUAL expresion
    (32) condicion -> . expresion LESS_THAN expresion
    (33) condicion -> . expresion GREATER_THAN expresion
    (34) condicion -> . expresion LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> . expresion GREATER_THAN_OR_EQUAL_TO expresion
    (36) condicion -> . condicion CONJUNCTION condicion
    (37) condicion -> . condicion DISJUNCTION condicion
    (38) condicion -> . NOT condicion
    (39) condicion -> . LPAREN condicion RPAREN
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    NOT             shift and go to state 17
    LPAREN          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    condicion                      shift and go to state 79
    expresion                      shift and go to state 16

state 39

    (30) condicion -> expresion EQUAL_TO . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 80

state 40

    (31) condicion -> expresion NOT_EQUAL . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 81

state 41

    (32) condicion -> expresion LESS_THAN . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 82

state 42

    (33) condicion -> expresion GREATER_THAN . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 83

state 43

    (34) condicion -> expresion LESS_THAN_OR_EQUAL_TO . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 84

state 44

    (35) condicion -> expresion GREATER_THAN_OR_EQUAL_TO . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 85

state 45

    (9) expresion -> expresion DOT . IDENTIFIER LPAREN argumentos_opt RPAREN

    IDENTIFIER      shift and go to state 86


state 46

    (15) expresion -> expresion PLUS . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 87

state 47

    (16) expresion -> expresion MINUS . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 88

state 48

    (17) expresion -> expresion TIMES . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 89

state 49

    (18) expresion -> expresion DIVIDE . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 90

state 50

    (19) expresion -> expresion MOD . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 91

state 51

    (29) expresion -> expresion AS . tipo
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 92

state 52

    (38) condicion -> NOT condicion .
    (36) condicion -> condicion . CONJUNCTION condicion
    (37) condicion -> condicion . DISJUNCTION condicion

    LBRACE          reduce using rule 38 (condicion -> NOT condicion .)
    CONJUNCTION     reduce using rule 38 (condicion -> NOT condicion .)
    DISJUNCTION     reduce using rule 38 (condicion -> NOT condicion .)
    RPAREN          reduce using rule 38 (condicion -> NOT condicion .)

  ! CONJUNCTION     [ shift and go to state 37 ]
  ! DISJUNCTION     [ shift and go to state 38 ]


state 53

    (20) expresion -> NOT expresion .
    (30) condicion -> expresion . EQUAL_TO expresion
    (31) condicion -> expresion . NOT_EQUAL expresion
    (32) condicion -> expresion . LESS_THAN expresion
    (33) condicion -> expresion . GREATER_THAN expresion
    (34) condicion -> expresion . LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> expresion . GREATER_THAN_OR_EQUAL_TO expresion
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    DOT             reduce using rule 20 (expresion -> NOT expresion .)
    RPAREN          reduce using rule 20 (expresion -> NOT expresion .)
    COMMA           reduce using rule 20 (expresion -> NOT expresion .)
    EQUAL_TO        shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    LESS_THAN       shift and go to state 41
    GREATER_THAN    shift and go to state 42
    LESS_THAN_OR_EQUAL_TO shift and go to state 43
    GREATER_THAN_OR_EQUAL_TO shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51

  ! EQUAL_TO        [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! NOT_EQUAL       [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! LESS_THAN       [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! GREATER_THAN    [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! LESS_THAN_OR_EQUAL_TO [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! GREATER_THAN_OR_EQUAL_TO [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! PLUS            [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! MINUS           [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! TIMES           [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! DIVIDE          [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! MOD             [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! AS              [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! DOT             [ shift and go to state 45 ]


state 54

    (39) condicion -> LPAREN condicion . RPAREN
    (36) condicion -> condicion . CONJUNCTION condicion
    (37) condicion -> condicion . DISJUNCTION condicion

    RPAREN          shift and go to state 103
    CONJUNCTION     shift and go to state 37
    DISJUNCTION     shift and go to state 38


state 55

    (14) expresion -> LPAREN expresion . RPAREN
    (30) condicion -> expresion . EQUAL_TO expresion
    (31) condicion -> expresion . NOT_EQUAL expresion
    (32) condicion -> expresion . LESS_THAN expresion
    (33) condicion -> expresion . GREATER_THAN expresion
    (34) condicion -> expresion . LESS_THAN_OR_EQUAL_TO expresion
    (35) condicion -> expresion . GREATER_THAN_OR_EQUAL_TO expresion
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo
    (73) lista_valores_tupla -> expresion .
    (74) lista_valores_tupla -> expresion . COMMA lista_valores_tupla

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 104
    EQUAL_TO        shift and go to state 39
    NOT_EQUAL       shift and go to state 40
    LESS_THAN       shift and go to state 41
    GREATER_THAN    shift and go to state 42
    LESS_THAN_OR_EQUAL_TO shift and go to state 43
    GREATER_THAN_OR_EQUAL_TO shift and go to state 44
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51
    COMMA           shift and go to state 105

  ! RPAREN          [ reduce using rule 73 (lista_valores_tupla -> expresion .) ]


state 56

    (72) expresion -> LPAREN lista_valores_tupla . RPAREN

    RPAREN          shift and go to state 106


state 57

    (8) expresion -> IDENTIFIER DOUBLE_COLON . IDENTIFIER LPAREN RPAREN

    IDENTIFIER      shift and go to state 107


state 58

    (63) expresion -> IDENTIFIER LBRACKET . expresion RBRACKET
    (64) expresion -> IDENTIFIER LBRACKET . INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> IDENTIFIER LBRACKET . INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    INTEGER         shift and go to state 109
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 108

state 59

    (66) expresion -> IDENTIFIER NOT . LBRACKET lista_elementos RBRACKET

    LBRACKET        shift and go to state 110


state 60

    (75) expresion -> IDENTIFIER DOT . INTEGER

    INTEGER         shift and go to state 111


state 61

    (27) expresion -> BIT_AND expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AS resolved as shift
    EQUAL_TO        reduce using rule 27 (expresion -> BIT_AND expresion .)
    NOT_EQUAL       reduce using rule 27 (expresion -> BIT_AND expresion .)
    LESS_THAN       reduce using rule 27 (expresion -> BIT_AND expresion .)
    GREATER_THAN    reduce using rule 27 (expresion -> BIT_AND expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 27 (expresion -> BIT_AND expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 27 (expresion -> BIT_AND expresion .)
    SEMICOLON       reduce using rule 27 (expresion -> BIT_AND expresion .)
    RPAREN          reduce using rule 27 (expresion -> BIT_AND expresion .)
    COMMA           reduce using rule 27 (expresion -> BIT_AND expresion .)
    RBRACKET        reduce using rule 27 (expresion -> BIT_AND expresion .)
    LBRACE          reduce using rule 27 (expresion -> BIT_AND expresion .)
    CONJUNCTION     reduce using rule 27 (expresion -> BIT_AND expresion .)
    DISJUNCTION     reduce using rule 27 (expresion -> BIT_AND expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51

  ! DOT             [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]
  ! PLUS            [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]
  ! MINUS           [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]
  ! TIMES           [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]
  ! DIVIDE          [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]
  ! MOD             [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]
  ! AS              [ reduce using rule 27 (expresion -> BIT_AND expresion .) ]


state 62

    (28) expresion -> BIT_AND MUT . IDENTIFIER

    IDENTIFIER      shift and go to state 112


state 63

    (61) expresion -> LBRACKET lista_elementos . RBRACKET
    (59) lista_elementos -> lista_elementos . COMMA expresion

    RBRACKET        shift and go to state 113
    COMMA           shift and go to state 114


state 64

    (62) expresion -> LBRACKET expresion . SEMICOLON INTEGER RBRACKET
    (60) lista_elementos -> expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    SEMICOLON       shift and go to state 115
    RBRACKET        reduce using rule 60 (lista_elementos -> expresion .)
    COMMA           reduce using rule 60 (lista_elementos -> expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 65

    (80) sentencia -> maybe_pub FN nombre_fn . LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> maybe_pub FN nombre_fn . LPAREN RPAREN LBRACE program_opt RBRACE

    LPAREN          shift and go to state 116


state 66

    (78) nombre_fn -> IDENTIFIER .

    LPAREN          reduce using rule 78 (nombre_fn -> IDENTIFIER .)


state 67

    (79) nombre_fn -> MAIN .

    LPAREN          reduce using rule 79 (nombre_fn -> MAIN .)


state 68

    (82) sentencia -> RETURN expresion SEMICOLON .

    PRINTLN         reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    IF              reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    RETURN          reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    LET             reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    CONST           reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    IDENTIFIER      reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    $end            reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    FN              reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)
    RBRACE          reduce using rule 82 (sentencia -> RETURN expresion SEMICOLON .)


state 69

    (14) expresion -> LPAREN expresion . RPAREN
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo
    (73) lista_valores_tupla -> expresion .
    (74) lista_valores_tupla -> expresion . COMMA lista_valores_tupla

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 104
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51
    COMMA           shift and go to state 105

  ! RPAREN          [ reduce using rule 73 (lista_valores_tupla -> expresion .) ]


state 70

    (20) expresion -> NOT expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    SEMICOLON       reduce using rule 20 (expresion -> NOT expresion .)
    DOT             reduce using rule 20 (expresion -> NOT expresion .)
    EQUAL_TO        reduce using rule 20 (expresion -> NOT expresion .)
    NOT_EQUAL       reduce using rule 20 (expresion -> NOT expresion .)
    LESS_THAN       reduce using rule 20 (expresion -> NOT expresion .)
    GREATER_THAN    reduce using rule 20 (expresion -> NOT expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 20 (expresion -> NOT expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 20 (expresion -> NOT expresion .)
    RPAREN          reduce using rule 20 (expresion -> NOT expresion .)
    COMMA           reduce using rule 20 (expresion -> NOT expresion .)
    RBRACKET        reduce using rule 20 (expresion -> NOT expresion .)
    LBRACE          reduce using rule 20 (expresion -> NOT expresion .)
    CONJUNCTION     reduce using rule 20 (expresion -> NOT expresion .)
    DISJUNCTION     reduce using rule 20 (expresion -> NOT expresion .)
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51

  ! PLUS            [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! MINUS           [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! TIMES           [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! DIVIDE          [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! MOD             [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! AS              [ reduce using rule 20 (expresion -> NOT expresion .) ]
  ! DOT             [ shift and go to state 45 ]


state 71

    (52) let_decl -> LET maybe_mut IDENTIFIER . maybe_type maybe_init SEMICOLON
    (55) maybe_type -> . COLON tipo
    (56) maybe_type -> . empty
    (5) empty -> .

    COLON           shift and go to state 118
    ASIGNED_TO      reduce using rule 5 (empty -> .)
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_type                     shift and go to state 117
    empty                          shift and go to state 119

state 72

    (68) const_decl -> CONST IDENTIFIER COLON . tipo ASIGNED_TO expresion SEMICOLON
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 120

state 73

    (6) sentencia -> PRINTLN NOT LPAREN STRING . RPAREN SEMICOLON
    (23) expresion -> STRING .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 121
    DOT             reduce using rule 23 (expresion -> STRING .)
    PLUS            reduce using rule 23 (expresion -> STRING .)
    MINUS           reduce using rule 23 (expresion -> STRING .)
    TIMES           reduce using rule 23 (expresion -> STRING .)
    DIVIDE          reduce using rule 23 (expresion -> STRING .)
    MOD             reduce using rule 23 (expresion -> STRING .)
    AS              reduce using rule 23 (expresion -> STRING .)

  ! RPAREN          [ reduce using rule 23 (expresion -> STRING .) ]


state 74

    (7) sentencia -> PRINTLN NOT LPAREN expresion . RPAREN SEMICOLON
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    RPAREN          shift and go to state 122
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 75

    (40) sentencia -> IF condicion LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 123


state 76

    (3) program_opt -> program .
    (1) program -> program . sentencia
    (6) sentencia -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> . PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
    (40) sentencia -> . IF condicion LBRACE program_opt RBRACE
    (51) sentencia -> . let_decl
    (67) sentencia -> . const_decl
    (80) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (82) sentencia -> . RETURN expresion SEMICOLON
    (52) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (68) const_decl -> . CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
    (76) maybe_pub -> . IDENTIFIER
    (77) maybe_pub -> . empty
    (5) empty -> .

    RBRACE          reduce using rule 3 (program_opt -> program .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 8
    LET             shift and go to state 9
    CONST           shift and go to state 11
    IDENTIFIER      shift and go to state 10
    FN              reduce using rule 5 (empty -> .)

    sentencia                      shift and go to state 13
    let_decl                       shift and go to state 5
    const_decl                     shift and go to state 6
    maybe_pub                      shift and go to state 7
    empty                          shift and go to state 12

state 77

    (4) program_opt -> empty .
    (77) maybe_pub -> empty .

    RBRACE          reduce using rule 4 (program_opt -> empty .)
    FN              reduce using rule 77 (maybe_pub -> empty .)


state 78

    (36) condicion -> condicion CONJUNCTION condicion .
    (36) condicion -> condicion . CONJUNCTION condicion
    (37) condicion -> condicion . DISJUNCTION condicion

    LBRACE          reduce using rule 36 (condicion -> condicion CONJUNCTION condicion .)
    CONJUNCTION     reduce using rule 36 (condicion -> condicion CONJUNCTION condicion .)
    DISJUNCTION     reduce using rule 36 (condicion -> condicion CONJUNCTION condicion .)
    RPAREN          reduce using rule 36 (condicion -> condicion CONJUNCTION condicion .)

  ! CONJUNCTION     [ shift and go to state 37 ]
  ! DISJUNCTION     [ shift and go to state 38 ]


state 79

    (37) condicion -> condicion DISJUNCTION condicion .
    (36) condicion -> condicion . CONJUNCTION condicion
    (37) condicion -> condicion . DISJUNCTION condicion

    LBRACE          reduce using rule 37 (condicion -> condicion DISJUNCTION condicion .)
    DISJUNCTION     reduce using rule 37 (condicion -> condicion DISJUNCTION condicion .)
    RPAREN          reduce using rule 37 (condicion -> condicion DISJUNCTION condicion .)
    CONJUNCTION     shift and go to state 37

  ! CONJUNCTION     [ reduce using rule 37 (condicion -> condicion DISJUNCTION condicion .) ]
  ! DISJUNCTION     [ shift and go to state 38 ]


state 80

    (30) condicion -> expresion EQUAL_TO expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    LBRACE          reduce using rule 30 (condicion -> expresion EQUAL_TO expresion .)
    CONJUNCTION     reduce using rule 30 (condicion -> expresion EQUAL_TO expresion .)
    DISJUNCTION     reduce using rule 30 (condicion -> expresion EQUAL_TO expresion .)
    RPAREN          reduce using rule 30 (condicion -> expresion EQUAL_TO expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 81

    (31) condicion -> expresion NOT_EQUAL expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    LBRACE          reduce using rule 31 (condicion -> expresion NOT_EQUAL expresion .)
    CONJUNCTION     reduce using rule 31 (condicion -> expresion NOT_EQUAL expresion .)
    DISJUNCTION     reduce using rule 31 (condicion -> expresion NOT_EQUAL expresion .)
    RPAREN          reduce using rule 31 (condicion -> expresion NOT_EQUAL expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 82

    (32) condicion -> expresion LESS_THAN expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    LBRACE          reduce using rule 32 (condicion -> expresion LESS_THAN expresion .)
    CONJUNCTION     reduce using rule 32 (condicion -> expresion LESS_THAN expresion .)
    DISJUNCTION     reduce using rule 32 (condicion -> expresion LESS_THAN expresion .)
    RPAREN          reduce using rule 32 (condicion -> expresion LESS_THAN expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 83

    (33) condicion -> expresion GREATER_THAN expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    LBRACE          reduce using rule 33 (condicion -> expresion GREATER_THAN expresion .)
    CONJUNCTION     reduce using rule 33 (condicion -> expresion GREATER_THAN expresion .)
    DISJUNCTION     reduce using rule 33 (condicion -> expresion GREATER_THAN expresion .)
    RPAREN          reduce using rule 33 (condicion -> expresion GREATER_THAN expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 84

    (34) condicion -> expresion LESS_THAN_OR_EQUAL_TO expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    LBRACE          reduce using rule 34 (condicion -> expresion LESS_THAN_OR_EQUAL_TO expresion .)
    CONJUNCTION     reduce using rule 34 (condicion -> expresion LESS_THAN_OR_EQUAL_TO expresion .)
    DISJUNCTION     reduce using rule 34 (condicion -> expresion LESS_THAN_OR_EQUAL_TO expresion .)
    RPAREN          reduce using rule 34 (condicion -> expresion LESS_THAN_OR_EQUAL_TO expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 85

    (35) condicion -> expresion GREATER_THAN_OR_EQUAL_TO expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    LBRACE          reduce using rule 35 (condicion -> expresion GREATER_THAN_OR_EQUAL_TO expresion .)
    CONJUNCTION     reduce using rule 35 (condicion -> expresion GREATER_THAN_OR_EQUAL_TO expresion .)
    DISJUNCTION     reduce using rule 35 (condicion -> expresion GREATER_THAN_OR_EQUAL_TO expresion .)
    RPAREN          reduce using rule 35 (condicion -> expresion GREATER_THAN_OR_EQUAL_TO expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 86

    (9) expresion -> expresion DOT IDENTIFIER . LPAREN argumentos_opt RPAREN

    LPAREN          shift and go to state 124


state 87

    (15) expresion -> expresion PLUS expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    EQUAL_TO        reduce using rule 15 (expresion -> expresion PLUS expresion .)
    NOT_EQUAL       reduce using rule 15 (expresion -> expresion PLUS expresion .)
    LESS_THAN       reduce using rule 15 (expresion -> expresion PLUS expresion .)
    GREATER_THAN    reduce using rule 15 (expresion -> expresion PLUS expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 15 (expresion -> expresion PLUS expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 15 (expresion -> expresion PLUS expresion .)
    DOT             reduce using rule 15 (expresion -> expresion PLUS expresion .)
    PLUS            reduce using rule 15 (expresion -> expresion PLUS expresion .)
    MINUS           reduce using rule 15 (expresion -> expresion PLUS expresion .)
    SEMICOLON       reduce using rule 15 (expresion -> expresion PLUS expresion .)
    RPAREN          reduce using rule 15 (expresion -> expresion PLUS expresion .)
    COMMA           reduce using rule 15 (expresion -> expresion PLUS expresion .)
    RBRACKET        reduce using rule 15 (expresion -> expresion PLUS expresion .)
    LBRACE          reduce using rule 15 (expresion -> expresion PLUS expresion .)
    CONJUNCTION     reduce using rule 15 (expresion -> expresion PLUS expresion .)
    DISJUNCTION     reduce using rule 15 (expresion -> expresion PLUS expresion .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51

  ! TIMES           [ reduce using rule 15 (expresion -> expresion PLUS expresion .) ]
  ! DIVIDE          [ reduce using rule 15 (expresion -> expresion PLUS expresion .) ]
  ! MOD             [ reduce using rule 15 (expresion -> expresion PLUS expresion .) ]
  ! AS              [ reduce using rule 15 (expresion -> expresion PLUS expresion .) ]
  ! DOT             [ shift and go to state 45 ]
  ! PLUS            [ shift and go to state 46 ]
  ! MINUS           [ shift and go to state 47 ]


state 88

    (16) expresion -> expresion MINUS expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    EQUAL_TO        reduce using rule 16 (expresion -> expresion MINUS expresion .)
    NOT_EQUAL       reduce using rule 16 (expresion -> expresion MINUS expresion .)
    LESS_THAN       reduce using rule 16 (expresion -> expresion MINUS expresion .)
    GREATER_THAN    reduce using rule 16 (expresion -> expresion MINUS expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 16 (expresion -> expresion MINUS expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 16 (expresion -> expresion MINUS expresion .)
    DOT             reduce using rule 16 (expresion -> expresion MINUS expresion .)
    PLUS            reduce using rule 16 (expresion -> expresion MINUS expresion .)
    MINUS           reduce using rule 16 (expresion -> expresion MINUS expresion .)
    SEMICOLON       reduce using rule 16 (expresion -> expresion MINUS expresion .)
    RPAREN          reduce using rule 16 (expresion -> expresion MINUS expresion .)
    COMMA           reduce using rule 16 (expresion -> expresion MINUS expresion .)
    RBRACKET        reduce using rule 16 (expresion -> expresion MINUS expresion .)
    LBRACE          reduce using rule 16 (expresion -> expresion MINUS expresion .)
    CONJUNCTION     reduce using rule 16 (expresion -> expresion MINUS expresion .)
    DISJUNCTION     reduce using rule 16 (expresion -> expresion MINUS expresion .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51

  ! TIMES           [ reduce using rule 16 (expresion -> expresion MINUS expresion .) ]
  ! DIVIDE          [ reduce using rule 16 (expresion -> expresion MINUS expresion .) ]
  ! MOD             [ reduce using rule 16 (expresion -> expresion MINUS expresion .) ]
  ! AS              [ reduce using rule 16 (expresion -> expresion MINUS expresion .) ]
  ! DOT             [ shift and go to state 45 ]
  ! PLUS            [ shift and go to state 46 ]
  ! MINUS           [ shift and go to state 47 ]


state 89

    (17) expresion -> expresion TIMES expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    EQUAL_TO        reduce using rule 17 (expresion -> expresion TIMES expresion .)
    NOT_EQUAL       reduce using rule 17 (expresion -> expresion TIMES expresion .)
    LESS_THAN       reduce using rule 17 (expresion -> expresion TIMES expresion .)
    GREATER_THAN    reduce using rule 17 (expresion -> expresion TIMES expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 17 (expresion -> expresion TIMES expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 17 (expresion -> expresion TIMES expresion .)
    DOT             reduce using rule 17 (expresion -> expresion TIMES expresion .)
    PLUS            reduce using rule 17 (expresion -> expresion TIMES expresion .)
    MINUS           reduce using rule 17 (expresion -> expresion TIMES expresion .)
    TIMES           reduce using rule 17 (expresion -> expresion TIMES expresion .)
    DIVIDE          reduce using rule 17 (expresion -> expresion TIMES expresion .)
    MOD             reduce using rule 17 (expresion -> expresion TIMES expresion .)
    SEMICOLON       reduce using rule 17 (expresion -> expresion TIMES expresion .)
    RPAREN          reduce using rule 17 (expresion -> expresion TIMES expresion .)
    COMMA           reduce using rule 17 (expresion -> expresion TIMES expresion .)
    RBRACKET        reduce using rule 17 (expresion -> expresion TIMES expresion .)
    LBRACE          reduce using rule 17 (expresion -> expresion TIMES expresion .)
    CONJUNCTION     reduce using rule 17 (expresion -> expresion TIMES expresion .)
    DISJUNCTION     reduce using rule 17 (expresion -> expresion TIMES expresion .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 17 (expresion -> expresion TIMES expresion .) ]
  ! DOT             [ shift and go to state 45 ]
  ! PLUS            [ shift and go to state 46 ]
  ! MINUS           [ shift and go to state 47 ]
  ! TIMES           [ shift and go to state 48 ]
  ! DIVIDE          [ shift and go to state 49 ]
  ! MOD             [ shift and go to state 50 ]


state 90

    (18) expresion -> expresion DIVIDE expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    EQUAL_TO        reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    NOT_EQUAL       reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    LESS_THAN       reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    GREATER_THAN    reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    DOT             reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    PLUS            reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    MINUS           reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    TIMES           reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    DIVIDE          reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    MOD             reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    SEMICOLON       reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    RPAREN          reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    COMMA           reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    RBRACKET        reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    LBRACE          reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    CONJUNCTION     reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    DISJUNCTION     reduce using rule 18 (expresion -> expresion DIVIDE expresion .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 18 (expresion -> expresion DIVIDE expresion .) ]
  ! DOT             [ shift and go to state 45 ]
  ! PLUS            [ shift and go to state 46 ]
  ! MINUS           [ shift and go to state 47 ]
  ! TIMES           [ shift and go to state 48 ]
  ! DIVIDE          [ shift and go to state 49 ]
  ! MOD             [ shift and go to state 50 ]


state 91

    (19) expresion -> expresion MOD expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    EQUAL_TO        reduce using rule 19 (expresion -> expresion MOD expresion .)
    NOT_EQUAL       reduce using rule 19 (expresion -> expresion MOD expresion .)
    LESS_THAN       reduce using rule 19 (expresion -> expresion MOD expresion .)
    GREATER_THAN    reduce using rule 19 (expresion -> expresion MOD expresion .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 19 (expresion -> expresion MOD expresion .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 19 (expresion -> expresion MOD expresion .)
    DOT             reduce using rule 19 (expresion -> expresion MOD expresion .)
    PLUS            reduce using rule 19 (expresion -> expresion MOD expresion .)
    MINUS           reduce using rule 19 (expresion -> expresion MOD expresion .)
    TIMES           reduce using rule 19 (expresion -> expresion MOD expresion .)
    DIVIDE          reduce using rule 19 (expresion -> expresion MOD expresion .)
    MOD             reduce using rule 19 (expresion -> expresion MOD expresion .)
    SEMICOLON       reduce using rule 19 (expresion -> expresion MOD expresion .)
    RPAREN          reduce using rule 19 (expresion -> expresion MOD expresion .)
    COMMA           reduce using rule 19 (expresion -> expresion MOD expresion .)
    RBRACKET        reduce using rule 19 (expresion -> expresion MOD expresion .)
    LBRACE          reduce using rule 19 (expresion -> expresion MOD expresion .)
    CONJUNCTION     reduce using rule 19 (expresion -> expresion MOD expresion .)
    DISJUNCTION     reduce using rule 19 (expresion -> expresion MOD expresion .)
    AS              shift and go to state 51

  ! AS              [ reduce using rule 19 (expresion -> expresion MOD expresion .) ]
  ! DOT             [ shift and go to state 45 ]
  ! PLUS            [ shift and go to state 46 ]
  ! MINUS           [ shift and go to state 47 ]
  ! TIMES           [ shift and go to state 48 ]
  ! DIVIDE          [ shift and go to state 49 ]
  ! MOD             [ shift and go to state 50 ]


state 92

    (29) expresion -> expresion AS tipo .

    EQUAL_TO        reduce using rule 29 (expresion -> expresion AS tipo .)
    NOT_EQUAL       reduce using rule 29 (expresion -> expresion AS tipo .)
    LESS_THAN       reduce using rule 29 (expresion -> expresion AS tipo .)
    GREATER_THAN    reduce using rule 29 (expresion -> expresion AS tipo .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 29 (expresion -> expresion AS tipo .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 29 (expresion -> expresion AS tipo .)
    DOT             reduce using rule 29 (expresion -> expresion AS tipo .)
    PLUS            reduce using rule 29 (expresion -> expresion AS tipo .)
    MINUS           reduce using rule 29 (expresion -> expresion AS tipo .)
    TIMES           reduce using rule 29 (expresion -> expresion AS tipo .)
    DIVIDE          reduce using rule 29 (expresion -> expresion AS tipo .)
    MOD             reduce using rule 29 (expresion -> expresion AS tipo .)
    AS              reduce using rule 29 (expresion -> expresion AS tipo .)
    SEMICOLON       reduce using rule 29 (expresion -> expresion AS tipo .)
    RPAREN          reduce using rule 29 (expresion -> expresion AS tipo .)
    COMMA           reduce using rule 29 (expresion -> expresion AS tipo .)
    RBRACKET        reduce using rule 29 (expresion -> expresion AS tipo .)
    LBRACE          reduce using rule 29 (expresion -> expresion AS tipo .)
    CONJUNCTION     reduce using rule 29 (expresion -> expresion AS tipo .)
    DISJUNCTION     reduce using rule 29 (expresion -> expresion AS tipo .)


state 93

    (41) tipo -> TYPE_I32 .

    EQUAL_TO        reduce using rule 41 (tipo -> TYPE_I32 .)
    NOT_EQUAL       reduce using rule 41 (tipo -> TYPE_I32 .)
    LESS_THAN       reduce using rule 41 (tipo -> TYPE_I32 .)
    GREATER_THAN    reduce using rule 41 (tipo -> TYPE_I32 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 41 (tipo -> TYPE_I32 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 41 (tipo -> TYPE_I32 .)
    DOT             reduce using rule 41 (tipo -> TYPE_I32 .)
    PLUS            reduce using rule 41 (tipo -> TYPE_I32 .)
    MINUS           reduce using rule 41 (tipo -> TYPE_I32 .)
    TIMES           reduce using rule 41 (tipo -> TYPE_I32 .)
    DIVIDE          reduce using rule 41 (tipo -> TYPE_I32 .)
    MOD             reduce using rule 41 (tipo -> TYPE_I32 .)
    AS              reduce using rule 41 (tipo -> TYPE_I32 .)
    SEMICOLON       reduce using rule 41 (tipo -> TYPE_I32 .)
    RPAREN          reduce using rule 41 (tipo -> TYPE_I32 .)
    COMMA           reduce using rule 41 (tipo -> TYPE_I32 .)
    RBRACKET        reduce using rule 41 (tipo -> TYPE_I32 .)
    LBRACE          reduce using rule 41 (tipo -> TYPE_I32 .)
    CONJUNCTION     reduce using rule 41 (tipo -> TYPE_I32 .)
    DISJUNCTION     reduce using rule 41 (tipo -> TYPE_I32 .)
    ASIGNED_TO      reduce using rule 41 (tipo -> TYPE_I32 .)


state 94

    (42) tipo -> TYPE_U64 .

    EQUAL_TO        reduce using rule 42 (tipo -> TYPE_U64 .)
    NOT_EQUAL       reduce using rule 42 (tipo -> TYPE_U64 .)
    LESS_THAN       reduce using rule 42 (tipo -> TYPE_U64 .)
    GREATER_THAN    reduce using rule 42 (tipo -> TYPE_U64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 42 (tipo -> TYPE_U64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 42 (tipo -> TYPE_U64 .)
    DOT             reduce using rule 42 (tipo -> TYPE_U64 .)
    PLUS            reduce using rule 42 (tipo -> TYPE_U64 .)
    MINUS           reduce using rule 42 (tipo -> TYPE_U64 .)
    TIMES           reduce using rule 42 (tipo -> TYPE_U64 .)
    DIVIDE          reduce using rule 42 (tipo -> TYPE_U64 .)
    MOD             reduce using rule 42 (tipo -> TYPE_U64 .)
    AS              reduce using rule 42 (tipo -> TYPE_U64 .)
    SEMICOLON       reduce using rule 42 (tipo -> TYPE_U64 .)
    RPAREN          reduce using rule 42 (tipo -> TYPE_U64 .)
    COMMA           reduce using rule 42 (tipo -> TYPE_U64 .)
    RBRACKET        reduce using rule 42 (tipo -> TYPE_U64 .)
    LBRACE          reduce using rule 42 (tipo -> TYPE_U64 .)
    CONJUNCTION     reduce using rule 42 (tipo -> TYPE_U64 .)
    DISJUNCTION     reduce using rule 42 (tipo -> TYPE_U64 .)
    ASIGNED_TO      reduce using rule 42 (tipo -> TYPE_U64 .)


state 95

    (43) tipo -> TYPE_F64 .

    EQUAL_TO        reduce using rule 43 (tipo -> TYPE_F64 .)
    NOT_EQUAL       reduce using rule 43 (tipo -> TYPE_F64 .)
    LESS_THAN       reduce using rule 43 (tipo -> TYPE_F64 .)
    GREATER_THAN    reduce using rule 43 (tipo -> TYPE_F64 .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 43 (tipo -> TYPE_F64 .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 43 (tipo -> TYPE_F64 .)
    DOT             reduce using rule 43 (tipo -> TYPE_F64 .)
    PLUS            reduce using rule 43 (tipo -> TYPE_F64 .)
    MINUS           reduce using rule 43 (tipo -> TYPE_F64 .)
    TIMES           reduce using rule 43 (tipo -> TYPE_F64 .)
    DIVIDE          reduce using rule 43 (tipo -> TYPE_F64 .)
    MOD             reduce using rule 43 (tipo -> TYPE_F64 .)
    AS              reduce using rule 43 (tipo -> TYPE_F64 .)
    SEMICOLON       reduce using rule 43 (tipo -> TYPE_F64 .)
    RPAREN          reduce using rule 43 (tipo -> TYPE_F64 .)
    COMMA           reduce using rule 43 (tipo -> TYPE_F64 .)
    RBRACKET        reduce using rule 43 (tipo -> TYPE_F64 .)
    LBRACE          reduce using rule 43 (tipo -> TYPE_F64 .)
    CONJUNCTION     reduce using rule 43 (tipo -> TYPE_F64 .)
    DISJUNCTION     reduce using rule 43 (tipo -> TYPE_F64 .)
    ASIGNED_TO      reduce using rule 43 (tipo -> TYPE_F64 .)


state 96

    (44) tipo -> TYPE_CHAR .

    EQUAL_TO        reduce using rule 44 (tipo -> TYPE_CHAR .)
    NOT_EQUAL       reduce using rule 44 (tipo -> TYPE_CHAR .)
    LESS_THAN       reduce using rule 44 (tipo -> TYPE_CHAR .)
    GREATER_THAN    reduce using rule 44 (tipo -> TYPE_CHAR .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 44 (tipo -> TYPE_CHAR .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 44 (tipo -> TYPE_CHAR .)
    DOT             reduce using rule 44 (tipo -> TYPE_CHAR .)
    PLUS            reduce using rule 44 (tipo -> TYPE_CHAR .)
    MINUS           reduce using rule 44 (tipo -> TYPE_CHAR .)
    TIMES           reduce using rule 44 (tipo -> TYPE_CHAR .)
    DIVIDE          reduce using rule 44 (tipo -> TYPE_CHAR .)
    MOD             reduce using rule 44 (tipo -> TYPE_CHAR .)
    AS              reduce using rule 44 (tipo -> TYPE_CHAR .)
    SEMICOLON       reduce using rule 44 (tipo -> TYPE_CHAR .)
    RPAREN          reduce using rule 44 (tipo -> TYPE_CHAR .)
    COMMA           reduce using rule 44 (tipo -> TYPE_CHAR .)
    RBRACKET        reduce using rule 44 (tipo -> TYPE_CHAR .)
    LBRACE          reduce using rule 44 (tipo -> TYPE_CHAR .)
    CONJUNCTION     reduce using rule 44 (tipo -> TYPE_CHAR .)
    DISJUNCTION     reduce using rule 44 (tipo -> TYPE_CHAR .)
    ASIGNED_TO      reduce using rule 44 (tipo -> TYPE_CHAR .)


state 97

    (45) tipo -> TYPE_STRING .

    EQUAL_TO        reduce using rule 45 (tipo -> TYPE_STRING .)
    NOT_EQUAL       reduce using rule 45 (tipo -> TYPE_STRING .)
    LESS_THAN       reduce using rule 45 (tipo -> TYPE_STRING .)
    GREATER_THAN    reduce using rule 45 (tipo -> TYPE_STRING .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 45 (tipo -> TYPE_STRING .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 45 (tipo -> TYPE_STRING .)
    DOT             reduce using rule 45 (tipo -> TYPE_STRING .)
    PLUS            reduce using rule 45 (tipo -> TYPE_STRING .)
    MINUS           reduce using rule 45 (tipo -> TYPE_STRING .)
    TIMES           reduce using rule 45 (tipo -> TYPE_STRING .)
    DIVIDE          reduce using rule 45 (tipo -> TYPE_STRING .)
    MOD             reduce using rule 45 (tipo -> TYPE_STRING .)
    AS              reduce using rule 45 (tipo -> TYPE_STRING .)
    SEMICOLON       reduce using rule 45 (tipo -> TYPE_STRING .)
    RPAREN          reduce using rule 45 (tipo -> TYPE_STRING .)
    COMMA           reduce using rule 45 (tipo -> TYPE_STRING .)
    RBRACKET        reduce using rule 45 (tipo -> TYPE_STRING .)
    LBRACE          reduce using rule 45 (tipo -> TYPE_STRING .)
    CONJUNCTION     reduce using rule 45 (tipo -> TYPE_STRING .)
    DISJUNCTION     reduce using rule 45 (tipo -> TYPE_STRING .)
    ASIGNED_TO      reduce using rule 45 (tipo -> TYPE_STRING .)


state 98

    (46) tipo -> TYPE_BOOL .

    EQUAL_TO        reduce using rule 46 (tipo -> TYPE_BOOL .)
    NOT_EQUAL       reduce using rule 46 (tipo -> TYPE_BOOL .)
    LESS_THAN       reduce using rule 46 (tipo -> TYPE_BOOL .)
    GREATER_THAN    reduce using rule 46 (tipo -> TYPE_BOOL .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 46 (tipo -> TYPE_BOOL .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 46 (tipo -> TYPE_BOOL .)
    DOT             reduce using rule 46 (tipo -> TYPE_BOOL .)
    PLUS            reduce using rule 46 (tipo -> TYPE_BOOL .)
    MINUS           reduce using rule 46 (tipo -> TYPE_BOOL .)
    TIMES           reduce using rule 46 (tipo -> TYPE_BOOL .)
    DIVIDE          reduce using rule 46 (tipo -> TYPE_BOOL .)
    MOD             reduce using rule 46 (tipo -> TYPE_BOOL .)
    AS              reduce using rule 46 (tipo -> TYPE_BOOL .)
    SEMICOLON       reduce using rule 46 (tipo -> TYPE_BOOL .)
    RPAREN          reduce using rule 46 (tipo -> TYPE_BOOL .)
    COMMA           reduce using rule 46 (tipo -> TYPE_BOOL .)
    RBRACKET        reduce using rule 46 (tipo -> TYPE_BOOL .)
    LBRACE          reduce using rule 46 (tipo -> TYPE_BOOL .)
    CONJUNCTION     reduce using rule 46 (tipo -> TYPE_BOOL .)
    DISJUNCTION     reduce using rule 46 (tipo -> TYPE_BOOL .)
    ASIGNED_TO      reduce using rule 46 (tipo -> TYPE_BOOL .)


state 99

    (47) tipo -> TYPE_TUPLE .

    EQUAL_TO        reduce using rule 47 (tipo -> TYPE_TUPLE .)
    NOT_EQUAL       reduce using rule 47 (tipo -> TYPE_TUPLE .)
    LESS_THAN       reduce using rule 47 (tipo -> TYPE_TUPLE .)
    GREATER_THAN    reduce using rule 47 (tipo -> TYPE_TUPLE .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 47 (tipo -> TYPE_TUPLE .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 47 (tipo -> TYPE_TUPLE .)
    DOT             reduce using rule 47 (tipo -> TYPE_TUPLE .)
    PLUS            reduce using rule 47 (tipo -> TYPE_TUPLE .)
    MINUS           reduce using rule 47 (tipo -> TYPE_TUPLE .)
    TIMES           reduce using rule 47 (tipo -> TYPE_TUPLE .)
    DIVIDE          reduce using rule 47 (tipo -> TYPE_TUPLE .)
    MOD             reduce using rule 47 (tipo -> TYPE_TUPLE .)
    AS              reduce using rule 47 (tipo -> TYPE_TUPLE .)
    SEMICOLON       reduce using rule 47 (tipo -> TYPE_TUPLE .)
    RPAREN          reduce using rule 47 (tipo -> TYPE_TUPLE .)
    COMMA           reduce using rule 47 (tipo -> TYPE_TUPLE .)
    RBRACKET        reduce using rule 47 (tipo -> TYPE_TUPLE .)
    LBRACE          reduce using rule 47 (tipo -> TYPE_TUPLE .)
    CONJUNCTION     reduce using rule 47 (tipo -> TYPE_TUPLE .)
    DISJUNCTION     reduce using rule 47 (tipo -> TYPE_TUPLE .)
    ASIGNED_TO      reduce using rule 47 (tipo -> TYPE_TUPLE .)


state 100

    (48) tipo -> LBRACKET . tipo RBRACKET
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 125

state 101

    (49) tipo -> BIT_AND . tipo
    (50) tipo -> BIT_AND . MUT tipo
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    MUT             shift and go to state 127
    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 126

state 102

    (69) tipo -> LPAREN . lista_tipos_tupla RPAREN
    (70) lista_tipos_tupla -> . tipo
    (71) lista_tipos_tupla -> . tipo COMMA lista_tipos_tupla
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    lista_tipos_tupla              shift and go to state 128
    tipo                           shift and go to state 129

state 103

    (39) condicion -> LPAREN condicion RPAREN .

    LBRACE          reduce using rule 39 (condicion -> LPAREN condicion RPAREN .)
    CONJUNCTION     reduce using rule 39 (condicion -> LPAREN condicion RPAREN .)
    DISJUNCTION     reduce using rule 39 (condicion -> LPAREN condicion RPAREN .)
    RPAREN          reduce using rule 39 (condicion -> LPAREN condicion RPAREN .)


state 104

    (14) expresion -> LPAREN expresion RPAREN .

    EQUAL_TO        reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    NOT_EQUAL       reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    LESS_THAN       reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    GREATER_THAN    reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    DOT             reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    TIMES           reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    MOD             reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    AS              reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    SEMICOLON       reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    COMMA           reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    LBRACE          reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    CONJUNCTION     reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)
    DISJUNCTION     reduce using rule 14 (expresion -> LPAREN expresion RPAREN .)


state 105

    (74) lista_valores_tupla -> expresion COMMA . lista_valores_tupla
    (73) lista_valores_tupla -> . expresion
    (74) lista_valores_tupla -> . expresion COMMA lista_valores_tupla
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 130
    lista_valores_tupla            shift and go to state 131

state 106

    (72) expresion -> LPAREN lista_valores_tupla RPAREN .

    EQUAL_TO        reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    NOT_EQUAL       reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    LESS_THAN       reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    GREATER_THAN    reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    DOT             reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    PLUS            reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    MINUS           reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    TIMES           reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    DIVIDE          reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    MOD             reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    AS              reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    SEMICOLON       reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    RPAREN          reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    COMMA           reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    RBRACKET        reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    LBRACE          reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    CONJUNCTION     reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)
    DISJUNCTION     reduce using rule 72 (expresion -> LPAREN lista_valores_tupla RPAREN .)


state 107

    (8) expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER . LPAREN RPAREN

    LPAREN          shift and go to state 132


state 108

    (63) expresion -> IDENTIFIER LBRACKET expresion . RBRACKET
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    RBRACKET        shift and go to state 133
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 109

    (64) expresion -> IDENTIFIER LBRACKET INTEGER . RANGE INTEGER RBRACKET
    (65) expresion -> IDENTIFIER LBRACKET INTEGER . RANGE_INCLUSIVE INTEGER RBRACKET
    (21) expresion -> INTEGER .

    RANGE           shift and go to state 134
    RANGE_INCLUSIVE shift and go to state 135
    RBRACKET        reduce using rule 21 (expresion -> INTEGER .)
    DOT             reduce using rule 21 (expresion -> INTEGER .)
    PLUS            reduce using rule 21 (expresion -> INTEGER .)
    MINUS           reduce using rule 21 (expresion -> INTEGER .)
    TIMES           reduce using rule 21 (expresion -> INTEGER .)
    DIVIDE          reduce using rule 21 (expresion -> INTEGER .)
    MOD             reduce using rule 21 (expresion -> INTEGER .)
    AS              reduce using rule 21 (expresion -> INTEGER .)


state 110

    (66) expresion -> IDENTIFIER NOT LBRACKET . lista_elementos RBRACKET
    (59) lista_elementos -> . lista_elementos COMMA expresion
    (60) lista_elementos -> . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    lista_elementos                shift and go to state 136
    expresion                      shift and go to state 137

state 111

    (75) expresion -> IDENTIFIER DOT INTEGER .

    EQUAL_TO        reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    NOT_EQUAL       reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    LESS_THAN       reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    GREATER_THAN    reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    DOT             reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    PLUS            reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    MINUS           reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    TIMES           reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    DIVIDE          reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    MOD             reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    AS              reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    SEMICOLON       reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    RPAREN          reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    COMMA           reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    RBRACKET        reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    LBRACE          reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    CONJUNCTION     reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)
    DISJUNCTION     reduce using rule 75 (expresion -> IDENTIFIER DOT INTEGER .)


state 112

    (28) expresion -> BIT_AND MUT IDENTIFIER .

    EQUAL_TO        reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    NOT_EQUAL       reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN       reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN    reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    DOT             reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    PLUS            reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    MINUS           reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    TIMES           reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    DIVIDE          reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    MOD             reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    AS              reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    SEMICOLON       reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    RPAREN          reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    COMMA           reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    RBRACKET        reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    LBRACE          reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    CONJUNCTION     reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)
    DISJUNCTION     reduce using rule 28 (expresion -> BIT_AND MUT IDENTIFIER .)


state 113

    (61) expresion -> LBRACKET lista_elementos RBRACKET .

    EQUAL_TO        reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    NOT_EQUAL       reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    LESS_THAN       reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    GREATER_THAN    reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    DOT             reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    PLUS            reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    MINUS           reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    TIMES           reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    DIVIDE          reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    MOD             reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    AS              reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    SEMICOLON       reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    RPAREN          reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    COMMA           reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    RBRACKET        reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    LBRACE          reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    CONJUNCTION     reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)
    DISJUNCTION     reduce using rule 61 (expresion -> LBRACKET lista_elementos RBRACKET .)


state 114

    (59) lista_elementos -> lista_elementos COMMA . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 138

state 115

    (62) expresion -> LBRACKET expresion SEMICOLON . INTEGER RBRACKET

    INTEGER         shift and go to state 139


state 116

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN . RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> maybe_pub FN nombre_fn LPAREN . RPAREN LBRACE program_opt RBRACE

    RPAREN          shift and go to state 140


state 117

    (52) let_decl -> LET maybe_mut IDENTIFIER maybe_type . maybe_init SEMICOLON
    (57) maybe_init -> . ASIGNED_TO expresion
    (58) maybe_init -> . empty
    (5) empty -> .

    ASIGNED_TO      shift and go to state 142
    SEMICOLON       reduce using rule 5 (empty -> .)

    maybe_init                     shift and go to state 141
    empty                          shift and go to state 143

state 118

    (55) maybe_type -> COLON . tipo
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 144

state 119

    (56) maybe_type -> empty .

    ASIGNED_TO      reduce using rule 56 (maybe_type -> empty .)
    SEMICOLON       reduce using rule 56 (maybe_type -> empty .)


state 120

    (68) const_decl -> CONST IDENTIFIER COLON tipo . ASIGNED_TO expresion SEMICOLON

    ASIGNED_TO      shift and go to state 145


state 121

    (6) sentencia -> PRINTLN NOT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 146


state 122

    (7) sentencia -> PRINTLN NOT LPAREN expresion RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 147


state 123

    (40) sentencia -> IF condicion LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    IF              reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    LET             reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    CONST           reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    $end            reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    FN              reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 40 (sentencia -> IF condicion LBRACE program_opt RBRACE .)


state 124

    (9) expresion -> expresion DOT IDENTIFIER LPAREN . argumentos_opt RPAREN
    (10) argumentos_opt -> . lista_argumentos
    (11) argumentos_opt -> . empty
    (12) lista_argumentos -> . lista_argumentos COMMA expresion
    (13) lista_argumentos -> . expresion
    (5) empty -> .
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    RPAREN          reduce using rule 5 (empty -> .)
    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 148
    argumentos_opt                 shift and go to state 149
    lista_argumentos               shift and go to state 150
    empty                          shift and go to state 151

state 125

    (48) tipo -> LBRACKET tipo . RBRACKET

    RBRACKET        shift and go to state 152


state 126

    (49) tipo -> BIT_AND tipo .

    EQUAL_TO        reduce using rule 49 (tipo -> BIT_AND tipo .)
    NOT_EQUAL       reduce using rule 49 (tipo -> BIT_AND tipo .)
    LESS_THAN       reduce using rule 49 (tipo -> BIT_AND tipo .)
    GREATER_THAN    reduce using rule 49 (tipo -> BIT_AND tipo .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 49 (tipo -> BIT_AND tipo .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 49 (tipo -> BIT_AND tipo .)
    DOT             reduce using rule 49 (tipo -> BIT_AND tipo .)
    PLUS            reduce using rule 49 (tipo -> BIT_AND tipo .)
    MINUS           reduce using rule 49 (tipo -> BIT_AND tipo .)
    TIMES           reduce using rule 49 (tipo -> BIT_AND tipo .)
    DIVIDE          reduce using rule 49 (tipo -> BIT_AND tipo .)
    MOD             reduce using rule 49 (tipo -> BIT_AND tipo .)
    AS              reduce using rule 49 (tipo -> BIT_AND tipo .)
    SEMICOLON       reduce using rule 49 (tipo -> BIT_AND tipo .)
    RPAREN          reduce using rule 49 (tipo -> BIT_AND tipo .)
    COMMA           reduce using rule 49 (tipo -> BIT_AND tipo .)
    RBRACKET        reduce using rule 49 (tipo -> BIT_AND tipo .)
    LBRACE          reduce using rule 49 (tipo -> BIT_AND tipo .)
    CONJUNCTION     reduce using rule 49 (tipo -> BIT_AND tipo .)
    DISJUNCTION     reduce using rule 49 (tipo -> BIT_AND tipo .)
    ASIGNED_TO      reduce using rule 49 (tipo -> BIT_AND tipo .)


state 127

    (50) tipo -> BIT_AND MUT . tipo
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 153

state 128

    (69) tipo -> LPAREN lista_tipos_tupla . RPAREN

    RPAREN          shift and go to state 154


state 129

    (70) lista_tipos_tupla -> tipo .
    (71) lista_tipos_tupla -> tipo . COMMA lista_tipos_tupla

    RPAREN          reduce using rule 70 (lista_tipos_tupla -> tipo .)
    COMMA           shift and go to state 155


state 130

    (73) lista_valores_tupla -> expresion .
    (74) lista_valores_tupla -> expresion . COMMA lista_valores_tupla
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    RPAREN          reduce using rule 73 (lista_valores_tupla -> expresion .)
    COMMA           shift and go to state 105
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 131

    (74) lista_valores_tupla -> expresion COMMA lista_valores_tupla .

    RPAREN          reduce using rule 74 (lista_valores_tupla -> expresion COMMA lista_valores_tupla .)


state 132

    (8) expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN . RPAREN

    RPAREN          shift and go to state 156


state 133

    (63) expresion -> IDENTIFIER LBRACKET expresion RBRACKET .

    EQUAL_TO        reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    NOT_EQUAL       reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    LESS_THAN       reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    GREATER_THAN    reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    DOT             reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    PLUS            reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    MINUS           reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    TIMES           reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    DIVIDE          reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    MOD             reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    AS              reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    SEMICOLON       reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    RPAREN          reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    COMMA           reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    RBRACKET        reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    LBRACE          reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    CONJUNCTION     reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)
    DISJUNCTION     reduce using rule 63 (expresion -> IDENTIFIER LBRACKET expresion RBRACKET .)


state 134

    (64) expresion -> IDENTIFIER LBRACKET INTEGER RANGE . INTEGER RBRACKET

    INTEGER         shift and go to state 157


state 135

    (65) expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE . INTEGER RBRACKET

    INTEGER         shift and go to state 158


state 136

    (66) expresion -> IDENTIFIER NOT LBRACKET lista_elementos . RBRACKET
    (59) lista_elementos -> lista_elementos . COMMA expresion

    RBRACKET        shift and go to state 159
    COMMA           shift and go to state 114


state 137

    (60) lista_elementos -> expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    RBRACKET        reduce using rule 60 (lista_elementos -> expresion .)
    COMMA           reduce using rule 60 (lista_elementos -> expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 138

    (59) lista_elementos -> lista_elementos COMMA expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    RBRACKET        reduce using rule 59 (lista_elementos -> lista_elementos COMMA expresion .)
    COMMA           reduce using rule 59 (lista_elementos -> lista_elementos COMMA expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 139

    (62) expresion -> LBRACKET expresion SEMICOLON INTEGER . RBRACKET

    RBRACKET        shift and go to state 160


state 140

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN . MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN . LBRACE program_opt RBRACE

    MINUS           shift and go to state 161
    LBRACE          shift and go to state 162


state 141

    (52) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init . SEMICOLON

    SEMICOLON       shift and go to state 163


state 142

    (57) maybe_init -> ASIGNED_TO . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 164

state 143

    (58) maybe_init -> empty .

    SEMICOLON       reduce using rule 58 (maybe_init -> empty .)


state 144

    (55) maybe_type -> COLON tipo .

    ASIGNED_TO      reduce using rule 55 (maybe_type -> COLON tipo .)
    SEMICOLON       reduce using rule 55 (maybe_type -> COLON tipo .)


state 145

    (68) const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO . expresion SEMICOLON
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 165

state 146

    (6) sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .

    PRINTLN         reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    LET             reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    CONST           reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    $end            reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    FN              reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)
    RBRACE          reduce using rule 6 (sentencia -> PRINTLN NOT LPAREN STRING RPAREN SEMICOLON .)


state 147

    (7) sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .

    PRINTLN         reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    IF              reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    RETURN          reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    LET             reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    CONST           reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    $end            reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    FN              reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)
    RBRACE          reduce using rule 7 (sentencia -> PRINTLN NOT LPAREN expresion RPAREN SEMICOLON .)


state 148

    (13) lista_argumentos -> expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    COMMA           reduce using rule 13 (lista_argumentos -> expresion .)
    RPAREN          reduce using rule 13 (lista_argumentos -> expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 149

    (9) expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt . RPAREN

    RPAREN          shift and go to state 166


state 150

    (10) argumentos_opt -> lista_argumentos .
    (12) lista_argumentos -> lista_argumentos . COMMA expresion

    RPAREN          reduce using rule 10 (argumentos_opt -> lista_argumentos .)
    COMMA           shift and go to state 167


state 151

    (11) argumentos_opt -> empty .

    RPAREN          reduce using rule 11 (argumentos_opt -> empty .)


state 152

    (48) tipo -> LBRACKET tipo RBRACKET .

    EQUAL_TO        reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    NOT_EQUAL       reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    LESS_THAN       reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    GREATER_THAN    reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    DOT             reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    PLUS            reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    MINUS           reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    TIMES           reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    DIVIDE          reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    MOD             reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    AS              reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    SEMICOLON       reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    RPAREN          reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    COMMA           reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    RBRACKET        reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    LBRACE          reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    CONJUNCTION     reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    DISJUNCTION     reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)
    ASIGNED_TO      reduce using rule 48 (tipo -> LBRACKET tipo RBRACKET .)


state 153

    (50) tipo -> BIT_AND MUT tipo .

    EQUAL_TO        reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    NOT_EQUAL       reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    LESS_THAN       reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    GREATER_THAN    reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    DOT             reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    PLUS            reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    MINUS           reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    TIMES           reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    DIVIDE          reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    MOD             reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    AS              reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    SEMICOLON       reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    RPAREN          reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    COMMA           reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    RBRACKET        reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    LBRACE          reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    CONJUNCTION     reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    DISJUNCTION     reduce using rule 50 (tipo -> BIT_AND MUT tipo .)
    ASIGNED_TO      reduce using rule 50 (tipo -> BIT_AND MUT tipo .)


state 154

    (69) tipo -> LPAREN lista_tipos_tupla RPAREN .

    EQUAL_TO        reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    NOT_EQUAL       reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    LESS_THAN       reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    GREATER_THAN    reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    DOT             reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    PLUS            reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    MINUS           reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    TIMES           reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    DIVIDE          reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    MOD             reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    AS              reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    SEMICOLON       reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    RPAREN          reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    COMMA           reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    RBRACKET        reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    LBRACE          reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    CONJUNCTION     reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    DISJUNCTION     reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)
    ASIGNED_TO      reduce using rule 69 (tipo -> LPAREN lista_tipos_tupla RPAREN .)


state 155

    (71) lista_tipos_tupla -> tipo COMMA . lista_tipos_tupla
    (70) lista_tipos_tupla -> . tipo
    (71) lista_tipos_tupla -> . tipo COMMA lista_tipos_tupla
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 129
    lista_tipos_tupla              shift and go to state 168

state 156

    (8) expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .

    EQUAL_TO        reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN       reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN    reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    PLUS            reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MINUS           reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    TIMES           reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DIVIDE          reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    MOD             reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    AS              reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    SEMICOLON       reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    LBRACE          reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    CONJUNCTION     reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)
    DISJUNCTION     reduce using rule 8 (expresion -> IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN .)


state 157

    (64) expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER . RBRACKET

    RBRACKET        shift and go to state 169


state 158

    (65) expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER . RBRACKET

    RBRACKET        shift and go to state 170


state 159

    (66) expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .

    EQUAL_TO        reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    NOT_EQUAL       reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    LESS_THAN       reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    GREATER_THAN    reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    DOT             reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    PLUS            reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    MINUS           reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    TIMES           reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    DIVIDE          reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    MOD             reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    AS              reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    SEMICOLON       reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    RPAREN          reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    COMMA           reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    RBRACKET        reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    LBRACE          reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    CONJUNCTION     reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)
    DISJUNCTION     reduce using rule 66 (expresion -> IDENTIFIER NOT LBRACKET lista_elementos RBRACKET .)


state 160

    (62) expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .

    EQUAL_TO        reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    DOT             reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    PLUS            reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    MINUS           reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    TIMES           reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    DIVIDE          reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    MOD             reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    AS              reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    RPAREN          reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    COMMA           reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    RBRACKET        reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    LBRACE          reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 62 (expresion -> LBRACKET expresion SEMICOLON INTEGER RBRACKET .)


state 161

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS . GREATER_THAN tipo LBRACE program_opt RBRACE

    GREATER_THAN    shift and go to state 171


state 162

    (81) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program sentencia
    (2) program -> . sentencia
    (5) empty -> .
    (6) sentencia -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> . PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
    (40) sentencia -> . IF condicion LBRACE program_opt RBRACE
    (51) sentencia -> . let_decl
    (67) sentencia -> . const_decl
    (80) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (82) sentencia -> . RETURN expresion SEMICOLON
    (52) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (68) const_decl -> . CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
    (76) maybe_pub -> . IDENTIFIER
    (77) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 8
    LET             shift and go to state 9
    CONST           shift and go to state 11
    IDENTIFIER      shift and go to state 10

    maybe_pub                      shift and go to state 7
    program_opt                    shift and go to state 172
    program                        shift and go to state 76
    empty                          shift and go to state 77
    sentencia                      shift and go to state 2
    let_decl                       shift and go to state 5
    const_decl                     shift and go to state 6

state 163

    (52) let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .

    PRINTLN         reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IF              reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RETURN          reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    LET             reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    CONST           reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    IDENTIFIER      reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    $end            reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    FN              reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)
    RBRACE          reduce using rule 52 (let_decl -> LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON .)


state 164

    (57) maybe_init -> ASIGNED_TO expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    SEMICOLON       reduce using rule 57 (maybe_init -> ASIGNED_TO expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 165

    (68) const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion . SEMICOLON
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    SEMICOLON       shift and go to state 173
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 166

    (9) expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .

    EQUAL_TO        reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    NOT_EQUAL       reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    LESS_THAN       reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    GREATER_THAN    reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    DOT             reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    PLUS            reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    MINUS           reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    TIMES           reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    DIVIDE          reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    MOD             reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    AS              reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    SEMICOLON       reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    RPAREN          reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    COMMA           reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    RBRACKET        reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    LBRACE          reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    CONJUNCTION     reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)
    DISJUNCTION     reduce using rule 9 (expresion -> expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN .)


state 167

    (12) lista_argumentos -> lista_argumentos COMMA . expresion
    (8) expresion -> . IDENTIFIER DOUBLE_COLON IDENTIFIER LPAREN RPAREN
    (9) expresion -> . expresion DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (14) expresion -> . LPAREN expresion RPAREN
    (15) expresion -> . expresion PLUS expresion
    (16) expresion -> . expresion MINUS expresion
    (17) expresion -> . expresion TIMES expresion
    (18) expresion -> . expresion DIVIDE expresion
    (19) expresion -> . expresion MOD expresion
    (20) expresion -> . NOT expresion
    (21) expresion -> . INTEGER
    (22) expresion -> . FLOAT
    (23) expresion -> . STRING
    (24) expresion -> . CHAR
    (25) expresion -> . BOOLEAN
    (26) expresion -> . IDENTIFIER
    (27) expresion -> . BIT_AND expresion
    (28) expresion -> . BIT_AND MUT IDENTIFIER
    (29) expresion -> . expresion AS tipo
    (61) expresion -> . LBRACKET lista_elementos RBRACKET
    (62) expresion -> . LBRACKET expresion SEMICOLON INTEGER RBRACKET
    (63) expresion -> . IDENTIFIER LBRACKET expresion RBRACKET
    (64) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET
    (65) expresion -> . IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET
    (66) expresion -> . IDENTIFIER NOT LBRACKET lista_elementos RBRACKET
    (72) expresion -> . LPAREN lista_valores_tupla RPAREN
    (75) expresion -> . IDENTIFIER DOT INTEGER

    IDENTIFIER      shift and go to state 19
    LPAREN          shift and go to state 29
    NOT             shift and go to state 30
    INTEGER         shift and go to state 20
    FLOAT           shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    BOOLEAN         shift and go to state 24
    BIT_AND         shift and go to state 25
    LBRACKET        shift and go to state 26

    expresion                      shift and go to state 174

state 168

    (71) lista_tipos_tupla -> tipo COMMA lista_tipos_tupla .

    RPAREN          reduce using rule 71 (lista_tipos_tupla -> tipo COMMA lista_tipos_tupla .)


state 169

    (64) expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .

    EQUAL_TO        reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DOT             reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    PLUS            reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MINUS           reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    TIMES           reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    MOD             reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    AS              reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RPAREN          reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    COMMA           reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    LBRACE          reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 64 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE INTEGER RBRACKET .)


state 170

    (65) expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .

    EQUAL_TO        reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    NOT_EQUAL       reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN       reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN    reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LESS_THAN_OR_EQUAL_TO reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    GREATER_THAN_OR_EQUAL_TO reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DOT             reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    PLUS            reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MINUS           reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    TIMES           reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DIVIDE          reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    MOD             reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    AS              reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    SEMICOLON       reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RPAREN          reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    COMMA           reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    RBRACKET        reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    LBRACE          reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    CONJUNCTION     reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)
    DISJUNCTION     reduce using rule 65 (expresion -> IDENTIFIER LBRACKET INTEGER RANGE_INCLUSIVE INTEGER RBRACKET .)


state 171

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN . tipo LBRACE program_opt RBRACE
    (41) tipo -> . TYPE_I32
    (42) tipo -> . TYPE_U64
    (43) tipo -> . TYPE_F64
    (44) tipo -> . TYPE_CHAR
    (45) tipo -> . TYPE_STRING
    (46) tipo -> . TYPE_BOOL
    (47) tipo -> . TYPE_TUPLE
    (48) tipo -> . LBRACKET tipo RBRACKET
    (49) tipo -> . BIT_AND tipo
    (50) tipo -> . BIT_AND MUT tipo
    (69) tipo -> . LPAREN lista_tipos_tupla RPAREN

    TYPE_I32        shift and go to state 93
    TYPE_U64        shift and go to state 94
    TYPE_F64        shift and go to state 95
    TYPE_CHAR       shift and go to state 96
    TYPE_STRING     shift and go to state 97
    TYPE_BOOL       shift and go to state 98
    TYPE_TUPLE      shift and go to state 99
    LBRACKET        shift and go to state 100
    BIT_AND         shift and go to state 101
    LPAREN          shift and go to state 102

    tipo                           shift and go to state 175

state 172

    (81) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 176


state 173

    (68) const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .

    PRINTLN         reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    IF              reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    RETURN          reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    LET             reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    CONST           reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    IDENTIFIER      reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    $end            reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    FN              reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)
    RBRACE          reduce using rule 68 (const_decl -> CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON .)


state 174

    (12) lista_argumentos -> lista_argumentos COMMA expresion .
    (9) expresion -> expresion . DOT IDENTIFIER LPAREN argumentos_opt RPAREN
    (15) expresion -> expresion . PLUS expresion
    (16) expresion -> expresion . MINUS expresion
    (17) expresion -> expresion . TIMES expresion
    (18) expresion -> expresion . DIVIDE expresion
    (19) expresion -> expresion . MOD expresion
    (29) expresion -> expresion . AS tipo

    COMMA           reduce using rule 12 (lista_argumentos -> lista_argumentos COMMA expresion .)
    RPAREN          reduce using rule 12 (lista_argumentos -> lista_argumentos COMMA expresion .)
    DOT             shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MOD             shift and go to state 50
    AS              shift and go to state 51


state 175

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo . LBRACE program_opt RBRACE

    LBRACE          shift and go to state 177


state 176

    (81) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    IF              reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    LET             reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    CONST           reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    $end            reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    FN              reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 81 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE .)


state 177

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE . program_opt RBRACE
    (3) program_opt -> . program
    (4) program_opt -> . empty
    (1) program -> . program sentencia
    (2) program -> . sentencia
    (5) empty -> .
    (6) sentencia -> . PRINTLN NOT LPAREN STRING RPAREN SEMICOLON
    (7) sentencia -> . PRINTLN NOT LPAREN expresion RPAREN SEMICOLON
    (40) sentencia -> . IF condicion LBRACE program_opt RBRACE
    (51) sentencia -> . let_decl
    (67) sentencia -> . const_decl
    (80) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE
    (81) sentencia -> . maybe_pub FN nombre_fn LPAREN RPAREN LBRACE program_opt RBRACE
    (82) sentencia -> . RETURN expresion SEMICOLON
    (52) let_decl -> . LET maybe_mut IDENTIFIER maybe_type maybe_init SEMICOLON
    (68) const_decl -> . CONST IDENTIFIER COLON tipo ASIGNED_TO expresion SEMICOLON
    (76) maybe_pub -> . IDENTIFIER
    (77) maybe_pub -> . empty

    RBRACE          reduce using rule 5 (empty -> .)
    FN              reduce using rule 5 (empty -> .)
    PRINTLN         shift and go to state 3
    IF              shift and go to state 4
    RETURN          shift and go to state 8
    LET             shift and go to state 9
    CONST           shift and go to state 11
    IDENTIFIER      shift and go to state 10

    maybe_pub                      shift and go to state 7
    program_opt                    shift and go to state 178
    program                        shift and go to state 76
    empty                          shift and go to state 77
    sentencia                      shift and go to state 2
    let_decl                       shift and go to state 5
    const_decl                     shift and go to state 6

state 178

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt . RBRACE

    RBRACE          shift and go to state 179


state 179

    (80) sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .

    PRINTLN         reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    IF              reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    RETURN          reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    LET             reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    CONST           reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    IDENTIFIER      reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    $end            reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    FN              reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)
    RBRACE          reduce using rule 80 (sentencia -> maybe_pub FN nombre_fn LPAREN RPAREN MINUS GREATER_THAN tipo LBRACE program_opt RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 19 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 55 resolved as shift
WARNING: shift/reduce conflict for DOT in state 61 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 61 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 61 resolved as shift
WARNING: shift/reduce conflict for MOD in state 61 resolved as shift
WARNING: shift/reduce conflict for AS in state 61 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 69 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 73 resolved as shift
